{
    "docs": [
        {
            "location": "/", 
            "text": "Vapor Documentation\n\n\nThis is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.\n\n\nVapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.\n\n\nGetting Started\n\n\nIf this is your first time using Vapor, head to the \nInstall \n macOS\n section to install Swift and Vapor.\n\n\nOnce you have Vapor installed, check out \nGetting Started \n Hello, world\n to create your first Vapor app!\n\n\nLike Vapor?\n\n\nOur small team works hard to make Vapor awesome (and free). Support the framework by \nstarring Vapor on GitHub\n \nor \ndonating $1 monthly\nit helps us a lot. Thanks!\n\n\nOther Sources\n\n\nHere are some other great places to find information about Vapor.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\nlink\n\n\n\n\n\n\n\n\n\n\nVapor Slack\n\n\nChat with ~5,000 Vapor developers.\n\n\nvisit \n\n\n\n\n\n\nAPI docs\n\n\nAuto-generated documentation from code comments.\n\n\nvisit \n\n\n\n\n\n\nStack Overflow\n\n\nAsk and answer questions with the \nvapor\n tag.\n\n\nvisit \n\n\n\n\n\n\nSource Code\n\n\nLearn how Vapor works under the hood.\n\n\nvisit \n\n\n\n\n\n\nGitHub Issues\n\n\nReport bugs or request features on GitHub.\n\n\nvisit \n\n\n\n\n\n\n\n\nProviders\n\n\nVapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the \nvapor-provider\n tag on GitHub.\n\n\nAuthors\n\n\nTanner Nelson\n, \nLogan Wright\n, \nJoannis Orlandos\n, and the hundreds of members of Vapor.", 
            "title": "Overview"
        }, 
        {
            "location": "/#vapor-documentation", 
            "text": "This is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.  Vapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.", 
            "title": "Vapor Documentation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "If this is your first time using Vapor, head to the  Install   macOS  section to install Swift and Vapor.  Once you have Vapor installed, check out  Getting Started   Hello, world  to create your first Vapor app!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#like-vapor", 
            "text": "Our small team works hard to make Vapor awesome (and free). Support the framework by  starring Vapor on GitHub  \nor  donating $1 monthly it helps us a lot. Thanks!", 
            "title": "Like Vapor?"
        }, 
        {
            "location": "/#other-sources", 
            "text": "Here are some other great places to find information about Vapor.     name  description  link      Vapor Slack  Chat with ~5,000 Vapor developers.  visit     API docs  Auto-generated documentation from code comments.  visit     Stack Overflow  Ask and answer questions with the  vapor  tag.  visit     Source Code  Learn how Vapor works under the hood.  visit     GitHub Issues  Report bugs or request features on GitHub.  visit", 
            "title": "Other Sources"
        }, 
        {
            "location": "/#providers", 
            "text": "Vapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the  vapor-provider  tag on GitHub.", 
            "title": "Providers"
        }, 
        {
            "location": "/#authors", 
            "text": "Tanner Nelson ,  Logan Wright ,  Joannis Orlandos , and the hundreds of members of Vapor.", 
            "title": "Authors"
        }, 
        {
            "location": "/install/macos/", 
            "text": "Install on macOS\n\n\nTo use Vapor on macOS, you just need to have Xcode 9 or greater installed.\n\n\n\n\nTip\n\n\nYou need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.\n\n\n\n\nInstall Xcode\n\n\nInstall \nXcode 9 or greater\n from the Mac App Store.\n\n\n\n\n\n\nWarning\n\n\nAfter Xcode has been downloaded, you must open it to finish the installation. This may take a while.\n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nInstall Vapor\n\n\nNow that you have Swift 4, let's install the \nVapor Toolbox\n.\n\n\nThe toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.\n\n\nbrew install vapor/tap/vapor\n\n\n\n\n\n\n\nTip\n\n\nIf you don't already have Homebrew installed, install it at \nbrew.sh \n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.", 
            "title": "macOS"
        }, 
        {
            "location": "/install/macos/#install-on-macos", 
            "text": "To use Vapor on macOS, you just need to have Xcode 9 or greater installed.   Tip  You need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.", 
            "title": "Install on macOS"
        }, 
        {
            "location": "/install/macos/#install-xcode", 
            "text": "Install  Xcode 9 or greater  from the Mac App Store.    Warning  After Xcode has been downloaded, you must open it to finish the installation. This may take a while.", 
            "title": "Install Xcode"
        }, 
        {
            "location": "/install/macos/#verify-installation", 
            "text": "Double check the installation was successful by opening Terminal and running:  swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#install-vapor", 
            "text": "Now that you have Swift 4, let's install the  Vapor Toolbox .  The toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.  brew install vapor/tap/vapor   Tip  If you don't already have Homebrew installed, install it at  brew.sh", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/macos/#verify-installation_1", 
            "text": "Double check the installation was successful by opening Terminal and running:  vapor --help  You should see a long list of available commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/", 
            "text": "Install on Ubuntu\n\n\nInstalling Vapor on Ubuntu only takes a couple of minutes.\n\n\nSupported\n\n\nVapor supports the same versions of Ubuntu that Swift supports.\n\n\n\n\n\n\n\n\nVersion\n\n\nCodename\n\n\n\n\n\n\n\n\n\n\n16.10\n\n\nYakkety Yak\n\n\n\n\n\n\n16.04\n\n\nXenial Xerus\n\n\n\n\n\n\n14.04\n\n\nTrusty Tahr\n\n\n\n\n\n\n\n\nAPT Repo\n\n\nAdd Vapor's APT repo to get access to all of Vapor's Ubuntu packages.\n\n\nQuick Script\n\n\nEasily add Vapor's APT repo with this handy script.\n\n\neval\n \n$(\ncurl -sL https://apt.vapor.sh\n)\n\n\n\n\n\n\n\n\nTip\n\n\nThis command requires \ncurl\n which can be installed using \nsudo apt-get install curl\n\n\n\n\nDockerfile\n\n\nWhen configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:\n\n\nRUN /bin/bash -c \n$(\nwget -qO- https://apt.vapor.sh\n)\n\n\n\n\n\n\nManual\n\n\nOr add the repo manually.\n\n\nwget -q https://repo.vapor.codes/apt/keyring.gpg -O- \n|\n sudo apt-key add -\n\necho\n \ndeb https://repo.vapor.codes/apt \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update\n\n\n\n\n\nInstall Vapor\n\n\nNow that you have added Vapor's APT repo, you can install the required dependencies.\n\n\nsudo apt-get install swift vapor\n\n\n\n\n\nVerify Installation\n\n\nDouble check everything worked with the following commands.\n\n\nSwift\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nVapor Toolbox\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.\n\n\nSwift.org\n\n\nCheck out \nSwift.org\n's guide to \nusing downloads\n if you need more detailed instructions for installing Swift 4.", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#install-on-ubuntu", 
            "text": "Installing Vapor on Ubuntu only takes a couple of minutes.", 
            "title": "Install on Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#supported", 
            "text": "Vapor supports the same versions of Ubuntu that Swift supports.     Version  Codename      16.10  Yakkety Yak    16.04  Xenial Xerus    14.04  Trusty Tahr", 
            "title": "Supported"
        }, 
        {
            "location": "/install/ubuntu/#apt-repo", 
            "text": "Add Vapor's APT repo to get access to all of Vapor's Ubuntu packages.", 
            "title": "APT Repo"
        }, 
        {
            "location": "/install/ubuntu/#quick-script", 
            "text": "Easily add Vapor's APT repo with this handy script.  eval   $( curl -sL https://apt.vapor.sh )    Tip  This command requires  curl  which can be installed using  sudo apt-get install curl", 
            "title": "Quick Script"
        }, 
        {
            "location": "/install/ubuntu/#dockerfile", 
            "text": "When configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:  RUN /bin/bash -c  $( wget -qO- https://apt.vapor.sh )", 
            "title": "Dockerfile"
        }, 
        {
            "location": "/install/ubuntu/#manual", 
            "text": "Or add the repo manually.  wget -q https://repo.vapor.codes/apt/keyring.gpg -O-  |  sudo apt-key add - echo   deb https://repo.vapor.codes/apt  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update", 
            "title": "Manual"
        }, 
        {
            "location": "/install/ubuntu/#install-vapor", 
            "text": "Now that you have added Vapor's APT repo, you can install the required dependencies.  sudo apt-get install swift vapor", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/ubuntu/#verify-installation", 
            "text": "Double check everything worked with the following commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/ubuntu/#swift", 
            "text": "swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Swift"
        }, 
        {
            "location": "/install/ubuntu/#vapor-toolbox", 
            "text": "vapor --help  You should see a long list of available commands.", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/install/ubuntu/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/#swiftorg", 
            "text": "Check out  Swift.org 's guide to  using downloads  if you need more detailed instructions for installing Swift 4.", 
            "title": "Swift.org"
        }, 
        {
            "location": "/getting-started/hello-world/", 
            "text": "Hello, world\n\n\nNow that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.\n\n\nNew Project\n\n\nThe first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project \nHello\n. \n\n\nOpen up your terminal, and use \nVapor Toolbox's \nnew\n command.\n\n\nvapor new Hello\n\n\n\n\n\n\n\nWarning\n\n\nMake sure to add \n--branch=beta\n while using Vapor 3 pre-release.\n\n\n\n\nOnce that finishes, change into the newly created directory.\n\n\ncd\n Hello\n\n\n\n\n\nGenerate Xcode Project\n\n\nLet's now use the \nVapor Toolbox's \nxcode\n command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.\n\n\nvapor xcode\n\n\n\n\n\nThe toolbox will ask you if you'd like to open Xcode automatically, select \nyes\n.\n\n\nBuild \n Run\n\n\nYou should now have Xcode open and running. Select the \nrun scheme\n from the scheme menu,\nthen click the play button.\n\n\nYou should see the terminal pop up at the bottom of the screen.\n\n\nServer starting on localhost:8080\n\n\n\n\n\nVisit Localhost\n\n\nOpen your web browser, and visit \nlocalhost:8080/hello \n\n\nYou should see the following page.\n\n\nHello, world!\n\n\n\n\n\nCongratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#hello-world", 
            "text": "Now that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#new-project", 
            "text": "The first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project  Hello .   Open up your terminal, and use  Vapor Toolbox's  new  command.  vapor new Hello   Warning  Make sure to add  --branch=beta  while using Vapor 3 pre-release.   Once that finishes, change into the newly created directory.  cd  Hello", 
            "title": "New Project"
        }, 
        {
            "location": "/getting-started/hello-world/#generate-xcode-project", 
            "text": "Let's now use the  Vapor Toolbox's  xcode  command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.  vapor xcode  The toolbox will ask you if you'd like to open Xcode automatically, select  yes .", 
            "title": "Generate Xcode Project"
        }, 
        {
            "location": "/getting-started/hello-world/#build-run", 
            "text": "You should now have Xcode open and running. Select the  run scheme  from the scheme menu,\nthen click the play button.  You should see the terminal pop up at the bottom of the screen.  Server starting on localhost:8080", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/hello-world/#visit-localhost", 
            "text": "Open your web browser, and visit  localhost:8080/hello   You should see the following page.  Hello, world!  Congratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Visit Localhost"
        }, 
        {
            "location": "/getting-started/toolbox/", 
            "text": "Install Toolbox\n\n\nVapor's command line interface provides shortcuts and assistance for common tasks.\n\n\n\n\nHelp prints useful information about available commands and flags.\n\n\nvapor --help\n\n\n\n\n\nYou can also run the \n--help\n option on any Toolbox command.\n\n\nvapor new --help\n\n\n\n\n\nThe \n--help\n flag should be your goto for learning about the toolbox as it is the most up-to-date.\n\n\nNew\n\n\nThe Toolbox's most important feature is helping you create a new project.\n\n\nvapor new \nname\n\n\n\n\n\n\nJust pass the name of your project as the first argument to the \nnew\n command.\n\n\n\n\nNote\n\n\nProject names should be \nPascalCase \n, like \nHelloWorld\n or \nMyProject\n.\n\n\n\n\nTemplates\n\n\nBy default, Vapor will create your new project from the API template. You can choose\na different template by passing the \n--template\n flag.\n\n\n\n\n\n\n\n\nName\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\n--template=api\n\n\nJSON API with Fluent database.\n\n\n\n\n\n\nWeb\n\n\n--template=web\n\n\nHTML website with Leaf templates.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nThere are lots of unofficial Vapor templates on GitHub under the \nvapor\n + \ntemplate\n topcs \n.\nYou can use these by passing the full GitHub URL to the \n--template\n option.\n\n\n\n\nBuild \n Run\n\n\nYou can use the toolbox to build and run your Vapor app.\n\n\nvapor build\nvapor run\n\n\n\n\n\n\n\nTip\n\n\nWe recommend building and running through \nXcode\n if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use \nvapor xcode\n to generate an Xcode project.\n\n\n\n\nUpdating\n\n\nThe toolbox should be updated by the package manager it was installed with.\n\n\nHomebrew\n\n\nbrew upgrade vapor\n\n\n\n\n\nAPT\n\n\nsudo apt-get update\nsudo apt-get install vapor", 
            "title": "Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#install-toolbox", 
            "text": "Vapor's command line interface provides shortcuts and assistance for common tasks.   Help prints useful information about available commands and flags.  vapor --help  You can also run the  --help  option on any Toolbox command.  vapor new --help  The  --help  flag should be your goto for learning about the toolbox as it is the most up-to-date.", 
            "title": "Install Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#new", 
            "text": "The Toolbox's most important feature is helping you create a new project.  vapor new  name   Just pass the name of your project as the first argument to the  new  command.   Note  Project names should be  PascalCase  , like  HelloWorld  or  MyProject .", 
            "title": "New"
        }, 
        {
            "location": "/getting-started/toolbox/#templates", 
            "text": "By default, Vapor will create your new project from the API template. You can choose\na different template by passing the  --template  flag.     Name  Flag  Description      API  --template=api  JSON API with Fluent database.    Web  --template=web  HTML website with Leaf templates.      Info  There are lots of unofficial Vapor templates on GitHub under the  vapor  +  template  topcs  .\nYou can use these by passing the full GitHub URL to the  --template  option.", 
            "title": "Templates"
        }, 
        {
            "location": "/getting-started/toolbox/#build-run", 
            "text": "You can use the toolbox to build and run your Vapor app.  vapor build\nvapor run   Tip  We recommend building and running through  Xcode  if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use  vapor xcode  to generate an Xcode project.", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/toolbox/#updating", 
            "text": "The toolbox should be updated by the package manager it was installed with.", 
            "title": "Updating"
        }, 
        {
            "location": "/getting-started/toolbox/#homebrew", 
            "text": "brew upgrade vapor", 
            "title": "Homebrew"
        }, 
        {
            "location": "/getting-started/toolbox/#apt", 
            "text": "sudo apt-get update\nsudo apt-get install vapor", 
            "title": "APT"
        }, 
        {
            "location": "/getting-started/spm/", 
            "text": "Managing your project\n\n\nThe Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the \nVapor Toolbox\n will \ninteract with SPM on your behalf. However, it's important to understand the basics.\n\n\n\n\nTip\n\n\nLearn more about SPM on \nSwift.org \n \n\n\n\n\nPackage Manifest\n\n\nThe first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named \nPackage.swift\n.\n\n\nDependencies\n\n\nDependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n\n        \n// \ud83d\udca7 A server-side Swift web framework. \n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/vapor.git\n,\n \nfrom\n:\n \n3.0.0\n),\n\n    \n],\n\n    \ntargets\n:\n \n[\n \n...\n \n]\n\n\n)\n\n\n\n\n\n\nIn the above example, you can see \nvapor/vapor \n version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which \ntargets\n depend on\nthe newly available modules.\n\n\n\n\nWarning\n\n\nAnytime you modify the package manifest, call \nvapor update\n to effect the changes.\n\n\n\n\nTargets\n\n\nTargets are all of the modules, executables, and tests that your package contains. \n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n \n...\n \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\nname\n:\n \nApp\n,\n \ndependencies\n:\n \n[\nVapor\n]),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nMost Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to \nimport\n them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe \nmain dependencies\n array.\n\n\n\n\nTip\n\n\nExecutable targets (targets that contain a \nmain.swift\n file) cannot be imported by other modules.\nThis is why Vapor has both an \nApp\n and a \nRun\n target.\nAny code you include in \nApp\n can be tested in the \nAppTests\n.\n\n\n\n\nFolder Structure\n\n\nBelow is the typical folder structure for an SPM package.\n\n\n.\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nEach \n.target\n corresponds to a folder in the \nSources\n folder. \nEach \n.testTarget\n corresponds to a folder in the \nTests\n folder.\n\n\nTroubleshooting\n\n\nIf you are experiencing problems with SPM, sometimes cleaning your project can help.\n\n\nvapor clean", 
            "title": "SPM"
        }, 
        {
            "location": "/getting-started/spm/#managing-your-project", 
            "text": "The Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the  Vapor Toolbox  will \ninteract with SPM on your behalf. However, it's important to understand the basics.   Tip  Learn more about SPM on  Swift.org", 
            "title": "Managing your project"
        }, 
        {
            "location": "/getting-started/spm/#package-manifest", 
            "text": "The first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named  Package.swift .", 
            "title": "Package Manifest"
        }, 
        {
            "location": "/getting-started/spm/#dependencies", 
            "text": "Dependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [ \n         // \ud83d\udca7 A server-side Swift web framework.  \n         . package ( url :   https://github.com/vapor/vapor.git ,   from :   3.0.0 ), \n     ], \n     targets :   [   ...   ]  )   In the above example, you can see  vapor/vapor   version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which  targets  depend on\nthe newly available modules.   Warning  Anytime you modify the package manifest, call  vapor update  to effect the changes.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/getting-started/spm/#targets", 
            "text": "Targets are all of the modules, executables, and tests that your package contains.   // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [   ...   ], \n     targets :   [ \n         . target ( name :   App ,   dependencies :   [ Vapor ]), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   Most Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to  import  them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe  main dependencies  array.   Tip  Executable targets (targets that contain a  main.swift  file) cannot be imported by other modules.\nThis is why Vapor has both an  App  and a  Run  target.\nAny code you include in  App  can be tested in the  AppTests .", 
            "title": "Targets"
        }, 
        {
            "location": "/getting-started/spm/#folder-structure", 
            "text": "Below is the typical folder structure for an SPM package.  .\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Each  .target  corresponds to a folder in the  Sources  folder. \nEach  .testTarget  corresponds to a folder in the  Tests  folder.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/spm/#troubleshooting", 
            "text": "If you are experiencing problems with SPM, sometimes cleaning your project can help.  vapor clean", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/getting-started/xcode/", 
            "text": "Xcode\n\n\nIf you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.\n\n\n\n\nXcode is a great way to develop Vapor apps, but you can use any text editor you like.\n\n\nGenerate Project\n\n\nTo use Xcode, you just need to generate an Xcode project using \nVapor Toolbox\n.\n\n\nvapor xcode\n\n\n\n\n\n\n\nTip\n\n\nDon't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.\n\n\n\n\nRun\n\n\nTo build and run your Vapor app, first make sure you have the \nRun\n scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.\n\n\n\n\nOnce that's selected, just click the play button or press \nCommand + R\n on your keyboard.\n\n\nTest\n\n\nTo run your unit tests, select the scheme ending in \n-Package\n and press \nCommand + U\n.\n\n\n\n\nWarning\n\n\nThere may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#xcode", 
            "text": "If you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.   Xcode is a great way to develop Vapor apps, but you can use any text editor you like.", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#generate-project", 
            "text": "To use Xcode, you just need to generate an Xcode project using  Vapor Toolbox .  vapor xcode   Tip  Don't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.", 
            "title": "Generate Project"
        }, 
        {
            "location": "/getting-started/xcode/#run", 
            "text": "To build and run your Vapor app, first make sure you have the  Run  scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.   Once that's selected, just click the play button or press  Command + R  on your keyboard.", 
            "title": "Run"
        }, 
        {
            "location": "/getting-started/xcode/#test", 
            "text": "To run your unit tests, select the scheme ending in  -Package  and press  Command + U .   Warning  There may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Test"
        }, 
        {
            "location": "/getting-started/structure/", 
            "text": "Structure\n\n\nThis section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.\n\n\nFolder Structure\n\n\nVapor's folder structure builds on top of \nSPM's folder structure\n.\n\n\n.\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nLet's take a look at what each of these folders and files does.\n\n\nPublic\n\n\nThis folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.\n\n\nWhenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.\n\n\nFor example, a request to \nlocalhost:8080/favicon.ico\n will check to see\nif \nPublic/favicon.ico\n exists. If it does, Vapor will return it.\n\n\nSources\n\n\nThis folder contains all of the Swift source files for your project. \nThe top level folders (\nApp\n and \nRun\n) reflect your package's modules, \nas declared in the \npackage manifest\n.\n\n\nApp\n\n\nThis is the most important folder in your application, it's where all of\nthe application logic goes!\n\n\nControllers\n\n\nControllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.\n\n\n\n\nTip\n\n\nVapor supports, but does not enforce the MVC pattern\n\n\n\n\nModels\n\n\nThe \nModels\n folder is a great place to store your \nContent\n structs or\nFluent \nModel\ns.\n\n\nboot.swift\n\n\nThis file contains a function that will be called \nafter\n your application has booted,\nbut \nbefore\n it has started running. This is a great place do things that should happen \nevery time your application starts.\n\n\nYou have access to the \nApplication\n here which you can use to create\nany \nservices\n you might need.\n\n\nconfigure.swift\n\n\nThis file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register \n\nservices\n to your application.\n\n\nroutes.swift\n\n\nThis file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.\n\n\nYou'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.\n\n\nYou can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection. \n\n\nTests\n\n\nEach non-executable module in your \nSources\n folder should have a corresponding \n...Tests\n folder.\n\n\nAppTests\n\n\nThis folder contains the unit tests for code in your \nApp\n module. \nLearn more about testing in \nTesting \n Getting Started\n.\n\n\nPackage.swift\n\n\nFinally is SPM's \npackage manifest\n.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#structure", 
            "text": "This section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.", 
            "title": "Structure"
        }, 
        {
            "location": "/getting-started/structure/#folder-structure", 
            "text": "Vapor's folder structure builds on top of  SPM's folder structure .  .\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Let's take a look at what each of these folders and files does.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#public", 
            "text": "This folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.  Whenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.  For example, a request to  localhost:8080/favicon.ico  will check to see\nif  Public/favicon.ico  exists. If it does, Vapor will return it.", 
            "title": "Public"
        }, 
        {
            "location": "/getting-started/structure/#sources", 
            "text": "This folder contains all of the Swift source files for your project. \nThe top level folders ( App  and  Run ) reflect your package's modules, \nas declared in the  package manifest .", 
            "title": "Sources"
        }, 
        {
            "location": "/getting-started/structure/#app", 
            "text": "This is the most important folder in your application, it's where all of\nthe application logic goes!", 
            "title": "App"
        }, 
        {
            "location": "/getting-started/structure/#controllers", 
            "text": "Controllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.   Tip  Vapor supports, but does not enforce the MVC pattern", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/structure/#models", 
            "text": "The  Models  folder is a great place to store your  Content  structs or\nFluent  Model s.", 
            "title": "Models"
        }, 
        {
            "location": "/getting-started/structure/#bootswift", 
            "text": "This file contains a function that will be called  after  your application has booted,\nbut  before  it has started running. This is a great place do things that should happen \nevery time your application starts.  You have access to the  Application  here which you can use to create\nany  services  you might need.", 
            "title": "boot.swift"
        }, 
        {
            "location": "/getting-started/structure/#configureswift", 
            "text": "This file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register  services  to your application.", 
            "title": "configure.swift"
        }, 
        {
            "location": "/getting-started/structure/#routesswift", 
            "text": "This file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.  You'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.  You can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection.", 
            "title": "routes.swift"
        }, 
        {
            "location": "/getting-started/structure/#tests", 
            "text": "Each non-executable module in your  Sources  folder should have a corresponding  ...Tests  folder.", 
            "title": "Tests"
        }, 
        {
            "location": "/getting-started/structure/#apptests", 
            "text": "This folder contains the unit tests for code in your  App  module. \nLearn more about testing in  Testing   Getting Started .", 
            "title": "AppTests"
        }, 
        {
            "location": "/getting-started/structure/#packageswift", 
            "text": "Finally is SPM's  package manifest .", 
            "title": "Package.swift"
        }, 
        {
            "location": "/getting-started/application/", 
            "text": "Application\n\n\nEvery Vapor project has an \nApplication\n. You use the application to create any services\nyou might need while developing. \n\n\nThe best place to access the application is in your project's \nboot.swift\n file.\n\n\nimport\n \nVapor\n\n\n\npublic\n \nfunc\n \nboot\n(\n_\n \napp\n:\n \nApplication\n)\n \nthrows\n \n{\n\n    \n// your code here\n\n\n}\n\n\n\n\n\n\nYou can also access the application from your \nroutes.swift\n file. It's stored\nas a property there.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \nlet\n \napp\n:\n \nApplication\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nUnlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.\n\n\n\n\nInfo\n\n\nAvoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.\n\n\n\n\nServices\n\n\nThe application's main function is to make services. For example, you might need a \nBCryptHasher\n to hash\nsome passwords before storing them in a database. You can use the application to create one.\n\n\nimport\n \nBCrypt\n\n\n\nlet\n \nbcryptHasher\n \n=\n \ntry\n \napp\n.\nmake\n(\nBCryptHasher\n.\nself\n)\n\n\n\n\n\n\nOr you might use the application to create an HTTP client.\n\n\nlet\n \nclient\n \n=\n \ntry\n \napp\n.\nmake\n(\nClient\n.\nself\n)\n\n\nlet\n \nres\n \n=\n \nclient\n.\nget\n(\nhttp://vapor.codes\n)\n\n\n\n\n\n\nLearn more about services in \nServices \n Getting Started\n.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#application", 
            "text": "Every Vapor project has an  Application . You use the application to create any services\nyou might need while developing.   The best place to access the application is in your project's  boot.swift  file.  import   Vapor  public   func   boot ( _   app :   Application )   throws   { \n     // your code here  }   You can also access the application from your  routes.swift  file. It's stored\nas a property there.  import   Vapor  final   class   Routes :   RouteCollection   { \n     let   app :   Application \n\n     ...  }   Unlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.   Info  Avoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#services", 
            "text": "The application's main function is to make services. For example, you might need a  BCryptHasher  to hash\nsome passwords before storing them in a database. You can use the application to create one.  import   BCrypt  let   bcryptHasher   =   try   app . make ( BCryptHasher . self )   Or you might use the application to create an HTTP client.  let   client   =   try   app . make ( Client . self )  let   res   =   client . get ( http://vapor.codes )   Learn more about services in  Services   Getting Started .", 
            "title": "Services"
        }, 
        {
            "location": "/getting-started/controllers/", 
            "text": "Controllers\n\n\nControllers are a great way to organization your code. They are collections of methods that accept\na request and return a response.\n\n\nA good place to put your controllers is in the \nControllers\n folder.\n\n\nMethods\n\n\nLet's take a look at an example controller.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nfunc\n \ngreet\n(\n_\n \nreq\n:\n \nRequest\n)\n \nthrows\n \n-\n \nString\n \n{\n\n        \nreturn\n \nHello!\n\n    \n}\n\n\n}\n\n\n\n\n\n\nController methods should always accept a \nRequest\n and return something \nResponseRepresentable\n. \nThis also includes \nfutures\n whose expectations are \nResponseRepresentable\n (i.e, \nFuture\nString\n).\n\n\nTo use this controller, we can simply initialize it, then pass the method to a router.\n\n\nlet\n \nhelloController\n \n=\n \nHelloController\n()\n\n\nrouter\n.\nget\n(\ngreet\n,\n \nuse\n:\n \nhelloController\n.\ngreet\n)\n\n\n\n\n\n\nUse Services\n\n\nYou will probably want to access your \napplication's services\n from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nlet\n \nhasher\n:\n \nBCryptHasher\n\n\n    \ninit\n(\nhasher\n:\n \nBCryptHasher\n)\n \n{\n\n        \nself\n.\nhasher\n \n=\n \nhasher\n\n    \n}\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nNext, use the \napplication\n to create these services when you initialize your controller.\n\n\nlet\n \nhelloController\n \n=\n \ntry\n \nHelloController\n(\n\n    \nhasher\n:\n \napp\n.\nmake\n()\n\n\n)", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#controllers", 
            "text": "Controllers are a great way to organization your code. They are collections of methods that accept\na request and return a response.  A good place to put your controllers is in the  Controllers  folder.", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#methods", 
            "text": "Let's take a look at an example controller.  import   Vapor  final   class   HelloController   { \n     func   greet ( _   req :   Request )   throws   -   String   { \n         return   Hello! \n     }  }   Controller methods should always accept a  Request  and return something  ResponseRepresentable . \nThis also includes  futures  whose expectations are  ResponseRepresentable  (i.e,  Future String ).  To use this controller, we can simply initialize it, then pass the method to a router.  let   helloController   =   HelloController ()  router . get ( greet ,   use :   helloController . greet )", 
            "title": "Methods"
        }, 
        {
            "location": "/getting-started/controllers/#use-services", 
            "text": "You will probably want to access your  application's services  from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.  final   class   HelloController   { \n     let   hasher :   BCryptHasher \n\n     init ( hasher :   BCryptHasher )   { \n         self . hasher   =   hasher \n     } \n\n     ...  }   Next, use the  application  to create these services when you initialize your controller.  let   helloController   =   try   HelloController ( \n     hasher :   app . make ()  )", 
            "title": "Use Services"
        }, 
        {
            "location": "/getting-started/json/", 
            "text": "", 
            "title": "JSON"
        }, 
        {
            "location": "/getting-started/routing/", 
            "text": "Routing\n\n\nRouting is the process of finding the appropriate response to an incoming request.\nFor example, imagine you want to return a list of users when someone visits \nGET /users\n. \nThat would look something like this.\n\n\nrouter\n.\nget\n(\nusers\n)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \n// fetch the users\n\n\n}\n\n\n\n\n\n\nIn Vapor, routing is usually done using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands. \nYou can supply the path as \n/\n or comma-separated strings. We recommend comma separated, as it's more readable.\n\n\nrouter\n.\nget\n(\npath\n,\n \nto\n,\n \nsomething\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nRoutes\n\n\nThe best place to add routes is in the \nroutes.swift\n file.\nYou will find a router there that is ready to use.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \n...\n\n\n    \nfunc\n \nboot\n(\nrouter\n:\n \nRouter\n)\n \nthrows\n \n{\n\n        \nrouter\n.\nget\n(\nhello\n)\n \n{\n \nreq\n \nin\n\n            \nreturn\n \nHello, world!\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can return anything that conforms to \nContent\n in a route closure. This includes \nfutures\n \nwhose expectation is Content as well.\n\n\nParameters\n\n\nSometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e., \nGET /users/:id\n\n\nrouter\n.\nget\n(\nusers\n,\n \nInt\n.\nself\n)\n \n{\n \nreq\n \nin\n\n    \nlet\n \nid\n \n=\n \ntry\n \nreq\n.\nparameters\n.\nnext\n(\nInt\n.\nself\n)\n\n    \nreturn\n \n// fetch the user with id\n\n\n}\n\n\n\n\n\n\nInstead of passing a string, pass the \ntype\n of parameter you expect. In this case, our \nUser\n has an \nInt\n ID.\n\n\n\n\nTip\n\n\nYou can define your own \ncustom parameter types\n as well.", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#routing", 
            "text": "Routing is the process of finding the appropriate response to an incoming request.\nFor example, imagine you want to return a list of users when someone visits  GET /users . \nThat would look something like this.  router . get ( users )   {   req   in \n     return   // fetch the users  }   In Vapor, routing is usually done using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands. \nYou can supply the path as  /  or comma-separated strings. We recommend comma separated, as it's more readable.  router . get ( path ,   to ,   something )   {   ...   }", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#routes", 
            "text": "The best place to add routes is in the  routes.swift  file.\nYou will find a router there that is ready to use.  import   Vapor  final   class   Routes :   RouteCollection   { \n     ... \n\n     func   boot ( router :   Router )   throws   { \n         router . get ( hello )   {   req   in \n             return   Hello, world! \n         } \n     }  }   You can return anything that conforms to  Content  in a route closure. This includes  futures  \nwhose expectation is Content as well.", 
            "title": "Routes"
        }, 
        {
            "location": "/getting-started/routing/#parameters", 
            "text": "Sometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e.,  GET /users/:id  router . get ( users ,   Int . self )   {   req   in \n     let   id   =   try   req . parameters . next ( Int . self ) \n     return   // fetch the user with id  }   Instead of passing a string, pass the  type  of parameter you expect. In this case, our  User  has an  Int  ID.   Tip  You can define your own  custom parameter types  as well.", 
            "title": "Parameters"
        }, 
        {
            "location": "/getting-started/content/", 
            "text": "Content\n\n\nIn Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a \nCodable\n class or struct.\n\n\nFor this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.\n\n\nRequest\n\n\nLet's take a look at how you would parse the following HTTP request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nemail\n:\n \nuser@vapor.codes\n,\n\n    \npassword\n:\n \ndon\nt look!\n\n\n}\n\n\n\n\n\n\nDecode Request\n\n\nFirst, create a struct or class that represents the data you expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nLoginRequest\n:\n \nContent\n \n{\n\n    \nvar\n \nemail\n:\n \nString\n\n    \nvar\n \npassword\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen simply conform this struct or class to \nContent\n.\nNow we are ready to decode that HTTP request.\n\n\nrouter\n.\npost\n(\nlogin\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nloginRequest\n \n=\n \ntry\n \nreq\n.\ncontent\n(\nLoginRequest\n.\nself\n)\n\n\n    \nprint\n(\nloginRequest\n.\nemail\n)\n \n// user@vapor.codes\n\n    \nprint\n(\nloginRequest\n.\npassword\n)\n \n// don\nt look!\n\n\n    \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}\n\n\n\n\n\n\nIt's that simple!\n\n\nOther Request Types\n\n\nSince the request in the previous example declared JSON as it's content type, \nVapor knows to use a JSON decoder automatically. \nThis same method would work just as well for the following request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/x-www-form-urlencoded\n\n\nemail=user@vapor.codes\ndon\nt+look!\n\n\n\n\n\n\n\nTip\n\n\nYou can configure which encoders/decoders Vapor uses. Read on to learn more.\n\n\n\n\nResponse\n\n\nLet's take a look at how you would create the following HTTP response.\n\n\nHTTP\n/\n1.1\n \n200\n \nOK\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nname\n:\n \nVapor User\n,\n\n    \nemail\n:\n \nuser@vapor.codes\n\n\n}\n\n\n\n\n\n\nEncode Response\n\n\nJust like decoding, first create a struct or class that represents the data your expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nemail\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen just conform this struct or class to \nContent\n.\nNow we are ready to encode that HTTP response.\n\n\nrouter\n.\nget\n(\nuser\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nuser\n \n=\n \nUser\n(\n\n        \nname\n:\n \nVapor User\n,\n \n        \nemail\n:\n \nuser@vapor.codes\n\n    \n)\n\n\n    \nlet\n \nres\n \n=\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n    \ntry\n \nres\n.\ncontent\n(\nuser\n)\n\n    \nreturn\n \nres\n\n\n}\n\n\n\n\n\n\nEven better, if you don't need to configure any properties on the response, you can \nsimply return the user directly.\n\n\nrouter\n.\nget\n(\nuser\n)\n \n{\n \nreq\n \n-\n \nUser\n \nin\n\n    \nlet\n \nuser\n \n=\n \nUser\n(\n\n        \nname\n:\n \nVapor User\n,\n \n        \nemail\n:\n \nuser@vapor.codes\n\n    \n)\n\n\n    \nreturn\n \nuser\n\n\n}\n\n\n\n\n\n\nOther Response Types\n\n\nContent will automatically encode as JSON by default. You can always override which content type is used\nusing the \nas:\n parameter.\n\n\ntry\n \nres\n.\ncontent\n(\nuser\n,\n \nas\n:\n \n.\nformURLEncoded\n)\n\n\n\n\n\n\nYou can also change the default media type for any class or struct.\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \n/// See Content.defaultMediaType\n\n    \nstatic\n \nlet\n \ndefaultMediaType\n:\n \nMediaType\n \n=\n \n.\nformURLEncoded\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nConfiguring Content\n\n\nComing soon.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#content", 
            "text": "In Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a  Codable  class or struct.  For this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#request", 
            "text": "Let's take a look at how you would parse the following HTTP request.  POST   /login   HTTP / 1.1  Content-Type :   application/json  { \n     email :   user@vapor.codes , \n     password :   don t look!  }", 
            "title": "Request"
        }, 
        {
            "location": "/getting-started/content/#decode-request", 
            "text": "First, create a struct or class that represents the data you expect.  import   Foundation  import   Vapor  struct   LoginRequest :   Content   { \n     var   email :   String \n     var   password :   String  }   Then simply conform this struct or class to  Content .\nNow we are ready to decode that HTTP request.  router . post ( login )   {   req   -   Response   in \n     let   loginRequest   =   try   req . content ( LoginRequest . self ) \n\n     print ( loginRequest . email )   // user@vapor.codes \n     print ( loginRequest . password )   // don t look! \n\n     return   Response ( status :   . ok )  }   It's that simple!", 
            "title": "Decode Request"
        }, 
        {
            "location": "/getting-started/content/#other-request-types", 
            "text": "Since the request in the previous example declared JSON as it's content type, \nVapor knows to use a JSON decoder automatically. \nThis same method would work just as well for the following request.  POST   /login   HTTP / 1.1  Content-Type :   application/x-www-form-urlencoded \n\nemail=user@vapor.codes don t+look!   Tip  You can configure which encoders/decoders Vapor uses. Read on to learn more.", 
            "title": "Other Request Types"
        }, 
        {
            "location": "/getting-started/content/#response", 
            "text": "Let's take a look at how you would create the following HTTP response.  HTTP / 1.1   200   OK  Content-Type :   application/json  { \n     name :   Vapor User , \n     email :   user@vapor.codes  }", 
            "title": "Response"
        }, 
        {
            "location": "/getting-started/content/#encode-response", 
            "text": "Just like decoding, first create a struct or class that represents the data your expect.  import   Foundation  import   Vapor  struct   User :   Content   { \n     var   name :   String \n     var   email :   String  }   Then just conform this struct or class to  Content .\nNow we are ready to encode that HTTP response.  router . get ( user )   {   req   -   Response   in \n     let   user   =   User ( \n         name :   Vapor User ,  \n         email :   user@vapor.codes \n     ) \n\n     let   res   =   Response ( status :   . ok ) \n     try   res . content ( user ) \n     return   res  }   Even better, if you don't need to configure any properties on the response, you can \nsimply return the user directly.  router . get ( user )   {   req   -   User   in \n     let   user   =   User ( \n         name :   Vapor User ,  \n         email :   user@vapor.codes \n     ) \n\n     return   user  }", 
            "title": "Encode Response"
        }, 
        {
            "location": "/getting-started/content/#other-response-types", 
            "text": "Content will automatically encode as JSON by default. You can always override which content type is used\nusing the  as:  parameter.  try   res . content ( user ,   as :   . formURLEncoded )   You can also change the default media type for any class or struct.  struct   User :   Content   { \n     /// See Content.defaultMediaType \n     static   let   defaultMediaType :   MediaType   =   . formURLEncoded \n\n     ...  }", 
            "title": "Other Response Types"
        }, 
        {
            "location": "/getting-started/content/#configuring-content", 
            "text": "Coming soon.", 
            "title": "Configuring Content"
        }, 
        {
            "location": "/getting-started/futures/", 
            "text": "Futures\n\n\nYou may have noticed some APIs in Vapor expect or return a \nFuture\nT\n type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.\n\n\nCallbacks\n\n\nFutures are a way of representing an object that you don't have yet. You have probably seen\nAPIs that use callbacks before (especially if you have developed iOS apps). Futures are just a\nway to make APIs with callbacks more user-friendly.\n\n\nThis is a what a common callback API looks like.\n\n\napi\n.\ngetUsers\n(\nonCompletion\n:\n \n{\n \nusers\n,\n \nerror\n \nin\n\n    \n// check if there\ns an error\n\n    \n// do something with the users\n\n\n})\n\n\n\n\n\n\nWith futures, we don't have to supply a callback. We get back instead \nFuture\n[User]\n.\n\n\nlet\n \nusers\n \n=\n \napi\n.\ngetUsers\n()\n\n\nprint\n(\nusers\n)\n \n// Future\n[User]\n\n\n\n\n\n\n\n\nInfo\n\n\nFutures use fewer system resources than synchronous APIs. This is part of\nwhat makes Vapor so fast!\n\n\n\n\nChaining\n\n\nWhat's great about futures is they allow us to chain multiple actions together without nesting callbacks.\n\n\nLet's take a look at an example of this with callbacks.\n\n\napi\n.\ndoThingOne\n(\nonCompletion\n:\n \n{\n \none\n,\n \nerror\n \nin\n\n    \n// check if there\ns an error\n\n    \napi\n.\ndoThingTwo\n(\nonCompletion\n:\n \n{\n \ntwo\n,\n \nerror\n \nin\n\n        \n// check if there\ns an error\n\n        \napi\n.\ndoThingThree\n(\nonCompletion\n:\n \n{\n \nthree\n,\n \nerror\n \nin\n\n            \n// check if there\ns an error\n\n            \napi\n.\ndoThingFour\n(\nonCompletion\n:\n \n{\n \nfour\n,\n \nerror\n \nin\n\n                \n// check if there\ns an error\n\n            \n})\n\n        \n})\n\n    \n})\n\n\n})\n\n\n\n\n\n\nFutures prevent nesting and greatly simplify error checking.\n\n\nlet\n \nfour\n \n=\n \napi\n.\ndoThingOne\n().\nthen\n \n{\n\n    \nreturn\n \napi\n.\ndoThingTwo\n()\n\n\n}.\nthen\n \n{\n\n    \nreturn\n \napi\n.\ndoThingThree\n()\n\n\n}.\nthen\n \n{\n\n    \nreturn\n \napi\n.\ndoThingFour\n()\n\n\n}\n\n\n\nprint\n(\nfour\n)\n \n// The future result of `doThingFour()`\n\n\n\n\n\n\nNotice that we didn't need to check for errors when we chained with futures. When we attempt to resolve \nfour\n,\nwe can catch errors thrown anywhere in the chain.\n\n\nfour\n.\ndo\n \n{\n \nfour\n \nin\n\n    \nprint\n(\nfour\n)\n \n// the result\n\n\n}.\ncatch\n \n{\n \nerr\n \nin\n\n    \nprint\n(\nerr\n)\n \n// error thrown from thing one, two, three, or four\n\n\n}\n\n\n\n\n\n\nLearn more about Vapor's async architecture in \nConcepts \n Async\n.\nOr take a deeper look at Futures and Promises in \nAsync \n Getting Started\n.", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#futures", 
            "text": "You may have noticed some APIs in Vapor expect or return a  Future T  type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#callbacks", 
            "text": "Futures are a way of representing an object that you don't have yet. You have probably seen\nAPIs that use callbacks before (especially if you have developed iOS apps). Futures are just a\nway to make APIs with callbacks more user-friendly.  This is a what a common callback API looks like.  api . getUsers ( onCompletion :   {   users ,   error   in \n     // check if there s an error \n     // do something with the users  })   With futures, we don't have to supply a callback. We get back instead  Future [User] .  let   users   =   api . getUsers ()  print ( users )   // Future [User]    Info  Futures use fewer system resources than synchronous APIs. This is part of\nwhat makes Vapor so fast!", 
            "title": "Callbacks"
        }, 
        {
            "location": "/getting-started/futures/#chaining", 
            "text": "What's great about futures is they allow us to chain multiple actions together without nesting callbacks.  Let's take a look at an example of this with callbacks.  api . doThingOne ( onCompletion :   {   one ,   error   in \n     // check if there s an error \n     api . doThingTwo ( onCompletion :   {   two ,   error   in \n         // check if there s an error \n         api . doThingThree ( onCompletion :   {   three ,   error   in \n             // check if there s an error \n             api . doThingFour ( onCompletion :   {   four ,   error   in \n                 // check if there s an error \n             }) \n         }) \n     })  })   Futures prevent nesting and greatly simplify error checking.  let   four   =   api . doThingOne (). then   { \n     return   api . doThingTwo ()  }. then   { \n     return   api . doThingThree ()  }. then   { \n     return   api . doThingFour ()  }  print ( four )   // The future result of `doThingFour()`   Notice that we didn't need to check for errors when we chained with futures. When we attempt to resolve  four ,\nwe can catch errors thrown anywhere in the chain.  four . do   {   four   in \n     print ( four )   // the result  }. catch   {   err   in \n     print ( err )   // error thrown from thing one, two, three, or four  }   Learn more about Vapor's async architecture in  Concepts   Async .\nOr take a deeper look at Futures and Promises in  Async   Getting Started .", 
            "title": "Chaining"
        }, 
        {
            "location": "/getting-started/cloud/", 
            "text": "Deployment\n\n\nDeploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.\n\n\nVapor Cloud\n\n\nThe best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.\n\n\nDeploying your project to Vapor Cloud is simple, it's built right into the \nVapor Toolbox\n.\nJust run this command from within the root directory of your project.\n\n\nvapor cloud deploy\n\n\n\n\n\nFor a detailed guide, visit \nVapor Cloud \n Quick Start\n.\n\n\nOther Options\n\n\nVapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout \nDeploy \n Getting Started", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#deployment", 
            "text": "Deploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#vapor-cloud", 
            "text": "The best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.  Deploying your project to Vapor Cloud is simple, it's built right into the  Vapor Toolbox .\nJust run this command from within the root directory of your project.  vapor cloud deploy  For a detailed guide, visit  Vapor Cloud   Quick Start .", 
            "title": "Vapor Cloud"
        }, 
        {
            "location": "/getting-started/cloud/#other-options", 
            "text": "Vapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout  Deploy   Getting Started", 
            "title": "Other Options"
        }, 
        {
            "location": "/concepts/vapor/", 
            "text": "What is Vapor?\n\n\nVapor is a \nhigh performance\n, type-safe and \neasy to use\n web framework written in and for Swift.\n\n\nVapor is designed for both big and small services, providing a low entry barrier to get started in addition to high performance, well tested and well documented APIs.\n\n\nPerformance\n\n\nVapor's high performance is achieved by a combination of our \nasynchronous architecture\n, Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.\n\n\nType safety\n\n\nVapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.\n\n\nWe believe type-safety is critical to both security and developer productivity.\n\n\nEasy to use\n\n\nCreating a new Vapor project takes only a few minutes.\n\n\nWe've got you covered with our thorough documentation and have \nan amazing community\n to back it up!", 
            "title": "What is Vapor?"
        }, 
        {
            "location": "/concepts/vapor/#what-is-vapor", 
            "text": "Vapor is a  high performance , type-safe and  easy to use  web framework written in and for Swift.  Vapor is designed for both big and small services, providing a low entry barrier to get started in addition to high performance, well tested and well documented APIs.", 
            "title": "What is Vapor?"
        }, 
        {
            "location": "/concepts/vapor/#performance", 
            "text": "Vapor's high performance is achieved by a combination of our  asynchronous architecture , Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.", 
            "title": "Performance"
        }, 
        {
            "location": "/concepts/vapor/#type-safety", 
            "text": "Vapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.  We believe type-safety is critical to both security and developer productivity.", 
            "title": "Type safety"
        }, 
        {
            "location": "/concepts/vapor/#easy-to-use", 
            "text": "Creating a new Vapor project takes only a few minutes.  We've got you covered with our thorough documentation and have  an amazing community  to back it up!", 
            "title": "Easy to use"
        }, 
        {
            "location": "/concepts/async/", 
            "text": "Async\n\n\nAsync APIs are one of the most important aspects of Vapor 3. You have likely noticed that they are\nthe biggest change to the API from previous versions. To learn more about how to use the new async\nAPIs check out the \nAsync \n Getting Started\n section. This document\naims to explain \nwhy\n Vapor 3 moved to async APIs and \nhow\n it has led to huge performance gains.\n\n\nDifferences\n\n\nLet's first make sure we understand the different between a \"sync\" and \"async\" API.\n\n\n// sync\n\n\nlet\n \nusers\n \n=\n \ntry\n \napi\n.\ngetUsers\n()\n\n\n\n\n\n\nSync APIs return values immediately.\n\n\n// async\n\n\ntry\n \napi\n.\ngetUsers\n(\nonCompletion\n:\n \n{\n \nusers\n,\n \nerror\n \nin\n\n\n\n})\n\n\n\n\n\n\nAsync APIs return their value at some point in the future. There are many different ways to implement\nasync APIs (such as \nfutures\n), but we will use callbacks here to make it obvious.\n\n\nConcurrency\n\n\nIt's fairly obvious from the above snippet that sync APIs are more concise. So why would anyone use an async API?\nTo understand why, you must first understand how concurrency works with these two API types.\n\n\nSync (Blocking)\n\n\nIn Swift, most APIs are synchronous. For example, when you convert a string to uppercase.\n\n\nlet\n \nhello\n \n=\n \nHello\n.\nuppercased\n()\n\n\n\n\n\n\nThere is no problem with this API being synchronous because at no point in converting \"Hello\" to uppercase is\nthe computer ever \nwaiting\n. Waiting, also called \"blocking\", is an important concept. Most simple functions,\nlike \n.uppercased()\n never wait\nthey are busy doing the requested work (i.e., capitalizing letters) the entire time.\nHowever, some functions do wait. The classic example of this is a function that makes a network request.\n\n\n/// sync + blocking\n\n\nlet\n \nres\n \n=\n \ntry\n \nHTTPClient\n.\ngetSync\n(\nhttp://google.com\n)\n\n\n\n\n\n\nIn the above example, the \n.getSync\n function must block. After it sends the request to \ngoogle.com\n, it must wait for\ntheir server to generate a response. While this function is waiting, it can't do anything. In other words, the CPU\nis idle. If you're trying to optimize your application, you'd quickly notice that letting your (expensive) CPU sit\nidle is not a great idea.\n\n\nAsync (Non-blocking)\n\n\nTo solve this problem, instead of expecting the \n.getSync\n function to immediately return a response, you give it a callback.\n\n\n/// async + non-blocking\n\n\nHTTPClient\n.\ngetAsync\n(\nhttp://google.com\n,\n \nonCompletion\n:\n \n{\n \nres\n,\n \nerror\n \nin\n\n\n\n})\n\n\n\n\n\n\nNow, after the \n.getAsync\n function is done sending the request to \ngoogle.com\n, it can simply continue executing your\nprogram. When Google's servers return a response, the CPU will be notified, and it will give the response to your callback.\n\n\nAdvanced\n\n\nLet's now take a deeper look at why Vapor prefers async (non-blocking) APIs over sync (blocking) ones.\n\n\nThreads\n\n\nYou may be thinking, what's the problem with \n.getSync\n? Why not just call that function on a background thread.\nThat is indeed a valid solution, and it would work. This style of threading is widely used and taught. However, the problem is\nthat threads are not \"free\" to create. When you're programming for iOS, this doesn't (usually) matter. You can\noften spin up as many threads as you like. You have a whole CPU to yourself! Things are different on the server though.\nWeb applications must respond to thousands (even millions) of requests \nat the same time\n. Imagine running a million instances\nof your iOS app on one device. Even relatively small costs, like creating a thread, become extremely important as a web server.\n\n\nMulti-Reactor\n\n\nTo achieve optimal performance, Vapor only creates one thread per CPU core on your machine. This means there will be no\nwasted time allocating new threads and very little wasted time switching between them.\n\n\nEach one of these threads is called an event loop, similar to Node.js. The difference is that Vapor has multiple event loops\n(one for each core) where as Node.js just has one. This means you don't need to spin up multiple instances of your app\nper computer for it to run optimally.\n\n\n/// every incoming request has a reference\n\n\n/// to its assigned event loop\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nprint\n(\nreq\n.\neventLoop\n)\n \n// EventLoop?\n\n\n}\n\n\n\n\n\n\nIt's important that you don't make blocking calls on an event loop. If you do, all other requests running on that event loop will\nbe blocked. For example, if your computer has 2 cores, and you call \nsleep(10)\n on one of the event loops, your application will\nstop responding to half of the incoming requests for 10 seconds.\n\n\nCoroutines\n\n\nComing soon.", 
            "title": "Async"
        }, 
        {
            "location": "/concepts/async/#async", 
            "text": "Async APIs are one of the most important aspects of Vapor 3. You have likely noticed that they are\nthe biggest change to the API from previous versions. To learn more about how to use the new async\nAPIs check out the  Async   Getting Started  section. This document\naims to explain  why  Vapor 3 moved to async APIs and  how  it has led to huge performance gains.", 
            "title": "Async"
        }, 
        {
            "location": "/concepts/async/#differences", 
            "text": "Let's first make sure we understand the different between a \"sync\" and \"async\" API.  // sync  let   users   =   try   api . getUsers ()   Sync APIs return values immediately.  // async  try   api . getUsers ( onCompletion :   {   users ,   error   in  })   Async APIs return their value at some point in the future. There are many different ways to implement\nasync APIs (such as  futures ), but we will use callbacks here to make it obvious.", 
            "title": "Differences"
        }, 
        {
            "location": "/concepts/async/#concurrency", 
            "text": "It's fairly obvious from the above snippet that sync APIs are more concise. So why would anyone use an async API?\nTo understand why, you must first understand how concurrency works with these two API types.", 
            "title": "Concurrency"
        }, 
        {
            "location": "/concepts/async/#sync-blocking", 
            "text": "In Swift, most APIs are synchronous. For example, when you convert a string to uppercase.  let   hello   =   Hello . uppercased ()   There is no problem with this API being synchronous because at no point in converting \"Hello\" to uppercase is\nthe computer ever  waiting . Waiting, also called \"blocking\", is an important concept. Most simple functions,\nlike  .uppercased()  never wait they are busy doing the requested work (i.e., capitalizing letters) the entire time.\nHowever, some functions do wait. The classic example of this is a function that makes a network request.  /// sync + blocking  let   res   =   try   HTTPClient . getSync ( http://google.com )   In the above example, the  .getSync  function must block. After it sends the request to  google.com , it must wait for\ntheir server to generate a response. While this function is waiting, it can't do anything. In other words, the CPU\nis idle. If you're trying to optimize your application, you'd quickly notice that letting your (expensive) CPU sit\nidle is not a great idea.", 
            "title": "Sync (Blocking)"
        }, 
        {
            "location": "/concepts/async/#async-non-blocking", 
            "text": "To solve this problem, instead of expecting the  .getSync  function to immediately return a response, you give it a callback.  /// async + non-blocking  HTTPClient . getAsync ( http://google.com ,   onCompletion :   {   res ,   error   in  })   Now, after the  .getAsync  function is done sending the request to  google.com , it can simply continue executing your\nprogram. When Google's servers return a response, the CPU will be notified, and it will give the response to your callback.", 
            "title": "Async (Non-blocking)"
        }, 
        {
            "location": "/concepts/async/#advanced", 
            "text": "Let's now take a deeper look at why Vapor prefers async (non-blocking) APIs over sync (blocking) ones.", 
            "title": "Advanced"
        }, 
        {
            "location": "/concepts/async/#threads", 
            "text": "You may be thinking, what's the problem with  .getSync ? Why not just call that function on a background thread.\nThat is indeed a valid solution, and it would work. This style of threading is widely used and taught. However, the problem is\nthat threads are not \"free\" to create. When you're programming for iOS, this doesn't (usually) matter. You can\noften spin up as many threads as you like. You have a whole CPU to yourself! Things are different on the server though.\nWeb applications must respond to thousands (even millions) of requests  at the same time . Imagine running a million instances\nof your iOS app on one device. Even relatively small costs, like creating a thread, become extremely important as a web server.", 
            "title": "Threads"
        }, 
        {
            "location": "/concepts/async/#multi-reactor", 
            "text": "To achieve optimal performance, Vapor only creates one thread per CPU core on your machine. This means there will be no\nwasted time allocating new threads and very little wasted time switching between them.  Each one of these threads is called an event loop, similar to Node.js. The difference is that Vapor has multiple event loops\n(one for each core) where as Node.js just has one. This means you don't need to spin up multiple instances of your app\nper computer for it to run optimally.  /// every incoming request has a reference  /// to its assigned event loop  router . get (...)   {   req   in \n     print ( req . eventLoop )   // EventLoop?  }   It's important that you don't make blocking calls on an event loop. If you do, all other requests running on that event loop will\nbe blocked. For example, if your computer has 2 cores, and you call  sleep(10)  on one of the event loops, your application will\nstop responding to half of the incoming requests for 10 seconds.", 
            "title": "Multi-Reactor"
        }, 
        {
            "location": "/concepts/async/#coroutines", 
            "text": "Coming soon.", 
            "title": "Coroutines"
        }, 
        {
            "location": "/concepts/codable/", 
            "text": "Codable\n\n\nCodable is any type that's both \nEncodable\n and \nDecodable\n. Encodable types can be serialized to a format, and Decodable types can be deserialized from a format.\n\n\nIf you only want your type to be serializable to another type, then you conform to \nEncodable\n. This will allow serializing this type to other formats such as JSON, XML, MySQL rows, MongoDB/BSON and more. But not backwards.\n\n\nIf you want to be able to construct your type from the raw data, you can conform your type to \nDecodable\n. This will allow converting serialized data to your model (the reverse of \nEncodable\n), allowing JSON, XML, MySQL and MongoDB data to construct your model. This will not allow serialization.\n\n\nIf you want both serialization and deserialization, you can conform to \nCodable\n.\n\n\nFor the best experience you should conform one of the above protocols in the \ndefinition\n of your \nstruct\n or \nclass\n. This way the compiler can infer the protocol requirements automatically. Conforming to these protocols in an extension will require you to manually implement the protocol requirements.\n\n\nstruct\n \nUser\n:\n \nCodable\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nWith this addition, the above struct can now be (de-)serialized between JSON, XML, MongoDB BSON, MySQL and more!", 
            "title": "Codable"
        }, 
        {
            "location": "/concepts/codable/#codable", 
            "text": "Codable is any type that's both  Encodable  and  Decodable . Encodable types can be serialized to a format, and Decodable types can be deserialized from a format.  If you only want your type to be serializable to another type, then you conform to  Encodable . This will allow serializing this type to other formats such as JSON, XML, MySQL rows, MongoDB/BSON and more. But not backwards.  If you want to be able to construct your type from the raw data, you can conform your type to  Decodable . This will allow converting serialized data to your model (the reverse of  Encodable ), allowing JSON, XML, MySQL and MongoDB data to construct your model. This will not allow serialization.  If you want both serialization and deserialization, you can conform to  Codable .  For the best experience you should conform one of the above protocols in the  definition  of your  struct  or  class . This way the compiler can infer the protocol requirements automatically. Conforming to these protocols in an extension will require you to manually implement the protocol requirements.  struct   User :   Codable   { \n   var   username :   String \n   var   age :   Int  }   With this addition, the above struct can now be (de-)serialized between JSON, XML, MongoDB BSON, MySQL and more!", 
            "title": "Codable"
        }, 
        {
            "location": "/concepts/services/", 
            "text": "Services\n\n\nTODO: Exaple service providers.", 
            "title": "Services"
        }, 
        {
            "location": "/concepts/services/#services", 
            "text": "TODO: Exaple service providers.", 
            "title": "Services"
        }, 
        {
            "location": "/concepts/http/", 
            "text": "HTTP\n\n\nAt the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.\n\n\nHTTP comes in two major versions. \nHTTP/1\n and \nHTTP/2\n. Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.\n\n\nWhat is the difference?\n\n\nHTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.\n\n\nHTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.\n\n\nHow it works\n\n\nAt the heart of HTTP lie the \nRequest\n and \nResponse\n. Both of them are \"HTTP Messages\". Both HTTP messages consists of \nHeaders\n and \na body\n.\n\n\nHTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.\n\n\nBodies contain the concrete information being transferred. Think of the web-page, images, videos, \nJSON\n and \nforms\n.\n\n\nHeaders contain metadata.\n\n\nCookies\n are metadataabout the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are \nsession tokens\n.\n\n\nAnother type of metadata can be related to the content. For example, defining the type of content transferred in the body.\n\n\nRequest\n\n\nRequests have two additional properties in addition to all properties of a Message. The \nMethod\n and \npath\n.\n\n\nThe path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of \ncomponents\n. The components are separated by a forward slash (\n/\n). All components must be encoded with percent encoding, affecting special characters only.\n\n\nThe \nmethod\n indicated the operation to this resource. \nGET\n is used for reading a resource where \nDELETE\n will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.\n\n\nResponse\n\n\nResponses have one additional property in addition to the message's properties. This is \nthe status code\n. The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively. \nMore about status codes here.\n\n\nHandling requests\n\n\nRequests in Vapor will be handled by a \nrouter\n. This allows registering a path to a method. For example, registering \n.get(\"users\")\n will register the path \n/users/\n to the method \nGET\n. The responder/closure associated with this route can then handle requests sent to \n/users/\n with the \nGET\n method.\n\n\nTypes of endpoints\n\n\nIn the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.\n\n\niOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.\n\n\nWebsites\n\n\nWebsites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.\n\n\nServer rendered pages make use of a templating system such as \nleaf\n whereas client rendered pages communicate with an API.\n\n\nAPI\n\n\nAPIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with \nJSON\n. Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.\n\n\nAPIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model \nwhich we explain here.\n\n\nDesigning an API in Vapor is really simple. \nWe dive into this from here.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#http", 
            "text": "At the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.  HTTP comes in two major versions.  HTTP/1  and  HTTP/2 . Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#what-is-the-difference", 
            "text": "HTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.  HTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.", 
            "title": "What is the difference?"
        }, 
        {
            "location": "/concepts/http/#how-it-works", 
            "text": "At the heart of HTTP lie the  Request  and  Response . Both of them are \"HTTP Messages\". Both HTTP messages consists of  Headers  and  a body .  HTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.  Bodies contain the concrete information being transferred. Think of the web-page, images, videos,  JSON  and  forms .  Headers contain metadata.  Cookies  are metadataabout the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are  session tokens .  Another type of metadata can be related to the content. For example, defining the type of content transferred in the body.", 
            "title": "How it works"
        }, 
        {
            "location": "/concepts/http/#request", 
            "text": "Requests have two additional properties in addition to all properties of a Message. The  Method  and  path .  The path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of  components . The components are separated by a forward slash ( / ). All components must be encoded with percent encoding, affecting special characters only.  The  method  indicated the operation to this resource.  GET  is used for reading a resource where  DELETE  will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.", 
            "title": "Request"
        }, 
        {
            "location": "/concepts/http/#response", 
            "text": "Responses have one additional property in addition to the message's properties. This is  the status code . The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively.  More about status codes here.", 
            "title": "Response"
        }, 
        {
            "location": "/concepts/http/#handling-requests", 
            "text": "Requests in Vapor will be handled by a  router . This allows registering a path to a method. For example, registering  .get(\"users\")  will register the path  /users/  to the method  GET . The responder/closure associated with this route can then handle requests sent to  /users/  with the  GET  method.", 
            "title": "Handling requests"
        }, 
        {
            "location": "/concepts/http/#types-of-endpoints", 
            "text": "In the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.  iOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.", 
            "title": "Types of endpoints"
        }, 
        {
            "location": "/concepts/http/#websites", 
            "text": "Websites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.  Server rendered pages make use of a templating system such as  leaf  whereas client rendered pages communicate with an API.", 
            "title": "Websites"
        }, 
        {
            "location": "/concepts/http/#api", 
            "text": "APIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with  JSON . Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.  APIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model  which we explain here.  Designing an API in Vapor is really simple.  We dive into this from here.", 
            "title": "API"
        }, 
        {
            "location": "/async/package/", 
            "text": "Using Async\n\n\nAsync is a library revolving around two main concepts:\n\n\n\n\nPromises and Futures\n\n\nStreams\n\n\nWorkers\n\n\n\n\nTogether they form the foundation of Vapor 3's data flow.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nAsync\n\n\n\n\n\n\nWithout Vapor\n\n\nAsync is a powerful library for any Swift project. To include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/async.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n1.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nAsync\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Async\n to access Async's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/async/package/#using-async", 
            "text": "Async is a library revolving around two main concepts:   Promises and Futures  Streams  Workers   Together they form the foundation of Vapor 3's data flow.", 
            "title": "Using Async"
        }, 
        {
            "location": "/async/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Async", 
            "title": "With Vapor"
        }, 
        {
            "location": "/async/package/#without-vapor", 
            "text": "Async is a powerful library for any Swift project. To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/async.git ,   . upToNextMajor ( from :   1.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Async ,   ...   ]) \n     ]  )   Use  import Async  to access Async's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/async/futures/", 
            "text": "Future basics\n\n\nFutures are used throughout Vapor, so it is useful to know some of the available helpers. We explain the reasoning and use cases \nhere\n. They are the primary \nFutureType\n implementation.\n\n\nAdding awaiters to all results\n\n\nIf you need to handle the results of an operation regardless of success or failure, you can do so by calling the \n.addAwaiter\n function on a future.\n\n\nThe awaiter shall be called on completion with a \nResult\nExpectation\n. This is an enum with either the \nExpectation\n or an \nError\n contained within.\n\n\nlet\n \nfuture\n \n=\n \nFuture\n(\nHello world\n)\n\n\n\nfuture\n.\naddAwaiter\n \n{\n \nresult\n \nin\n\n  \nswitch\n \nresult\n \n{\n\n  \ncase\n \n.\nexpectation\n(\nlet\n \nstring\n):\n\n    \nprint\n(\nstring\n)\n\n  \ncase\n \n.\nerror\n(\nlet\n \nerror\n):\n\n    \nprint\n(\nError: \n\\(\nerror\n)\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nFlat-Mapping results\n\n\nNested async callbacks can be a pain to unwind. An example of a painfully complex \"callback hell\" scenario is demonstrated below:\n\n\napp\n.\nget\n(\nfriends\n)\n \n{\n \nrequest\n \nin\n\n    \nlet\n \nsession\n \n=\n \ntry\n \nrequest\n.\ngetSessionCookie\n()\n \nas\n \nUserSession\n\n\n    \nlet\n \npromise\n \n=\n \nPromise\nView\n()\n\n\n    \n// Fetch the user\n\n    \ntry\n \nsession\n.\nuser\n.\nresolve\n().\nthen\n \n{\n \nuser\n \nin\n\n        \n// Returns all the user\ns friends\n\n        \ntry\n \nuser\n.\nfriends\n.\nresolve\n().\nthen\n \n{\n \nfriends\n \nin\n\n            \nreturn\n \ntry\n \nview\n.\nmake\n(\nfriends\n,\n \ncontext\n:\n \nfriends\n,\n \nfor\n:\n \nrequest\n).\nthen\n \n{\n  \nrenderedView\n \nin\n\n                \npromise\n.\ncomplete\n(\nrenderedView\n)\n\n            \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n        \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n    \n}.\ncatch\n(\npromise\n.\nfail\n)\n\n\n    \nreturn\n \npromise\n.\nfuture\n\n\n}\n\n\n\n\n\n\nVapor 3 offers a \nflatMap\n solution here that will help keep the code readable and maintainable.\n\n\napp\n.\nget\n(\nfriends\n)\n \n{\n \nrequest\n \nin\n\n    \nlet\n \nsession\n \n=\n \ntry\n \nrequest\n.\ngetSessionCookie\n()\n \nas\n \nUserSession\n\n\n    \n// Fetch the user\n\n    \nreturn\n \ntry\n \nsession\n.\nuser\n.\nresolve\n().\nflatten\n \n{\n \nuser\n \nin\n\n        \n// Returns all the user\ns friends\n\n        \nreturn\n \ntry\n \nuser\n.\nfriends\n.\nresolve\n()\n\n    \n}.\nmap\n \n{\n \nfriends\n \nin\n\n        \n// Flatten replaced this future with\n\n        \nreturn\n \ntry\n \nview\n.\nmake\n(\nfriends\n,\n \ncontext\n:\n \nfriends\n,\n \nfor\n:\n \nrequest\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nCombining multiple futures\n\n\nIf you're expecting the same type of result from multiple sources you can group them using the \nflatten\n function.\n\n\nvar\n \nfutures\n \n=\n \n[\nFuture\nString\n]()\n\n\nfutures\n.\nappend\n(\nFuture\n(\nHello\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nWorld\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nFoo\n))\n\n\nfutures\n.\nappend\n(\nFuture\n(\nBar\n))\n\n\n\nlet\n \nfutureResults\n \n=\n \nfutures\n.\nflatten\n()\n \n// Future\n[String]\n\n\n\n\n\n\nCreating a promise\n\n\nPromises are important if you're implementing a function that returns a result in the future, such as the database shown above.\n\n\nPromises need to be created without a result. They can then be completed with the expectation or an error at any point.\n\n\nYou can extract a \nfuture\n from the \npromise\n that you can hand to the API consumer.\n\n\n// the example `fetchUser` implementation\n\n\nfunc\n \nfetchUser\n(\nnamed\n \nname\n:\n \nString\n)\n \n-\n \nFuture\nUser\n \n{\n\n    \n// Creates a promise that can be fulfilled in the future\n\n    \nlet\n \npromise\n \n=\n \nPromise\nUser\n()\n\n\n    \ndo\n \n{\n\n    \n// \nTODO:\n Run a query asynchronously, looking for the user\n\n\n        \n// Initialize the user using the datbase result\n\n        \n// This can throw an error if the result is empty or invalid\n\n        \nlet\n \nuser\n \n=\n \ntry\n \nUser\n(\ndecodingFrom\n:\n \ndatabaseResult\n)\n\n\n        \n// If initialization is successful, complete the promise.\n\n        \n//\n\n        \n// Completing the promise will notify the promise\ns associated future with this user\n\n        \npromise\n.\ncomplete\n(\nuser\n)\n\n    \n}\n \ncatch\n \n{\n\n        \n// If initialization is successful, fail the promise.\n\n        \n//\n\n        \n// Failing the promise will notify the promise\ns associated future with an error\n\n        \npromise\n.\nfail\n(\nerror\n)\n\n    \n}\n\n\n    \n// After spawning the asynchronous operation, return the promise\ns associated future\n\n    \n//\n\n    \n// The future can then be used by the API consumer\n\n    \nreturn\n \npromise\n.\nfuture\n\n\n}\n\n\n\n\n\n\nOn future completion\n\n\nWhen a promise completes, you can chain the result/error into a closure:\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// `.then`\ns closure will be executed on success\n\n\nfuture\n.\nthen\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n// `.catch` will catch any error on failure\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nCatching specific errors\n\n\nSometimes you only care for specific errors, for example, for logging.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// `.then`\ns closure will be executed on success\n\n\nfuture\n.\nthen\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n// This `.catch` will only catch `DatabaseError`s\n\n\n}.\ncatch\n(\nDatabaseError\n.\nself\n)\n \n{\n \ndatabaseError\n \nin\n\n    \nprint\n(\ndatabaseError\n)\n\n\n// `.catch` will catch any error on failure, including `DatabaseError` types\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nMapping results\n\n\nFutures can be mapped to different results asynchronously.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// Maps the user to it\ns username\n\n\nlet\n \nfutureUsername\n:\n \nFuture\nString\n \n=\n \nfuture\n.\nmap\n \n{\n \nuser\n \nin\n\n    \nreturn\n \nuser\n.\nusername\n\n\n}\n\n\n\n// Mapped futures can be mapped and chained, too\n\n\nfutureUsername\n.\nthen\n \n{\n \nusername\n \nin\n\n    \nprint\n(\nusername\n)\n\n\n}\n\n\n\n\n\n\nFutures without promise\n\n\nIn some scenarios you're required to return a \nFuture\n where a \nPromise\n isn't necessary as you already have the result.\n\n\nIn these scenarios you can initialize a future with the already completed result.\n\n\n// Already completed on initialization\n\n\nlet\n \nfuture\n \n=\n \nFuture\n(\nHello world!\n)\n\n\n\nfuture\n.\nthen\n \n{\n \nstring\n \nin\n\n  \nprint\n(\nstring\n)\n\n\n}\n\n\n\n\n\n\nSynchronous APIs\n\n\nSometimes, an API needs to be used synchronously in a synchronous envinronment.\n\n\nRather than using a synchronous API with all edge cases involved, we recommend using the \ntry future.blockingAwait()\n function.\n\n\n// The future provided by the above function will be used\n\n\nlet\n \nfuture\n:\n \nFuture\nUser\n \n=\n \nfetchUser\n(\nnamed\n:\n \nAdmin\n)\n\n\n\n// This will either receive the user if the promise was completed or throw an error if the promise was failed.\n\n\nlet\n \nuser\n:\n \nUser\n \n=\n \ntry\n \nfuture\n.\nblockingAwait\n()\n\n\n\n\n\n\nThis will wait for a result indefinitely, blocking the thread.\n\n\nIf you expect a result with a specified duration, say, 30 seconds:\n\n\n// This will also throw an error if the deadline wasn\nt met\n\n\nlet\n \nuser\n \n=\n \ntry\n \nfuture\n.\nblocked\n(\ntimeout\n:\n \n.\nseconds\n(\n30\n))", 
            "title": "Futures"
        }, 
        {
            "location": "/async/futures/#future-basics", 
            "text": "Futures are used throughout Vapor, so it is useful to know some of the available helpers. We explain the reasoning and use cases  here . They are the primary  FutureType  implementation.", 
            "title": "Future basics"
        }, 
        {
            "location": "/async/futures/#adding-awaiters-to-all-results", 
            "text": "If you need to handle the results of an operation regardless of success or failure, you can do so by calling the  .addAwaiter  function on a future.  The awaiter shall be called on completion with a  Result Expectation . This is an enum with either the  Expectation  or an  Error  contained within.  let   future   =   Future ( Hello world )  future . addAwaiter   {   result   in \n   switch   result   { \n   case   . expectation ( let   string ): \n     print ( string ) \n   case   . error ( let   error ): \n     print ( Error:  \\( error ) ) \n   }  }", 
            "title": "Adding awaiters to all results"
        }, 
        {
            "location": "/async/futures/#flat-mapping-results", 
            "text": "Nested async callbacks can be a pain to unwind. An example of a painfully complex \"callback hell\" scenario is demonstrated below:  app . get ( friends )   {   request   in \n     let   session   =   try   request . getSessionCookie ()   as   UserSession \n\n     let   promise   =   Promise View () \n\n     // Fetch the user \n     try   session . user . resolve (). then   {   user   in \n         // Returns all the user s friends \n         try   user . friends . resolve (). then   {   friends   in \n             return   try   view . make ( friends ,   context :   friends ,   for :   request ). then   {    renderedView   in \n                 promise . complete ( renderedView ) \n             }. catch ( promise . fail ) \n         }. catch ( promise . fail ) \n     }. catch ( promise . fail ) \n\n     return   promise . future  }   Vapor 3 offers a  flatMap  solution here that will help keep the code readable and maintainable.  app . get ( friends )   {   request   in \n     let   session   =   try   request . getSessionCookie ()   as   UserSession \n\n     // Fetch the user \n     return   try   session . user . resolve (). flatten   {   user   in \n         // Returns all the user s friends \n         return   try   user . friends . resolve () \n     }. map   {   friends   in \n         // Flatten replaced this future with \n         return   try   view . make ( friends ,   context :   friends ,   for :   request ) \n     }  }", 
            "title": "Flat-Mapping results"
        }, 
        {
            "location": "/async/futures/#combining-multiple-futures", 
            "text": "If you're expecting the same type of result from multiple sources you can group them using the  flatten  function.  var   futures   =   [ Future String ]()  futures . append ( Future ( Hello ))  futures . append ( Future ( World ))  futures . append ( Future ( Foo ))  futures . append ( Future ( Bar ))  let   futureResults   =   futures . flatten ()   // Future [String]", 
            "title": "Combining multiple futures"
        }, 
        {
            "location": "/async/futures/#creating-a-promise", 
            "text": "Promises are important if you're implementing a function that returns a result in the future, such as the database shown above.  Promises need to be created without a result. They can then be completed with the expectation or an error at any point.  You can extract a  future  from the  promise  that you can hand to the API consumer.  // the example `fetchUser` implementation  func   fetchUser ( named   name :   String )   -   Future User   { \n     // Creates a promise that can be fulfilled in the future \n     let   promise   =   Promise User () \n\n     do   { \n     //  TODO:  Run a query asynchronously, looking for the user \n\n         // Initialize the user using the datbase result \n         // This can throw an error if the result is empty or invalid \n         let   user   =   try   User ( decodingFrom :   databaseResult ) \n\n         // If initialization is successful, complete the promise. \n         // \n         // Completing the promise will notify the promise s associated future with this user \n         promise . complete ( user ) \n     }   catch   { \n         // If initialization is successful, fail the promise. \n         // \n         // Failing the promise will notify the promise s associated future with an error \n         promise . fail ( error ) \n     } \n\n     // After spawning the asynchronous operation, return the promise s associated future \n     // \n     // The future can then be used by the API consumer \n     return   promise . future  }", 
            "title": "Creating a promise"
        }, 
        {
            "location": "/async/futures/#on-future-completion", 
            "text": "When a promise completes, you can chain the result/error into a closure:  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // `.then` s closure will be executed on success  future . then   {   user   in \n   print ( user . username )  // `.catch` will catch any error on failure  }. catch   {   error   in \n   print ( error )  }", 
            "title": "On future completion"
        }, 
        {
            "location": "/async/futures/#catching-specific-errors", 
            "text": "Sometimes you only care for specific errors, for example, for logging.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // `.then` s closure will be executed on success  future . then   {   user   in \n   print ( user . username )  // This `.catch` will only catch `DatabaseError`s  }. catch ( DatabaseError . self )   {   databaseError   in \n     print ( databaseError )  // `.catch` will catch any error on failure, including `DatabaseError` types  }. catch   {   error   in \n   print ( error )  }", 
            "title": "Catching specific errors"
        }, 
        {
            "location": "/async/futures/#mapping-results", 
            "text": "Futures can be mapped to different results asynchronously.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // Maps the user to it s username  let   futureUsername :   Future String   =   future . map   {   user   in \n     return   user . username  }  // Mapped futures can be mapped and chained, too  futureUsername . then   {   username   in \n     print ( username )  }", 
            "title": "Mapping results"
        }, 
        {
            "location": "/async/futures/#futures-without-promise", 
            "text": "In some scenarios you're required to return a  Future  where a  Promise  isn't necessary as you already have the result.  In these scenarios you can initialize a future with the already completed result.  // Already completed on initialization  let   future   =   Future ( Hello world! )  future . then   {   string   in \n   print ( string )  }", 
            "title": "Futures without promise"
        }, 
        {
            "location": "/async/futures/#synchronous-apis", 
            "text": "Sometimes, an API needs to be used synchronously in a synchronous envinronment.  Rather than using a synchronous API with all edge cases involved, we recommend using the  try future.blockingAwait()  function.  // The future provided by the above function will be used  let   future :   Future User   =   fetchUser ( named :   Admin )  // This will either receive the user if the promise was completed or throw an error if the promise was failed.  let   user :   User   =   try   future . blockingAwait ()   This will wait for a result indefinitely, blocking the thread.  If you expect a result with a specified duration, say, 30 seconds:  // This will also throw an error if the deadline wasn t met  let   user   =   try   future . blocked ( timeout :   . seconds ( 30 ))", 
            "title": "Synchronous APIs"
        }, 
        {
            "location": "/async/streams/", 
            "text": "Streams is a mechanism that you can implement on objects that process any information efficiently and asynchronously without bloat.\n\n\nThere are three primary stream protocols:\n\n\n\n\nInputStream\n\n\nOutputStream\n\n\nStream\n\n\n\n\nConforming to Stream means conformance to both InputStream and OutputStream. So \nStream\n is both processing output and providing output.\n\n\nInputStream is a protocol that, when implemented, accepts streaming input. An example can be a TCP socket that, on input, writes data to the socket.\n\n\nOutputStream is a protocol that, when implement, can emit output.\n\n\nConcept\n\n\nIn Vapor 3 (related libraries), almost everything is a stream. TCP Server is a stream of clients. Each client is a stream of received binary data. For HTTP, each client has an HTTP Request Parser, and Response Serializer. A parser accepts the binary stream and outputs a request stream. And a responder accepts a response and outputs a binary stream (that you can send back to the client's TCP socket as input for the binary stream).\n\n\nDraining streams\n\n\nNow that we've seen how to chain streams, let's talk about draining. In this example the \nTCP Server\n accepts a client stream which can be drained with a closure. This allows additional processing to take place.\n\n\nIn this example we print the string representation of the TCP connnection's incoming data.\n\n\ntcpSocket\n.\ndrain\n \n{\n \nbuffer\n \nin\n\n  \nprint\n(\nString\n(\nbytes\n:\n \nbuffer\n,\n \nencoding\n:\n \n.\nutf8\n))\n\n\n}\n\n\n\n\n\n\nAnother use case for draining is when the stream does not need to be continued any further. After a \nResponse\n has been sent to the Client, nothing else needs to happen.\n\n\nCatching stream errors\n\n\nWhen a (fatal) error occurs, often something need to happen. Many chained streams will do a sensible default. Sockets will close, for example. You can hook into this process by \n.catch\n-ing a stream's errors.\n\n\nstream\n.\ncatch\n \n{\n \nerror\n \nin\n\n  \n// Do something with the error\n\n  \nprint\n(\nerror\n)\n\n\n}\n\n\n\n\n\n\nImplementing an example stream\n\n\nThis example is a stream that deserializes \nByteBuffer\n to \nString\n streaming/asynchronously.\n\n\nstruct\n \nInvalidUTF8\n \n:\n \nError\n \n{}\n\n\n\n// Deserializes `ByteBuffer` (`Input`) to `String` (`Output`) using the provided encoding\n\n\nclass\n \nStringDeserializationStream\n:\n \nAsync\n.\nStream\n \n{\n\n    \ntypealias\n \nInput\n \n=\n \nByteBuffer\n\n    \ntypealias\n \nOutput\n \n=\n \nString\n\n\n    \n// Used only by this specific stream to specify an encoding\n\n    \nlet\n \nencoding\n:\n \nString\n.\nEncoding\n\n\n    \n// \nMARK:\n Stream requirements\n\n\n    \n// An error stream that can be listened to for errors in this stream\n\n    \nvar\n \nerrorStream\n:\n \nBaseStream\n.\nErrorHandler\n?\n\n\n    \n// A handler that can be set to handle output\n\n    \nvar\n \noutputStream\n:\n \nOutputHandler\n?\n\n\n    \n// Creates a new `StringDeserializationStream`\n\n    \ninit\n(\nencoding\n:\n \nString\n.\nEncoding\n \n=\n \n.\nutf8\n)\n \n{\n\n        \n// Sets the String encoding\n\n        \nself\n.\nencoding\n \n=\n \nencoding\n\n    \n}\n\n\n    \n// Receives `Input`/`ByteBuffer` from another stream or manual call\n\n    \n//\n\n    \n// Attempts to process it to a String using the specified encoding\n\n    \nfunc\n \ninputStream\n(\n_\n \ninput\n:\n \nInput\n)\n \n{\n\n        \n// Converts the `Input`/`ByteBuffer` to a String\n\n        \nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \ninput\n,\n \nencoding\n:\n \nself\n.\nencoding\n)\n \n{\n\n            \n// Stream an error if string initialization failed\n\n            \nself\n.\nerrorStream\n?(\nInvalidUTF8\n())\n\n            \nreturn\n\n        \n}\n\n\n        \n// On success, output the created string\n\n        \nself\n.\noutputStream\n?(\nstring\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTransforming streams without an intermediary stream\n\n\nThe above stream \nStringDeserializationStream\n is a very simple example of implementing a stream.\n\n\nStreams support two kinds of transforms. \nflatMap\n and \nmap\n. Map transforms the output of the stream into a new stream with different output. And \nflatMap\n does the same, but allows returning \nnil\n and does not output it.\n\n\n// `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.\n\n\n// `stringStream` is a stream outputting `String`\n\n\nlet\n \nstringStream\n \n=\n \ntcpStream\n.\nflatMap\n \n{\n \nbytes\n \nin\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n// `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.\n\n\n// `optionalStringStream` is a stream outputting `String?`\n\n\nlet\n \noptionalStringStream\n \n=\n \ntcpStream\n.\nmap\n \n{\n \nbytes\n \nin\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n\n\n\nAs you see, you an provide a closure to do the mapping for you. If you want to reuse this code instead, you could make it a function for simplicity. This function can then be used instead of the closure.\n\n\n// Creates a `String` from `ByteBuffer`. This can return `nil` if the `ByteBuffer` doesn\nt contain valid UTF-8\n\n\nfunc\n \nutf8String\n(\nfrom\n \nbytes\n:\n \nByteBuffer\n)\n \n-\n \nString\n?\n \n{\n\n  \nreturn\n \nString\n(\nbytes\n:\n \nbytes\n,\n \nencoding\n:\n \n.\nutf8\n)\n\n\n}\n\n\n\n// `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.\n\n\n// `stringStream` is a stream outputting `String`\n\n\nlet\n \nstringStream\n \n=\n \ntcpStream\n.\nflatMap\n(\nutf8String\n)\n\n\n\n// `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.\n\n\n// `optionalStringStream` is a stream outputting `String?`\n\n\nlet\n \noptionalStringStream\n \n=\n \ntcpStream\n.\nmap\n(\nutf8String\n)\n\n\n\n\n\n\nChaining streams\n\n\nIf an \nOutputStream\n's Output is the same as an \nInputStream\n's input, you can \"chain\" these streams together to create really performant and readable solutions.\n\n\nThis doesn't work for all situation, but let's look at an example that \ndoes\n accept \nbase64\n.\n\n\nclient\n.\nstream\n(\nto\n:\n \nbase64encoder\n).\nstream\n(\nto\n:\n \nclient\n)\n\n\n\n\n\n\nThe result is an \"echo\" server that base64-encodes incoming data, and replies it back in base64-encoded format.", 
            "title": "Streams"
        }, 
        {
            "location": "/async/streams/#concept", 
            "text": "In Vapor 3 (related libraries), almost everything is a stream. TCP Server is a stream of clients. Each client is a stream of received binary data. For HTTP, each client has an HTTP Request Parser, and Response Serializer. A parser accepts the binary stream and outputs a request stream. And a responder accepts a response and outputs a binary stream (that you can send back to the client's TCP socket as input for the binary stream).", 
            "title": "Concept"
        }, 
        {
            "location": "/async/streams/#draining-streams", 
            "text": "Now that we've seen how to chain streams, let's talk about draining. In this example the  TCP Server  accepts a client stream which can be drained with a closure. This allows additional processing to take place.  In this example we print the string representation of the TCP connnection's incoming data.  tcpSocket . drain   {   buffer   in \n   print ( String ( bytes :   buffer ,   encoding :   . utf8 ))  }   Another use case for draining is when the stream does not need to be continued any further. After a  Response  has been sent to the Client, nothing else needs to happen.", 
            "title": "Draining streams"
        }, 
        {
            "location": "/async/streams/#catching-stream-errors", 
            "text": "When a (fatal) error occurs, often something need to happen. Many chained streams will do a sensible default. Sockets will close, for example. You can hook into this process by  .catch -ing a stream's errors.  stream . catch   {   error   in \n   // Do something with the error \n   print ( error )  }", 
            "title": "Catching stream errors"
        }, 
        {
            "location": "/async/streams/#implementing-an-example-stream", 
            "text": "This example is a stream that deserializes  ByteBuffer  to  String  streaming/asynchronously.  struct   InvalidUTF8   :   Error   {}  // Deserializes `ByteBuffer` (`Input`) to `String` (`Output`) using the provided encoding  class   StringDeserializationStream :   Async . Stream   { \n     typealias   Input   =   ByteBuffer \n     typealias   Output   =   String \n\n     // Used only by this specific stream to specify an encoding \n     let   encoding :   String . Encoding \n\n     //  MARK:  Stream requirements \n\n     // An error stream that can be listened to for errors in this stream \n     var   errorStream :   BaseStream . ErrorHandler ? \n\n     // A handler that can be set to handle output \n     var   outputStream :   OutputHandler ? \n\n     // Creates a new `StringDeserializationStream` \n     init ( encoding :   String . Encoding   =   . utf8 )   { \n         // Sets the String encoding \n         self . encoding   =   encoding \n     } \n\n     // Receives `Input`/`ByteBuffer` from another stream or manual call \n     // \n     // Attempts to process it to a String using the specified encoding \n     func   inputStream ( _   input :   Input )   { \n         // Converts the `Input`/`ByteBuffer` to a String \n         guard   let   string   =   String ( bytes :   input ,   encoding :   self . encoding )   { \n             // Stream an error if string initialization failed \n             self . errorStream ?( InvalidUTF8 ()) \n             return \n         } \n\n         // On success, output the created string \n         self . outputStream ?( string ) \n     }  }", 
            "title": "Implementing an example stream"
        }, 
        {
            "location": "/async/streams/#transforming-streams-without-an-intermediary-stream", 
            "text": "The above stream  StringDeserializationStream  is a very simple example of implementing a stream.  Streams support two kinds of transforms.  flatMap  and  map . Map transforms the output of the stream into a new stream with different output. And  flatMap  does the same, but allows returning  nil  and does not output it.  // `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.  // `stringStream` is a stream outputting `String`  let   stringStream   =   tcpStream . flatMap   {   bytes   in \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }  // `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.  // `optionalStringStream` is a stream outputting `String?`  let   optionalStringStream   =   tcpStream . map   {   bytes   in \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }   As you see, you an provide a closure to do the mapping for you. If you want to reuse this code instead, you could make it a function for simplicity. This function can then be used instead of the closure.  // Creates a `String` from `ByteBuffer`. This can return `nil` if the `ByteBuffer` doesn t contain valid UTF-8  func   utf8String ( from   bytes :   ByteBuffer )   -   String ?   { \n   return   String ( bytes :   bytes ,   encoding :   . utf8 )  }  // `flatMap`s the data into a `String?`. If the string results in `nil`, the resulting `stringStream` does not get called.  // `stringStream` is a stream outputting `String`  let   stringStream   =   tcpStream . flatMap ( utf8String )  // `map`s the data into a `String?`. If the string results in `nil`, the resulting `optionalStringStream` emits `nil`, too.  // `optionalStringStream` is a stream outputting `String?`  let   optionalStringStream   =   tcpStream . map ( utf8String )", 
            "title": "Transforming streams without an intermediary stream"
        }, 
        {
            "location": "/async/streams/#chaining-streams", 
            "text": "If an  OutputStream 's Output is the same as an  InputStream 's input, you can \"chain\" these streams together to create really performant and readable solutions.  This doesn't work for all situation, but let's look at an example that  does  accept  base64 .  client . stream ( to :   base64encoder ). stream ( to :   client )   The result is an \"echo\" server that base64-encodes incoming data, and replies it back in base64-encoded format.", 
            "title": "Chaining streams"
        }, 
        {
            "location": "/async/worker/", 
            "text": "Worker\n\n\nWorkers are any type that keep track of the current \nEventLoop\n.\n\n\nWorker is a simple protocol and can be conformed to if the context can return (by means of a computed property) or contain an EventLoop.\n\n\nThere are three primary Workers that you can use to access the \nEventLoop\n and it's queue or context.\n\n\n\n\nRequest\n can be used, usually from within a \nRoute\n\n\nEventLoop\n is itself a worker to ensure the extensions and consumers of Worker can be used, too.\n\n\nDispatchQueue\n is a worker that will return a \nnew and clean\n EventLoop based on the current DispatchQueue", 
            "title": "Worker"
        }, 
        {
            "location": "/async/worker/#worker", 
            "text": "Workers are any type that keep track of the current  EventLoop .  Worker is a simple protocol and can be conformed to if the context can return (by means of a computed property) or contain an EventLoop.  There are three primary Workers that you can use to access the  EventLoop  and it's queue or context.   Request  can be used, usually from within a  Route  EventLoop  is itself a worker to ensure the extensions and consumers of Worker can be used, too.  DispatchQueue  is a worker that will return a  new and clean  EventLoop based on the current DispatchQueue", 
            "title": "Worker"
        }, 
        {
            "location": "/http/package/", 
            "text": "Using HTTP\n\n\nHTTP is a module as part of the \nEngine\n library containing all HTTP related APIs.\n\n\nIndex\n\n\n\n\nRequest\n\n\nResponse\n\n\nMethod\n\n\nStatus\n\n\nHeaders\n\n\nBody\n\n\nMiddleware\n\n\nMultipart\n\n\nResponder\n\n\nURI\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nHTTP\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/engine.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nHTTP\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport HTTP\n to access HTTP's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/http/package/#using-http", 
            "text": "HTTP is a module as part of the  Engine  library containing all HTTP related APIs.", 
            "title": "Using HTTP"
        }, 
        {
            "location": "/http/package/#index", 
            "text": "Request  Response  Method  Status  Headers  Body  Middleware  Multipart  Responder  URI", 
            "title": "Index"
        }, 
        {
            "location": "/http/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   HTTP", 
            "title": "With Vapor"
        }, 
        {
            "location": "/http/package/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/engine.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ HTTP ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import HTTP  to access HTTP's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/http/body/", 
            "text": "Body\n\n\nBody contains the bytes transmitted for a \nRequest\n or \nResponse\n. It's contents are related to the \nContent-Type\n header.\n\n\nBody is a binary blob but can contain text like HTML, JSON or another text-based format.\nIt can also contain binary data such as images, ZIP and other files.\n\n\nCreating a Body\n\n\nEmpty bodies can be created using the empty initializer \nBody()\n.\nAlternatively you can provide \nData\n or \nDispatchData\n as the content of the body.\n\n\nBodyRepresentable\n\n\nWhen adding a new struct/class that can be serialized to a Body as part of a Request or Response you can consider implementing the \nBodyRepresentable\n protocol. Below is how String is implemented.\n\n\n/// String can be represented as an HTTP body.\n\n\nextension\n \nString\n:\n \nBodyRepresentable\n \n{\n\n    \n/// See BodyRepresentable.makeBody()\n\n    \npublic\n \nfunc\n \nmakeBody\n()\n \nthrows\n \n-\n \nBody\n \n{\n\n        \nguard\n \nlet\n \ndata\n \n=\n \nself\n.\ndata\n(\nusing\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n            \nthrow\n \nError\n(\nidentifier\n:\n \nstring-body-conversion\n,\n \nreason\n:\n \nConverting a String to an HTTP Body failed.\n)\n\n        \n}\n\n\n        \nreturn\n \nBody\n(\ndata\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe protocol requires the implementation of the \nmakeBody\n function that creates a new \nBody\n.\n\n\nAlthough often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "Body"
        }, 
        {
            "location": "/http/body/#body", 
            "text": "Body contains the bytes transmitted for a  Request  or  Response . It's contents are related to the  Content-Type  header.  Body is a binary blob but can contain text like HTML, JSON or another text-based format.\nIt can also contain binary data such as images, ZIP and other files.", 
            "title": "Body"
        }, 
        {
            "location": "/http/body/#creating-a-body", 
            "text": "Empty bodies can be created using the empty initializer  Body() .\nAlternatively you can provide  Data  or  DispatchData  as the content of the body.", 
            "title": "Creating a Body"
        }, 
        {
            "location": "/http/body/#bodyrepresentable", 
            "text": "When adding a new struct/class that can be serialized to a Body as part of a Request or Response you can consider implementing the  BodyRepresentable  protocol. Below is how String is implemented.  /// String can be represented as an HTTP body.  extension   String :   BodyRepresentable   { \n     /// See BodyRepresentable.makeBody() \n     public   func   makeBody ()   throws   -   Body   { \n         guard   let   data   =   self . data ( using :   . utf8 )   else   { \n             throw   Error ( identifier :   string-body-conversion ,   reason :   Converting a String to an HTTP Body failed. ) \n         } \n\n         return   Body ( data ) \n     }  }   The protocol requires the implementation of the  makeBody  function that creates a new  Body .  Although often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "BodyRepresentable"
        }, 
        {
            "location": "/http/client/", 
            "text": "HTTP Client\n\n\nHTTP Clients are often used to communicate with external APIs such as PayPal, Stripe or Mailgun.\n\n\nConnecting\n\n\nConnecting only requires a hostname and a boolean indicating if you want to use SSL. For almost every use case it is recommended to use SSL. If you're processing any sensitive data such as payments, emails and other personal data you will need to use SSL by setting it to \ntrue\n.\n\n\nHTTP clients require a \nWorker\n, too, so it can run on the current \nEventLoop\n\n\n// Future\nHTTPClient\n\n \nlet\n \nclient\n \n=\n \ntry\n \nHTTPClient\n.\nconnect\n(\n\n    \nto\n:\n \nexample.com\n,\n\n    \nssl\n:\n \ntrue\n,\n\n    \nworker\n:\n \nworker\n\n \n)\n\n\n\n\n\n\nYou can override the port by specifying a custom port using the following parameters:\n\n\n// Future\nHTTPClient\n\n \nlet\n \nclient\n \n=\n \ntry\n \nHTTPClient\n.\nconnect\n(\n\n    \nto\n:\n \nlocalhost\n,\n\n    \nport\n:\n \n8080\n,\n\n    \nssl\n:\n \nfalse\n,\n\n    \nworker\n:\n \nworker\n\n \n)\n\n\n\n\n\n\nSending Requests\n\n\nFrom here, you can send \nRequests\n. You can only send one request at a time. Sending a request before a \nResponse\n has been received has unpredictable consequences.\n\n\n// Future\nResponse\n\n\nlet\n \nresponse\n \n=\n \nclient\n.\nflatMap\n \n{\n \nconnectedClient\n \nin\n\n  \nlet\n \nrequest\n \n=\n \nRequest\n(\n\n    \nmethod\n:\n \n.\nget\n,\n\n    \nuri\n:\n \nhttps://example.com/\n\n  \n)\n\n\n  \nreturn\n \nconnectedClient\n.\nsend\n(\nrequest\n:\n \nrequest\n)\n\n\n}", 
            "title": "Client"
        }, 
        {
            "location": "/http/client/#http-client", 
            "text": "HTTP Clients are often used to communicate with external APIs such as PayPal, Stripe or Mailgun.", 
            "title": "HTTP Client"
        }, 
        {
            "location": "/http/client/#connecting", 
            "text": "Connecting only requires a hostname and a boolean indicating if you want to use SSL. For almost every use case it is recommended to use SSL. If you're processing any sensitive data such as payments, emails and other personal data you will need to use SSL by setting it to  true .  HTTP clients require a  Worker , too, so it can run on the current  EventLoop  // Future HTTPClient \n  let   client   =   try   HTTPClient . connect ( \n     to :   example.com , \n     ssl :   true , \n     worker :   worker \n  )   You can override the port by specifying a custom port using the following parameters:  // Future HTTPClient \n  let   client   =   try   HTTPClient . connect ( \n     to :   localhost , \n     port :   8080 , \n     ssl :   false , \n     worker :   worker \n  )", 
            "title": "Connecting"
        }, 
        {
            "location": "/http/client/#sending-requests", 
            "text": "From here, you can send  Requests . You can only send one request at a time. Sending a request before a  Response  has been received has unpredictable consequences.  // Future Response  let   response   =   client . flatMap   {   connectedClient   in \n   let   request   =   Request ( \n     method :   . get , \n     uri :   https://example.com/ \n   ) \n\n   return   connectedClient . send ( request :   request )  }", 
            "title": "Sending Requests"
        }, 
        {
            "location": "/http/cookies/", 
            "text": "Cookies\n\n\nCookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.\n\n\nCreating cookies\n\n\nVapor has three related objects for Cookies.\n\n\nThe \nCookies\n object is an array of multiple Cookie objects.\n\n\nThe \nCookie\n object is a single key-value pair. Where the key is the Cookie name.\n\n\nThe \nValue\n object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.\n\n\nValues\n\n\nValues can be initialized with a String Literal.\n\n\nvar\n \nvalue\n:\n \nCookie\n.\nValue\n \n=\n \nString Literal\n\n\n\n\n\n\nThey can be manipulated to add other properties.\n\n\n// Expires in one day\n\n\nvalue\n.\nexpires\n \n=\n \nDate\n().\naddingTimeInterval\n(\n24\n \n*\n \n3600\n)\n\n\n\n\n\n\nA single Cookie\n\n\nCreating a \nCookie\n requires a name and a Value.\n\n\nlet\n \ncookie\n \n=\n \nCookie\n(\nnamed\n:\n \nsession\n,\n \nvalue\n:\n \nvalue\n)\n\n\n\n\n\n\nMultiple cookies\n\n\nCookies\n can be initialized with a dictionary literal.\n\n\nlet\n \ncookies\n:\n \nCookies\n \n=\n \n[\n\n  \nsession\n:\n \nString Literal\n\n\n]\n\n\n\n\n\n\nThe above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#cookies", 
            "text": "Cookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#creating-cookies", 
            "text": "Vapor has three related objects for Cookies.  The  Cookies  object is an array of multiple Cookie objects.  The  Cookie  object is a single key-value pair. Where the key is the Cookie name.  The  Value  object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.", 
            "title": "Creating cookies"
        }, 
        {
            "location": "/http/cookies/#values", 
            "text": "Values can be initialized with a String Literal.  var   value :   Cookie . Value   =   String Literal   They can be manipulated to add other properties.  // Expires in one day  value . expires   =   Date (). addingTimeInterval ( 24   *   3600 )", 
            "title": "Values"
        }, 
        {
            "location": "/http/cookies/#a-single-cookie", 
            "text": "Creating a  Cookie  requires a name and a Value.  let   cookie   =   Cookie ( named :   session ,   value :   value )", 
            "title": "A single Cookie"
        }, 
        {
            "location": "/http/cookies/#multiple-cookies", 
            "text": "Cookies  can be initialized with a dictionary literal.  let   cookies :   Cookies   =   [ \n   session :   String Literal  ]   The above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Multiple cookies"
        }, 
        {
            "location": "/http/headers/", 
            "text": "Headers\n\n\nHTTP Headers are the metadata of a request/response. They can provide a wide variety of information.\n\n\nHeaders\n are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.\n\n\nCreating a Headers object\n\n\nThe most common syntax for creating Headers is a dictionary literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nThe left hand side (key) is a \nHeader.Name\n.\n\n\nA name can also be initialized with a String literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \nContent-Type\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nAccessing headers\n\n\nThere are two ways to access Headers. Either by accessing a single (the first) value, or all values.\n\n\nA single value example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\nprint\n(\nheaders\n[.\ncontentType\n])\n \n// prints \ntext/html\n\n\n\n\n\n\nAccessing all values example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\nsetCookie\n:\n \nsession=afasfwrw3qr241j4qwmdsijfo13k43\n,\n\n  \n.\nsetCookie\n:\n \nawesome=true\n\n\n]\n\n\n\n// prints [\nsession=afasfwrw3qr241j4qwmdsijfo13k43\n, \nawesome=true\n]\n\n\nprint\n(\nheaders\n[\nvaluesFor\n:\n \n.\ncontentType\n])", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#headers", 
            "text": "HTTP Headers are the metadata of a request/response. They can provide a wide variety of information.  Headers  are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#creating-a-headers-object", 
            "text": "The most common syntax for creating Headers is a dictionary literal.  let   headers :   Headers   =   [ \n   . contentType :   text/html  ]   The left hand side (key) is a  Header.Name .  A name can also be initialized with a String literal.  let   headers :   Headers   =   [ \n   Content-Type :   text/html  ]", 
            "title": "Creating a Headers object"
        }, 
        {
            "location": "/http/headers/#accessing-headers", 
            "text": "There are two ways to access Headers. Either by accessing a single (the first) value, or all values.", 
            "title": "Accessing headers"
        }, 
        {
            "location": "/http/headers/#a-single-value-example", 
            "text": "let   headers :   Headers   =   [ \n   . contentType :   text/html  ]  print ( headers [. contentType ])   // prints  text/html", 
            "title": "A single value example:"
        }, 
        {
            "location": "/http/headers/#accessing-all-values-example", 
            "text": "let   headers :   Headers   =   [ \n   . setCookie :   session=afasfwrw3qr241j4qwmdsijfo13k43 , \n   . setCookie :   awesome=true  ]  // prints [ session=afasfwrw3qr241j4qwmdsijfo13k43 ,  awesome=true ]  print ( headers [ valuesFor :   . contentType ])", 
            "title": "Accessing all values example:"
        }, 
        {
            "location": "/http/method/", 
            "text": "Method\n\n\nMethods are used to indicate the type of operation requested for a route. They're part exclusively in \nHTTP Requests\n and are required.\n\n\n\n\n\n\n\n\nMethod\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n.get\n\n\nUsed for retrieving content\n\n\n\n\n\n\n.head\n\n\nUsed for retrieving content metadata\n\n\n\n\n\n\n.put\n\n\nUsed for replacing content\n\n\n\n\n\n\n.post\n\n\nUsed for creating content\n\n\n\n\n\n\n.delete\n\n\nUsed for deleting content\n\n\n\n\n\n\n\n\nA \npath\n is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Methods"
        }, 
        {
            "location": "/http/method/#method", 
            "text": "Methods are used to indicate the type of operation requested for a route. They're part exclusively in  HTTP Requests  and are required.     Method  Purpose      .get  Used for retrieving content    .head  Used for retrieving content metadata    .put  Used for replacing content    .post  Used for creating content    .delete  Used for deleting content     A  path  is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Method"
        }, 
        {
            "location": "/http/middleware/", 
            "text": "Middleware\n\n\nMiddleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.\n\n\nThey can be employed for authorization checks, logging and a wide range of other functionalities.\n\n\nImplementing a Middleware\n\n\nThe following example is a middleware that will prevent all \nrequests\n from going to their respective \nresponder\n unless the origin has a special header set. In the case of a missing header, \nstatus code\n 404 (not found) will be returned.\n\n\nDon't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.\n\n\npublic\n \nfinal\n \nclass\n \nSpecialHeaderCheckMiddleware\n:\n \nMiddleware\n \n{\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nguard\n \nrequest\n.\nheaders\n[\nSecret-Header\n]\n \n==\n \nMagicK3y\n \nelse\n \n{\n\n      \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nnotFound\n)\n\n    \n}\n\n\n    \nreturn\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIntercepting/transforming Responses\n\n\nThe following example demonstrates a middleware that creates a session token for new users.\n\n\n// For the random number\n\n\nimport\n \nCrypto\n\n\n\nstruct\n \nInvalidString\n \n:\n \nSwift\n.\nError\n \n{}\n\n\n\npublic\n \nfinal\n \nclass\n \nSessionTokenMiddleware\n:\n \nMiddleware\n \n{\n\n  \nfunc\n \ngenerateSessionToken\n()\n \nthrows\n \n-\n \nString\n \n{\n\n    \n// Generate token here ...\n\n    \nlet\n \nbase64\n \n=\n \nBase64Encoder\n.\nencode\n(\nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n))\n\n\n    \n// Convert to a String\n\n    \nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nbase64\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n      \n// This can never happen, but throw an error anyways\n\n      \nthrow\n \nInvalidString\n()\n\n    \n}\n\n\n    \nreturn\n \nstring\n\n  \n}\n\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nlet\n \nresponse\n \n=\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n\n    \n// If the session cookie is not set\n\n    \nguard\n \nrequest\n.\ncookies\n[\nsession\n]\n \n!=\n \nnil\n \nelse\n \n{\n\n      \n// Set a new session token\n\n      \nresponse\n.\ncookies\n[\nsession\n]\n \n=\n \ntry\n \ngenerateSessionToken\n()\n\n\n      \nreturn\n \nresponse\n\n    \n}\n\n\n    \nreturn\n \nresponse\n\n  \n}\n\n\n}", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#middleware", 
            "text": "Middleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.  They can be employed for authorization checks, logging and a wide range of other functionalities.", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#implementing-a-middleware", 
            "text": "The following example is a middleware that will prevent all  requests  from going to their respective  responder  unless the origin has a special header set. In the case of a missing header,  status code  404 (not found) will be returned.  Don't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.  public   final   class   SpecialHeaderCheckMiddleware :   Middleware   { \n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     guard   request . headers [ Secret-Header ]   ==   MagicK3y   else   { \n       return   Response ( status :   . notFound ) \n     } \n\n     return   try   next . respond ( to :   request ) \n   }  }", 
            "title": "Implementing a Middleware"
        }, 
        {
            "location": "/http/middleware/#interceptingtransforming-responses", 
            "text": "The following example demonstrates a middleware that creates a session token for new users.  // For the random number  import   Crypto  struct   InvalidString   :   Swift . Error   {}  public   final   class   SessionTokenMiddleware :   Middleware   { \n   func   generateSessionToken ()   throws   -   String   { \n     // Generate token here ... \n     let   base64   =   Base64Encoder . encode ( OSRandom (). data ( count :   32 )) \n\n     // Convert to a String \n     guard   let   string   =   String ( bytes :   base64 ,   encoding :   . utf8 )   else   { \n       // This can never happen, but throw an error anyways \n       throw   InvalidString () \n     } \n\n     return   string \n   } \n\n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     let   response   =   try   next . respond ( to :   request ) \n\n     // If the session cookie is not set \n     guard   request . cookies [ session ]   !=   nil   else   { \n       // Set a new session token \n       response . cookies [ session ]   =   try   generateSessionToken () \n\n       return   response \n     } \n\n     return   response \n   }  }", 
            "title": "Intercepting/transforming Responses"
        }, 
        {
            "location": "/http/multipart/", 
            "text": "Multipart Forms\n\n\nMultipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.\n\n\nParsing a multipart form\n\n\nMultipart forms can be parsed using \nMultipartParser\n.\n\n\nlet\n \nmultipartForm\n \n=\n \ntry\n \nMultipartParser\n.\nparse\n(\nfrom\n:\n \nrequest\n)\n\n\n\n\n\n\nReading forms\n\n\nThe parsed form is an array of \nPart\n instances.\nEach of them contains data and headers.\n\n\nYou can read a part using either manually or using the \nForm\n's helpers.\n\n\nlet\n \npictureData\n \n=\n \ntry\n \nmultipartForm\n.\ngetFile\n(\nforName\n:\n \nprofile-picture\n)\n\n\n\n\n\n\nlet\n \nnewPassword\n \n=\n \ntry\n \nmultipartForm\n.\ngetString\n(\nforName\n:\n \npassword\n)", 
            "title": "Multipart"
        }, 
        {
            "location": "/http/multipart/#multipart-forms", 
            "text": "Multipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.", 
            "title": "Multipart Forms"
        }, 
        {
            "location": "/http/multipart/#parsing-a-multipart-form", 
            "text": "Multipart forms can be parsed using  MultipartParser .  let   multipartForm   =   try   MultipartParser . parse ( from :   request )", 
            "title": "Parsing a multipart form"
        }, 
        {
            "location": "/http/multipart/#reading-forms", 
            "text": "The parsed form is an array of  Part  instances.\nEach of them contains data and headers.  You can read a part using either manually or using the  Form 's helpers.  let   pictureData   =   try   multipartForm . getFile ( forName :   profile-picture )   let   newPassword   =   try   multipartForm . getString ( forName :   password )", 
            "title": "Reading forms"
        }, 
        {
            "location": "/http/request/", 
            "text": "Request\n\n\nWhen a client connects with an HTTP Server it sends a \nRequest\n. This HTTP request will be processed \nas discussed here\n and resolved into a \nResponse\n. This is the response in the http \nRequest/Response model\n.\n\n\nRequests consist of a \nMethod\n, \nURI\n and \nHeaders\n.\n\n\nRequests can optionally also contain a \nBody\n.\n\n\nRequests are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nRequest properties\n\n\nRequest has a few primary properties according to spec, and one extra property as part of the Vapor framework.\n\n\nThe \nRequest Method\n, \nURI\n, \nHeaders\n and \nBody\n are available.\n\n\nWe also provide access to the HTTP version, although this will almost always be \n1.1\n.\n\n\nIn addition to these properties there is an Extend available which an be used to store extra information for each request.\n\n\nIt can be used to store information between \nmiddlewares\n and the responder and is used by Vapor to store the current \nWorker\n, too.\n\n\nUsing Extend, many properties can be added in extensions.\n\n\nCreating a Request\n\n\nCreating requests is necessary for \nHTTP Clients\n.\n\n\nA request accepts a method, uri, version, headers and body. The version's default is recommended. The body is optional.\n\n\nThe body can be a \nBody\n or \nBodyRepresentable\n. If the body is a \nBodyRepresentable\n the \nResponse\n initializer will become throwing.\n\n\nlet\n \nrequest1\n \n=\n \nRequest\n(\n\n                \nmethod\n:\n \n.\nget\n,\n\n                \nuri\n:\n \nuri\n,\n\n                \nheaders\n:\n \nheaders\n,\n\n                \nbody\n:\n \nbody\n\n              \n)\n\n\n\nlet\n \nrequest2\n \n=\n \ntry\n \nRequest\n(\n\n                \nmethod\n:\n \n.\nget\n,\n\n                \nuri\n:\n \nuri\n,\n\n                \nheaders\n:\n \nheaders\n,\n\n                \nbody\n:\n \nbodyRepresentable\n\n              \n)", 
            "title": "Request"
        }, 
        {
            "location": "/http/request/#request", 
            "text": "When a client connects with an HTTP Server it sends a  Request . This HTTP request will be processed  as discussed here  and resolved into a  Response . This is the response in the http  Request/Response model .  Requests consist of a  Method ,  URI  and  Headers .  Requests can optionally also contain a  Body .  Requests are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.", 
            "title": "Request"
        }, 
        {
            "location": "/http/request/#request-properties", 
            "text": "Request has a few primary properties according to spec, and one extra property as part of the Vapor framework.  The  Request Method ,  URI ,  Headers  and  Body  are available.  We also provide access to the HTTP version, although this will almost always be  1.1 .  In addition to these properties there is an Extend available which an be used to store extra information for each request.  It can be used to store information between  middlewares  and the responder and is used by Vapor to store the current  Worker , too.  Using Extend, many properties can be added in extensions.", 
            "title": "Request properties"
        }, 
        {
            "location": "/http/request/#creating-a-request", 
            "text": "Creating requests is necessary for  HTTP Clients .  A request accepts a method, uri, version, headers and body. The version's default is recommended. The body is optional.  The body can be a  Body  or  BodyRepresentable . If the body is a  BodyRepresentable  the  Response  initializer will become throwing.  let   request1   =   Request ( \n                 method :   . get , \n                 uri :   uri , \n                 headers :   headers , \n                 body :   body \n               )  let   request2   =   try   Request ( \n                 method :   . get , \n                 uri :   uri , \n                 headers :   headers , \n                 body :   bodyRepresentable \n               )", 
            "title": "Creating a Request"
        }, 
        {
            "location": "/http/response/", 
            "text": "HTTP Response\n\n\nWhen a client connects with an HTTP Server it sends a \nRequest\n. This HTTP request will be processed \nas discussed here\n and resolved into a \nResponse\n. This is the response in the http Request/Response model.\n\n\nHTTP's Response object contains a \nStatus\n, \nHeaders\n and a \nBody\n. Before further reading this page, you must have read and understood the previous pages for Status, Headers and Body.\n\n\nResponses are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nCreating a Response\n\n\nA Response accepts a version, status, headers and body. The version's default is recommended. The body is optional.\n\n\nThe body can be a \nBody\n or \nBodyRepresentable\n. If the body is a \nBodyRepresentable\n the \nResponse\n initializer will become throwing.\n\n\nlet\n \nresponse1\n \n=\n \nResponse\n(\n\n                  \nstatus\n:\n \nstatus\n,\n\n                  \nheaders\n:\n \nheaders\n,\n\n                  \nbody\n:\n \nbody\n)\n\n\n\nlet\n \nresponse2\n \n=\n \ntry\n \nResponse\n(\n\n                  \nstatus\n:\n \nstatus\n,\n\n                  \nheaders\n:\n \nheaders\n,\n\n                  \nbody\n:\n \nbodyRepresentable\n)\n\n\n\n\n\n\nResponseRepresentable\n\n\nInstead of requiring a Response, many parts of the framework and related libraries work with the protocol \nResponseRepresentable\n. When types conform to \nResponseRepresentable\n they're required to implement a \nmakeResponse\n function that allows conversion from this instance to a \nResponse\n.\n\n\nFor the purpose of an example, we'll convert an integer to a \nResponse\n. This \nInt\n will always response with a status code 200 (OK) and a body containing itself in textual representation.\n\n\nextension\n \nInt\n:\n \nResponseRepresentable\n \n{\n\n  \npublic\n \nfunc\n \nmakeResponse\n()\n \nthrows\n \n-\n \nResponse\n \n{\n\n    \nreturn\n \ntry\n \nResponse\n(\nstatus\n:\n \n.\nok\n,\n \nbody\n:\n \nself\n.\ndescription\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nResponseInitializable\n\n\nResponseInitializable\n is used for converting a \nResponse\n to another type.\n\n\nThis is particularly useful for \nHTTP Clients\n that interact with existing APIs.\n\n\nThis example is pseudocode for interacting with a payment API such as Stripe or PayPal in a type-safe fashion.\n\n\nstruct\n \nPaymentStatus\n:\n \nResponseInitializable\n \n{\n\n  \npublic\n \ninit\n(\nresponse\n:\n \nResponse\n)\n \nthrows\n \n{\n\n    \n// Create a `PaymentStatus` from the API call\ns `Response`\n\n  \n}\n\n\n}", 
            "title": "Response"
        }, 
        {
            "location": "/http/response/#http-response", 
            "text": "When a client connects with an HTTP Server it sends a  Request . This HTTP request will be processed  as discussed here  and resolved into a  Response . This is the response in the http Request/Response model.  HTTP's Response object contains a  Status ,  Headers  and a  Body . Before further reading this page, you must have read and understood the previous pages for Status, Headers and Body.  Responses are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.", 
            "title": "HTTP Response"
        }, 
        {
            "location": "/http/response/#creating-a-response", 
            "text": "A Response accepts a version, status, headers and body. The version's default is recommended. The body is optional.  The body can be a  Body  or  BodyRepresentable . If the body is a  BodyRepresentable  the  Response  initializer will become throwing.  let   response1   =   Response ( \n                   status :   status , \n                   headers :   headers , \n                   body :   body )  let   response2   =   try   Response ( \n                   status :   status , \n                   headers :   headers , \n                   body :   bodyRepresentable )", 
            "title": "Creating a Response"
        }, 
        {
            "location": "/http/response/#responserepresentable", 
            "text": "Instead of requiring a Response, many parts of the framework and related libraries work with the protocol  ResponseRepresentable . When types conform to  ResponseRepresentable  they're required to implement a  makeResponse  function that allows conversion from this instance to a  Response .  For the purpose of an example, we'll convert an integer to a  Response . This  Int  will always response with a status code 200 (OK) and a body containing itself in textual representation.  extension   Int :   ResponseRepresentable   { \n   public   func   makeResponse ()   throws   -   Response   { \n     return   try   Response ( status :   . ok ,   body :   self . description ) \n   }  }", 
            "title": "ResponseRepresentable"
        }, 
        {
            "location": "/http/response/#responseinitializable", 
            "text": "ResponseInitializable  is used for converting a  Response  to another type.  This is particularly useful for  HTTP Clients  that interact with existing APIs.  This example is pseudocode for interacting with a payment API such as Stripe or PayPal in a type-safe fashion.  struct   PaymentStatus :   ResponseInitializable   { \n   public   init ( response :   Response )   throws   { \n     // Create a `PaymentStatus` from the API call s `Response` \n   }  }", 
            "title": "ResponseInitializable"
        }, 
        {
            "location": "/http/responder/", 
            "text": "Responder\n\n\nResponders are a type capable of \nresponding\n to a \nRequest\n.\n\n\nResponders are always \nasync\n by returning a \nFuture\nResponse\n by either transforming/mapping an existing future or creating it's own promise.\n\n\nImplementing a static Responder\n\n\nstruct\n \nStaticResponder\n:\n \nResponder\n \n{\n\n  \nlet\n \nresponse\n:\n \nResponse\n\n\n  \ninit\n(\nresponse\n:\n \nResponse\n)\n \n{\n\n    \nself\n.\nresponse\n \n=\n \nresponse\n\n  \n}\n\n\n  \nfunc\n \nrespond\n(\nto\n \nreq\n:\n \nRequest\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nreturn\n \nFuture\n(\nresponse\n)\n\n  \n}\n\n\n}", 
            "title": "Responder"
        }, 
        {
            "location": "/http/responder/#responder", 
            "text": "Responders are a type capable of  responding  to a  Request .  Responders are always  async  by returning a  Future Response  by either transforming/mapping an existing future or creating it's own promise.", 
            "title": "Responder"
        }, 
        {
            "location": "/http/responder/#implementing-a-static-responder", 
            "text": "struct   StaticResponder :   Responder   { \n   let   response :   Response \n\n   init ( response :   Response )   { \n     self . response   =   response \n   } \n\n   func   respond ( to   req :   Request )   throws   -   Future Response   { \n     return   Future ( response ) \n   }  }", 
            "title": "Implementing a static Responder"
        }, 
        {
            "location": "/http/status/", 
            "text": "Status codes\n\n\nStatus codes are exclusively part of the \nHTTP Response\n and are required.\n\n\nStatus codes are a 3 digit number.\n\n\nThe first of the 3 numbers indicated the type of response.\n\n\n\n\n\n\n\n\n_xx\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n1xx\n\n\nInformational response\n\n\n\n\n\n\n2xx\n\n\nSuccess\n\n\n\n\n\n\n3xx\n\n\nRedirection\n\n\n\n\n\n\n4xx\n\n\nClient error\n\n\n\n\n\n\n5xx\n\n\nServer error\n\n\n\n\n\n\n\n\nThe other 2 numbers in a status code are used to define a specific code.\n\n\nSelecting a status code\n\n\nThe enum \nStatus\n has all supported status codes. It can be accessed using a \n.\n or created using an integer literal.\n\n\nlet\n \nok\n \n=\n \nStatus\n.\nok\n\n\nlet\n \nnotFound\n \n=\n \nStatus\n.\nnotFound\n\n\n\n\n\n\nlet\n \nok\n:\n \nStatus\n \n=\n \n200\n\n\nlet\n \nnotFound\n:\n \nStatus\n \n=\n \n404\n\n\n\n\n\n\nInformational responses\n\n\nInformational responses indicate a \nRequest\n was received and understood.\n\n\n101 - switching protocols\n\n\nSwitching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by \nWebSocket\n or HTTP/2.\n\n\nSuccess responses\n\n\nSuccess responses indicate that the request was received, understood, accepted and processed.\n\n\n200 - OK\n\n\n200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.\n\n\nRedirection responses\n\n\nRedirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.\n\n\nClient error responses\n\n\nClient errors indicate an error was caused by the client.\n\n\n400 - Bad Request\n\n\nThe error was caused by the client sending an invalid request.\n\n\nFor example an invalid message, malformed request syntax or too large request size.\n\n\n403 - Forbidden\n\n\nThe client does not have the permissions to execute this operation on the specified resource.\n\n\n404 - Not found\n\n\nThe requested resource does not exist.\n\n\nServer error responses\n\n\nServer errors occur when the an error occurred on the server side.\n\n\n500 - Internal Server Error\n\n\nInternal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#status-codes", 
            "text": "Status codes are exclusively part of the  HTTP Response  and are required.  Status codes are a 3 digit number.  The first of the 3 numbers indicated the type of response.     _xx  Meaning      1xx  Informational response    2xx  Success    3xx  Redirection    4xx  Client error    5xx  Server error     The other 2 numbers in a status code are used to define a specific code.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#selecting-a-status-code", 
            "text": "The enum  Status  has all supported status codes. It can be accessed using a  .  or created using an integer literal.  let   ok   =   Status . ok  let   notFound   =   Status . notFound   let   ok :   Status   =   200  let   notFound :   Status   =   404", 
            "title": "Selecting a status code"
        }, 
        {
            "location": "/http/status/#informational-responses", 
            "text": "Informational responses indicate a  Request  was received and understood.", 
            "title": "Informational responses"
        }, 
        {
            "location": "/http/status/#101-switching-protocols", 
            "text": "Switching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by  WebSocket  or HTTP/2.", 
            "title": "101 - switching protocols"
        }, 
        {
            "location": "/http/status/#success-responses", 
            "text": "Success responses indicate that the request was received, understood, accepted and processed.", 
            "title": "Success responses"
        }, 
        {
            "location": "/http/status/#200-ok", 
            "text": "200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.", 
            "title": "200 - OK"
        }, 
        {
            "location": "/http/status/#redirection-responses", 
            "text": "Redirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.", 
            "title": "Redirection responses"
        }, 
        {
            "location": "/http/status/#client-error-responses", 
            "text": "Client errors indicate an error was caused by the client.", 
            "title": "Client error responses"
        }, 
        {
            "location": "/http/status/#400-bad-request", 
            "text": "The error was caused by the client sending an invalid request.  For example an invalid message, malformed request syntax or too large request size.", 
            "title": "400 - Bad Request"
        }, 
        {
            "location": "/http/status/#403-forbidden", 
            "text": "The client does not have the permissions to execute this operation on the specified resource.", 
            "title": "403 - Forbidden"
        }, 
        {
            "location": "/http/status/#404-not-found", 
            "text": "The requested resource does not exist.", 
            "title": "404 - Not found"
        }, 
        {
            "location": "/http/status/#server-error-responses", 
            "text": "Server errors occur when the an error occurred on the server side.", 
            "title": "Server error responses"
        }, 
        {
            "location": "/http/status/#500-internal-server-error", 
            "text": "Internal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "500 - Internal Server Error"
        }, 
        {
            "location": "/http/body-stream/", 
            "text": "", 
            "title": "Streaming Body"
        }, 
        {
            "location": "/http/uri/", 
            "text": "URI\n\n\nURIs or \"Uniform Resource Identifiers\" are used for defining a resource.\n\n\nThey consist of the following components:\n\n\n\n\nscheme\n\n\nauthority\n\n\npath\n\n\nquery\n\n\nfragment\n\n\n\n\nCreating an URI\n\n\nURIs can be created from it's initializer or from a String literal.\n\n\nlet\n \nstringLiteralURI\n:\n \nURI\n \n=\n \nhttp://localhost:8080/path\n\n\nlet\n \nmanualURI\n:\n \nURI\n \n=\n \nURI\n(\n\n    \nscheme\n:\n \nhttp\n,\n\n    \nhostname\n:\n \nlocalhost\n,\n\n    \nport\n:\n \n8080\n,\n\n    \npath\n:\n \n/path\n\n\n)", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#uri", 
            "text": "URIs or \"Uniform Resource Identifiers\" are used for defining a resource.  They consist of the following components:   scheme  authority  path  query  fragment", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#creating-an-uri", 
            "text": "URIs can be created from it's initializer or from a String literal.  let   stringLiteralURI :   URI   =   http://localhost:8080/path  let   manualURI :   URI   =   URI ( \n     scheme :   http , \n     hostname :   localhost , \n     port :   8080 , \n     path :   /path  )", 
            "title": "Creating an URI"
        }, 
        {
            "location": "/fluent/getting-started/package/", 
            "text": "Adding Fluent to your Project\n\n\nFluent (\nvapor/fluent\n) is a type-safe, fast, and easy-to-use ORM built for Swift.\nIt takes advantage of Swift's strong type system to provide an elegant API for your database.\n\n\nDatabase\n\n\nIn addition to adding Fluent to your project, you must also add a Fluent compatible database.\nFluent does not include any databases by default. All official databases have a getting started guide similar to this one.\n\n\n\n\n\n\n\n\ndatabase\n\n\nlibrary\n\n\ndriver\n\n\nguide\n\n\n\n\n\n\n\n\n\n\nPostgreSQL\n\n\nvapor/postgres\n\n\nvapor/fluent-postgres\n\n\nPostgreSQL \n Package\n\n\n\n\n\n\nMySQL\n\n\nvapor/mysql\n\n\nvapor/fluent-mysql\n\n\nMySQL \n Package\n\n\n\n\n\n\nSQLite\n\n\nvapor/sqlite\n\n\nvapor/fluent-sqlite\n\n\nSQLite \n Package\n\n\n\n\n\n\nMongoDB\n\n\nmongokitten/mongokitten\n\n\nvapor/fluent-mongokitten\n\n\nREADME.md\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nAny database can be made to work with Fluent by conforming to its \nDatabase\n protocol.\nFor a list of all compatible database types, search GitHub for the \nfluent-driver\n topic.\n\n\n\n\nFluent\n\n\nAfter you have added your database driver, simply add the Fluent package to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/fluent.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nFluent\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\n\n\nNote\n\n\nUse \nimport Fluent\n to access Fluent's APIs.\n\n\n\n\nOnce you have Fluent added to your project, you are ready to \nconfigure your database(s)\n.", 
            "title": "Package"
        }, 
        {
            "location": "/fluent/getting-started/package/#adding-fluent-to-your-project", 
            "text": "Fluent ( vapor/fluent ) is a type-safe, fast, and easy-to-use ORM built for Swift.\nIt takes advantage of Swift's strong type system to provide an elegant API for your database.", 
            "title": "Adding Fluent to your Project"
        }, 
        {
            "location": "/fluent/getting-started/package/#database", 
            "text": "In addition to adding Fluent to your project, you must also add a Fluent compatible database.\nFluent does not include any databases by default. All official databases have a getting started guide similar to this one.     database  library  driver  guide      PostgreSQL  vapor/postgres  vapor/fluent-postgres  PostgreSQL   Package    MySQL  vapor/mysql  vapor/fluent-mysql  MySQL   Package    SQLite  vapor/sqlite  vapor/fluent-sqlite  SQLite   Package    MongoDB  mongokitten/mongokitten  vapor/fluent-mongokitten  README.md      Tip  Any database can be made to work with Fluent by conforming to its  Database  protocol.\nFor a list of all compatible database types, search GitHub for the  fluent-driver  topic.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/getting-started/package/#fluent", 
            "text": "After you have added your database driver, simply add the Fluent package to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/fluent.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Fluent ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .   Note  Use  import Fluent  to access Fluent's APIs.   Once you have Fluent added to your project, you are ready to  configure your database(s) .", 
            "title": "Fluent"
        }, 
        {
            "location": "/fluent/getting-started/provider/", 
            "text": "Configuring Fluent\n\n\nFluent integrates seamlessly into your Vapor project using \nservices\n.\nIn this section we will add the Fluent service provider to your application and configure your databases.\n\n\n\n\nWarning\n\n\nThis section assumes you have added both \nFluent\n and a \nFluent database\n to your package.\n\n\n\n\nService Provider\n\n\nThe first step to using Fluent, is registering it with your Vapor application.\n\n\nimport\n \nFluent\n\n\n\n...\n\n\n\ntry\n \nservices\n.\nregister\n(\nFluentProvider\n())\n\n\n\n\n\n\nRegister the \nFluentProvider\n in the \nconfigure section\n of your application.\n\n\n\n\nQuestion\n\n\nLearn more about how service providers work in \nGetting Started: Application\n\nand \nConcepts: Services\n.\n\n\n\n\nConfig\n\n\nOnce the service provider has been added, we can configure one or more databases\nto be used with Fluent.\n\n\nIdentifier\n\n\nEach database you use with Fluent must have a unique identifier. The easiest way to\nkeep track of this identifier is to add it as static extension to \nDatabaseIdentifier\n.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFluentSQLite\n\n\n\nextension\n \nDatabaseIdentifier\n \n{\n\n    \nstatic\n \nvar\n \nfoo\n:\n \nDatabaseIdentifier\nSQLiteDatabase\n \n{\n\n        \nreturn\n \n.\ninit\n(\nfoo\n)\n\n    \n}\n\n\n    \nstatic\n \nvar\n \nbar\n:\n \nDatabaseIdentifier\nMySQLDatabase\n \n{\n\n        \nreturn\n \n.\ninit\n(\nbar\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow we can use the identifier anywhere in our project:\n\n\nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nThe \nconfigure section\n of your project is a good place to put this extension.\n\n\nDatabases\n\n\nNow that we have created a unique identifier for our database, we can register it\nto our application using \nDatabaseConfig\n. A good place to do this is in the\n\nconfigure section\n of your project.\n\n\nYou can add databases to the \nDatabaseConfig\n using either a type (\n.self\n) or an instance.\n\n\nType\n\n\nIf you register a database type (like \nSQLiteDatabase.self\n), Fluent will ask the application\nto create an instance of your database at boot.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentSQLite\n\n\n\n...\n\n\n\nvar\n \ndatabaseConfig\n \n=\n \nDatabaseConfig\n()\n\n\n\ndatabaseConfig\n.\nadd\n(\ndatabase\n:\n \nSQLiteDatabase\n.\nself\n,\n \nas\n:\n \n.\nfoo\n)\n\n\n\nservices\n.\nregister\n(\ndatabaseConfig\n)\n\n\n\n\n\n\nInstance\n\n\nYou can also register a pre-initialized database. This is especially useful if you'd\nlike to configure two instances of the same database type.\n\n\nimport\n \nFluent\n\n\nimport\n \nFluentMySQL\n\n\n\n...\n\n\n\nvar\n \ndatabaseConfig\n \n=\n \nDatabaseConfig\n()\n\n\n\nlet\n \nmysql\n \n=\n \nMySQLDatabase\n(...)\n\n\ndatabaseConfig\n.\nadd\n(\ndatabase\n:\n \nmysql\n,\n \nas\n:\n \n.\nbar\n)\n\n\n\nservices\n.\nregister\n(\ndatabaseConfig\n)\n\n\n\n\n\n\nMigrations\n\n\nIf your database uses schemas (most SQL databases do, whereas NoSQL databases don't), you will also want to configure\nyour migrations using \nMigrationConfig\n.\n\n\nimport\n \nFluent\n\n\n\n...\n\n\n\nvar\n \nmigrationConfig\n \n=\n \nMigrationConfig\n()\n\n\n\nmigrationConfig\n.\nadd\n(\nmigration\n:\n \nUser\n.\nself\n,\n \ndatabase\n:\n \n.\nfoo\n)\n\n\n\nservices\n.\nregister\n(\nmigrationConfig\n)\n\n\n\n\n\n\nYou can read more about migrations in \nFluent: Migrations\n.\n\n\nDone\n\n\nYou should now be able to compile and run your application. The next step is to create your\nmodels.", 
            "title": "Provider"
        }, 
        {
            "location": "/fluent/getting-started/provider/#configuring-fluent", 
            "text": "Fluent integrates seamlessly into your Vapor project using  services .\nIn this section we will add the Fluent service provider to your application and configure your databases.   Warning  This section assumes you have added both  Fluent  and a  Fluent database  to your package.", 
            "title": "Configuring Fluent"
        }, 
        {
            "location": "/fluent/getting-started/provider/#service-provider", 
            "text": "The first step to using Fluent, is registering it with your Vapor application.  import   Fluent  ...  try   services . register ( FluentProvider ())   Register the  FluentProvider  in the  configure section  of your application.   Question  Learn more about how service providers work in  Getting Started: Application \nand  Concepts: Services .", 
            "title": "Service Provider"
        }, 
        {
            "location": "/fluent/getting-started/provider/#config", 
            "text": "Once the service provider has been added, we can configure one or more databases\nto be used with Fluent.", 
            "title": "Config"
        }, 
        {
            "location": "/fluent/getting-started/provider/#identifier", 
            "text": "Each database you use with Fluent must have a unique identifier. The easiest way to\nkeep track of this identifier is to add it as static extension to  DatabaseIdentifier .  import   Fluent  import   FluentMySQL  import   FluentSQLite  extension   DatabaseIdentifier   { \n     static   var   foo :   DatabaseIdentifier SQLiteDatabase   { \n         return   . init ( foo ) \n     } \n\n     static   var   bar :   DatabaseIdentifier MySQLDatabase   { \n         return   . init ( bar ) \n     }  }   Now we can use the identifier anywhere in our project:  req . database (. foo )   {   ...   }   The  configure section  of your project is a good place to put this extension.", 
            "title": "Identifier"
        }, 
        {
            "location": "/fluent/getting-started/provider/#databases", 
            "text": "Now that we have created a unique identifier for our database, we can register it\nto our application using  DatabaseConfig . A good place to do this is in the configure section  of your project.  You can add databases to the  DatabaseConfig  using either a type ( .self ) or an instance.", 
            "title": "Databases"
        }, 
        {
            "location": "/fluent/getting-started/provider/#type", 
            "text": "If you register a database type (like  SQLiteDatabase.self ), Fluent will ask the application\nto create an instance of your database at boot.  import   Fluent  import   FluentSQLite  ...  var   databaseConfig   =   DatabaseConfig ()  databaseConfig . add ( database :   SQLiteDatabase . self ,   as :   . foo )  services . register ( databaseConfig )", 
            "title": "Type"
        }, 
        {
            "location": "/fluent/getting-started/provider/#instance", 
            "text": "You can also register a pre-initialized database. This is especially useful if you'd\nlike to configure two instances of the same database type.  import   Fluent  import   FluentMySQL  ...  var   databaseConfig   =   DatabaseConfig ()  let   mysql   =   MySQLDatabase (...)  databaseConfig . add ( database :   mysql ,   as :   . bar )  services . register ( databaseConfig )", 
            "title": "Instance"
        }, 
        {
            "location": "/fluent/getting-started/provider/#migrations", 
            "text": "If your database uses schemas (most SQL databases do, whereas NoSQL databases don't), you will also want to configure\nyour migrations using  MigrationConfig .  import   Fluent  ...  var   migrationConfig   =   MigrationConfig ()  migrationConfig . add ( migration :   User . self ,   database :   . foo )  services . register ( migrationConfig )   You can read more about migrations in  Fluent: Migrations .", 
            "title": "Migrations"
        }, 
        {
            "location": "/fluent/getting-started/provider/#done", 
            "text": "You should now be able to compile and run your application. The next step is to create your\nmodels.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/models/", 
            "text": "Getting Started with Models\n\n\nModels are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped \narrays or dictionaries for queries. Instead, you query the database using models. This allows the \nSwift compiler to catch many errors that have burdened ORM users for ages.\n\n\nIn this guide, we will cover the creation of a basic \nUser\n model. See \nFluent \n Model\n for\nmore in-depth information about the model protocol.\n\n\nClass\n\n\nEvery Fluent model starts with a \nCodable\n class. You can make any \nCodable\n class a Fluent model, \neven ones that come from a different module. All you have to do is conform to \nModel\n. \n\n\nimport\n \nFoundation\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nCodable\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nAlthough it's not necessary, adding \nfinal\n to your Swift classes can make them more performant\nand also make adding \ninit\n methods in extensions easier.\n\n\nConforming to Model\n\n\nNow that we have our \nUser\n class, let's conform it to \nModel\n.\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n\n\n}\n\n\n\n\n\n\nOnce you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make \nUser\n conform to model.\n\n\n\n\nTip\n\n\nWe recommend adding \nModel\n conformance in an extension to help keep your code clean.\n\n\n\n\nDatabase\n\n\nThe first step to conforming to \nModel\n is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n \n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n}\n\n\n\n\n\n\nID\n\n\nNow we can tell Fluent what type of ID this model uses. In this example, our \nUser\n model\nhas an ID property of type \nUUID\n named \nid\n.\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFoundation\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can use any type that conforms to \nIDType\n as a Fluent ID. See \nFluent \n Model \n ID\n for more information.\nYou can also use any property name you'd like for the id.\n\n\n\n\nWarning\n\n\nSome databases require certain ID keys. For example, MongoDB requires \n_id\n.\n\n\n\n\nKey Field Map\n\n\nIn order to prevent duplicate (and error-prone) strings throughout your code, Fluent models declare\na \nKeyFieldMap\n. This maps your model's properties to their respective database fields.\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.keyFieldMap\n\n    \nstatic\n \nvar\n \nkeyFieldMap\n:\n \nKeyFieldMap\n \n{\n\n        \nreturn\n \n[\n\n            \nkey\n(\n\\\n.\nid\n):\n \nfield\n(\nid\n),\n\n            \nkey\n(\n\\\n.\nname\n):\n \nfield\n(\nname\n),\n\n            \nkey\n(\n\\\n.\nage\n):\n \nfield\n(\nage\n),\n\n        \n]\n\n    \n}\n\n\n}\n\n\n\n\n\n\nKey paths are a type-safe way to declare references to your model's properties.\nYou can learn more about key paths in the Swift Evolution proposal, \nSE-0161\n.\n\n\n\n\nNote\n\n\nUnless you have a special use case, you should always \njust set the \nfield(...)\n and \nkey(...)\n as the same string.\n\n\n\n\nTo see what using these key paths looks like in action, check out \nFluent \n Getting Started \n Query\n.\n\n\nExample\n\n\nWe now have a fully-conformed Fluent model!\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFoundation\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nCodable\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n    \n/// See Model.keyFieldMap\n\n    \nstatic\n \nvar\n \nkeyFieldMap\n:\n \nKeyFieldMap\n \n{\n\n        \nreturn\n \n[\n\n            \nkey\n(\n\\\n.\nid\n):\n \nfield\n(\nid\n),\n\n            \nkey\n(\n\\\n.\nname\n):\n \nfield\n(\nname\n),\n\n            \nkey\n(\n\\\n.\nage\n):\n \nfield\n(\nage\n),\n\n        \n]\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model, you can move onto \nquerying\n your model. \nHowever, if your database uses schemas, you may need to create a \nmigration\n for your model first.", 
            "title": "Models"
        }, 
        {
            "location": "/fluent/getting-started/models/#getting-started-with-models", 
            "text": "Models are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped \narrays or dictionaries for queries. Instead, you query the database using models. This allows the \nSwift compiler to catch many errors that have burdened ORM users for ages.  In this guide, we will cover the creation of a basic  User  model. See  Fluent   Model  for\nmore in-depth information about the model protocol.", 
            "title": "Getting Started with Models"
        }, 
        {
            "location": "/fluent/getting-started/models/#class", 
            "text": "Every Fluent model starts with a  Codable  class. You can make any  Codable  class a Fluent model, \neven ones that come from a different module. All you have to do is conform to  Model .   import   Foundation  final   class   User :   Codable   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }   Although it's not necessary, adding  final  to your Swift classes can make them more performant\nand also make adding  init  methods in extensions easier.", 
            "title": "Class"
        }, 
        {
            "location": "/fluent/getting-started/models/#conforming-to-model", 
            "text": "Now that we have our  User  class, let's conform it to  Model .  import   FluentMySQL  extension   User :   Model   {  }   Once you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make  User  conform to model.   Tip  We recommend adding  Model  conformance in an extension to help keep your code clean.", 
            "title": "Conforming to Model"
        }, 
        {
            "location": "/fluent/getting-started/models/#database", 
            "text": "The first step to conforming to  Model  is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.  import   FluentMySQL  extension   User :   Model   { \n     ...  \n\n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase  }", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/getting-started/models/#id", 
            "text": "Now we can tell Fluent what type of ID this model uses. In this example, our  User  model\nhas an ID property of type  UUID  named  id .  import   FluentMySQL  import   Foundation  extension   User :   Model   { \n     ... \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     }  }   You can use any type that conforms to  IDType  as a Fluent ID. See  Fluent   Model   ID  for more information.\nYou can also use any property name you'd like for the id.   Warning  Some databases require certain ID keys. For example, MongoDB requires  _id .", 
            "title": "ID"
        }, 
        {
            "location": "/fluent/getting-started/models/#key-field-map", 
            "text": "In order to prevent duplicate (and error-prone) strings throughout your code, Fluent models declare\na  KeyFieldMap . This maps your model's properties to their respective database fields.  import   FluentMySQL  extension   User :   Model   { \n     ... \n\n     /// See Model.keyFieldMap \n     static   var   keyFieldMap :   KeyFieldMap   { \n         return   [ \n             key ( \\ . id ):   field ( id ), \n             key ( \\ . name ):   field ( name ), \n             key ( \\ . age ):   field ( age ), \n         ] \n     }  }   Key paths are a type-safe way to declare references to your model's properties.\nYou can learn more about key paths in the Swift Evolution proposal,  SE-0161 .   Note  Unless you have a special use case, you should always \njust set the  field(...)  and  key(...)  as the same string.   To see what using these key paths looks like in action, check out  Fluent   Getting Started   Query .", 
            "title": "Key Field Map"
        }, 
        {
            "location": "/fluent/getting-started/models/#example", 
            "text": "We now have a fully-conformed Fluent model!  import   FluentMySQL  import   Foundation  final   class   User :   Codable   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }  extension   User :   Model   { \n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     } \n\n     /// See Model.keyFieldMap \n     static   var   keyFieldMap :   KeyFieldMap   { \n         return   [ \n             key ( \\ . id ):   field ( id ), \n             key ( \\ . name ):   field ( name ), \n             key ( \\ . age ):   field ( age ), \n         ] \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/getting-started/models/#done", 
            "text": "Now that you have a working Fluent model, you can move onto  querying  your model. \nHowever, if your database uses schemas, you may need to create a  migration  for your model first.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/migrations/", 
            "text": "Getting Started with Migrations\n\n\nMigrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!\n\n\nMigrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.\n\n\nIn this guide we will cover creating both types of migrations.\n\n\nModel Schema\n\n\nLet's take a look at how we can prepare a schema supporting database to accept the \n\nUser\n model from the \nprevious section\n.\n\n\nJust like we did with the \nModel\n protocol, we will conform our \nUser\n to \nMigration\n.\n\n\nimport\n \nFluent\n\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n\n\n}\n\n\n\n\n\n\nSwift will inform us that \nUser\n does not yet conform. Let's add the required methods!\n\n\nPrepare\n\n\nThe first method to implement is \nprepare\n. This method is where you make any of your \ndesired changes to the database.\n\n\nFor our \nUser\n model, we simply want to create a table that can store one or more users. To do this,\nwe will use the \n.create(...)\n function on the supplied database connection.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe pass \nself\n (shorthand for \nUser.self\n since this is a static method) as the first argument to the \n.create\n method. This indicates\nto Fluent that we would like to create a schema for the \nUser\n model.\n\n\nNext, we pass a closure that accepts a \nSchemaBuilder\n for our \nUser\n model.\nWe can then call \n.field\non this builder to describe what fields we'd like our table to have.\n\n\nSince we are passing key paths to our \nUser\n model (indicated by \n\\.\n), Fluent can see what type those properties are.\nFor most common types (\nString\n, \nInt\n, \nDouble\n, etc) Fluent will automatically be able to determine the best\ndatabase field type to use.\n\n\nYou can also choose to manually select which database field type to use for a given field.\n\n\ntry\n \nbuilder\n.\nfield\n(\ntype\n:\n \n.\ntext\n,\n \nfor\n:\n \n\\\n.\nname\n)\n\n\n\n\n\n\nLearn more about creating, updating, and deleting schemas in \nFluent \n Schema Builder\n.\n\n\nRevert\n\n\nRevert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the \n--revert\n option. See \nFluent \n Migration\n for more information.\n\n\nTo implement \nrevert\n for our model, we simply use \n.delete\n to indicate that we would like to delete the schema created for \nUser\n.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExample\n\n\nWe now have a fully functioning model with migration!\n\n\nextension\n \nTestUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model and migration, you can move onto \nquerying\n your model.", 
            "title": "Migrations"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#getting-started-with-migrations", 
            "text": "Migrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!  Migrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.  In this guide we will cover creating both types of migrations.", 
            "title": "Getting Started with Migrations"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#model-schema", 
            "text": "Let's take a look at how we can prepare a schema supporting database to accept the  User  model from the  previous section .  Just like we did with the  Model  protocol, we will conform our  User  to  Migration .  import   Fluent  extension   User :   Migration   {  }   Swift will inform us that  User  does not yet conform. Let's add the required methods!", 
            "title": "Model Schema"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#prepare", 
            "text": "The first method to implement is  prepare . This method is where you make any of your \ndesired changes to the database.  For our  User  model, we simply want to create a table that can store one or more users. To do this,\nwe will use the  .create(...)  function on the supplied database connection.  extension   User :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     }  }   We pass  self  (shorthand for  User.self  since this is a static method) as the first argument to the  .create  method. This indicates\nto Fluent that we would like to create a schema for the  User  model.  Next, we pass a closure that accepts a  SchemaBuilder  for our  User  model.\nWe can then call  .field on this builder to describe what fields we'd like our table to have.  Since we are passing key paths to our  User  model (indicated by  \\. ), Fluent can see what type those properties are.\nFor most common types ( String ,  Int ,  Double , etc) Fluent will automatically be able to determine the best\ndatabase field type to use.  You can also choose to manually select which database field type to use for a given field.  try   builder . field ( type :   . text ,   for :   \\ . name )   Learn more about creating, updating, and deleting schemas in  Fluent   Schema Builder .", 
            "title": "Prepare"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#revert", 
            "text": "Revert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the  --revert  option. See  Fluent   Migration  for more information.  To implement  revert  for our model, we simply use  .delete  to indicate that we would like to delete the schema created for  User .  extension   User :   Migration   { \n     /// See Migration.revert \n     static   func   revert ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Revert"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#example", 
            "text": "We now have a fully functioning model with migration!  extension   TestUser :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     } \n\n     /// See Migration.revert \n     static   func   revert ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/getting-started/migrations/#done", 
            "text": "Now that you have a working Fluent model and migration, you can move onto  querying  your model.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/getting-started/querying/", 
            "text": "Querying Models\n\n\nOnce you have a \nmodel\n (and optionally a \nmigration\n) you can start \nquerying your database to create, read, update, and delete data.\n\n\nConnection\n\n\nThe first thing you need to query your database, is a connection to it. Luckily, they are easy to get.\n\n\nYou can use either the application or an incoming request to create a database connection. You just need\naccess to the \nDatabaseIdentifier\n.\n\n\nRequest\n\n\nThe preferred method for getting access to a database connection is via an incoming request. \n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \nin\n\n        \n// use the db here\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first parameter is the database's \nidentifier\n. The second parameter is a closure\nthat accepts a connection to that database.\n\n\n\n\nTip\n\n\nAlthough the closure to \n.database(...)\n accepts a database \nconnection\n, we often use just \ndb\n for short.\n\n\n\n\nThe closure is expected to return a \nFuture\nVoid\n. When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.\n\n\nApplication\n\n\nYou can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.\n\n\nlet\n \nres\n \n=\n \napp\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \nin\n\n    \n// use the db here\n\n\n}\n\n\nprint\n(\nres\n)\n \n// Future\nT\n\n\n\n\n\n\nThis is usually done in the \nboot section\n of your application.\n\n\n\n\nWarning\n\n\nDo not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.\n\n\n\n\nCreate\n\n\nTo create (save) a model to the database, first initialize an instance of your model, then call \n.save(on: )\n.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\nmap\n \n{\n \nuser\n \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nResponse\n\n\n.save(on: )\n returns a \nFuture\nVoid\n that completes when the user has finished saving. In this example, we then\nmap that \nFuture\nVoid\n to a \nFuture\nUser\n by calling \n.map\n and passing in the recently-saved user. \n\n\nYou can also use \n.map\n to return a simple success response.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nResponse\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\nmap\n \n{\n \n            \nreturn\n \nResponse\n(\nstatus\n:\n \n.\ncreated\n)\n \n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMultiple\n\n\nIf you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nResponse\n \nin\n\n        \nlet\n \nmarie\n \n=\n \nUser\n(\nname\n:\n \nMarie Curie\n,\n \nage\n:\n \n66\n)\n\n        \nlet\n \ncharles\n \n=\n \nUser\n(\nname\n:\n \nCharles Darwin\n,\n \nage\n:\n \n73\n)\n\n        \nreturn\n \n[\n\n            \nmarie\n.\nsave\n(\non\n:\n \ndb\n),\n\n            \ncharles\n.\nsave\n(\non\n:\n \ndb\n)\n\n        \n].\nmap\n \n{\n\n            \nreturn\n \nResponse\n(\nstatus\n:\n \n.\ncreated\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRead\n\n\nTo read models from the database, use \n.query()\n on the database connection to create a \nQueryBuilder\n. \n\n\nAll\n\n\nFetch all instances of a model from the database using \n.all()\n.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFilter\n\n\nUse \n.filter(...)\n to apply \nfilters\n to your query.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nage\n \n \n50\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFirst\n\n\nYou can also use \n.first()\n to just get the first result.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\ndatabase\n(.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nname\n \n==\n \nVapor\n).\nfirst\n().\nmap\n \n{\n \nuser\n \nin\n\n            \nguard\n \nlet\n \nuser\n \n=\n \nuser\n \nelse\n \n{\n\n                \nthrow\n \nAbort\n(.\nnotFound\n,\n \nreason\n:\n \nCould not find user.\n)\n\n            \n}\n\n\n            \nreturn\n \nuser\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice we use \n.map()\n here to convert the optional user returned by \n.first()\n to a non-optional\nuser, or we throw an error.\n\n\nUpdate\n\n\nComing soon.\n\n\nDelete\n\n\nComing soon.", 
            "title": "Querying"
        }, 
        {
            "location": "/fluent/getting-started/querying/#querying-models", 
            "text": "Once you have a  model  (and optionally a  migration ) you can start \nquerying your database to create, read, update, and delete data.", 
            "title": "Querying Models"
        }, 
        {
            "location": "/fluent/getting-started/querying/#connection", 
            "text": "The first thing you need to query your database, is a connection to it. Luckily, they are easy to get.  You can use either the application or an incoming request to create a database connection. You just need\naccess to the  DatabaseIdentifier .", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/getting-started/querying/#request", 
            "text": "The preferred method for getting access to a database connection is via an incoming request.   router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   in \n         // use the db here \n     }  }   The first parameter is the database's  identifier . The second parameter is a closure\nthat accepts a connection to that database.   Tip  Although the closure to  .database(...)  accepts a database  connection , we often use just  db  for short.   The closure is expected to return a  Future Void . When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.", 
            "title": "Request"
        }, 
        {
            "location": "/fluent/getting-started/querying/#application", 
            "text": "You can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.  let   res   =   app . database (. foo )   {   db   in \n     // use the db here  }  print ( res )   // Future T   This is usually done in the  boot section  of your application.   Warning  Do not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.", 
            "title": "Application"
        }, 
        {
            "location": "/fluent/getting-started/querying/#create", 
            "text": "To create (save) a model to the database, first initialize an instance of your model, then call  .save(on: ) .  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future User   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). map   {   user   } \n     }  }", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/getting-started/querying/#response", 
            "text": ".save(on: )  returns a  Future Void  that completes when the user has finished saving. In this example, we then\nmap that  Future Void  to a  Future User  by calling  .map  and passing in the recently-saved user.   You can also use  .map  to return a simple success response.  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future Response   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). map   {  \n             return   Response ( status :   . created )  \n         } \n     }  }", 
            "title": "Response"
        }, 
        {
            "location": "/fluent/getting-started/querying/#multiple", 
            "text": "If you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.  router . post (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future Response   in \n         let   marie   =   User ( name :   Marie Curie ,   age :   66 ) \n         let   charles   =   User ( name :   Charles Darwin ,   age :   73 ) \n         return   [ \n             marie . save ( on :   db ), \n             charles . save ( on :   db ) \n         ]. map   { \n             return   Response ( status :   . created ) \n         } \n     }  }", 
            "title": "Multiple"
        }, 
        {
            "location": "/fluent/getting-started/querying/#read", 
            "text": "To read models from the database, use  .query()  on the database connection to create a  QueryBuilder .", 
            "title": "Read"
        }, 
        {
            "location": "/fluent/getting-started/querying/#all", 
            "text": "Fetch all instances of a model from the database using  .all() .  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future [ User ]   in \n         return   db . query ( User . self ). all () \n     }  }", 
            "title": "All"
        }, 
        {
            "location": "/fluent/getting-started/querying/#filter", 
            "text": "Use  .filter(...)  to apply  filters  to your query.  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future [ User ]   in \n         return   try   db . query ( User . self ). filter ( \\ User . age     50 ). all () \n     }  }", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/getting-started/querying/#first", 
            "text": "You can also use  .first()  to just get the first result.  router . get (...)   {   req   in \n     return   req . database (. foo )   {   db   -   Future User   in \n         return   try   db . query ( User . self ). filter ( \\ User . name   ==   Vapor ). first (). map   {   user   in \n             guard   let   user   =   user   else   { \n                 throw   Abort (. notFound ,   reason :   Could not find user. ) \n             } \n\n             return   user \n         } \n     }  }   Notice we use  .map()  here to convert the optional user returned by  .first()  to a non-optional\nuser, or we throw an error.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/getting-started/querying/#update", 
            "text": "Coming soon.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/getting-started/querying/#delete", 
            "text": "Coming soon.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/database/", 
            "text": "Fluent Database\n\n\nComing soon.\n\n\nConnection\n\n\nComing soon.\n\n\nLogger\n\n\nComing soon.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/database/#fluent-database", 
            "text": "Coming soon.", 
            "title": "Fluent Database"
        }, 
        {
            "location": "/fluent/database/#connection", 
            "text": "Coming soon.", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/database/#logger", 
            "text": "Coming soon.", 
            "title": "Logger"
        }, 
        {
            "location": "/fluent/model/", 
            "text": "Fluent Model\n\n\nComing soon.", 
            "title": "Model"
        }, 
        {
            "location": "/fluent/model/#fluent-model", 
            "text": "Coming soon.", 
            "title": "Fluent Model"
        }, 
        {
            "location": "/fluent/query-builder/", 
            "text": "Fluent Query Builder\n\n\nComing soon.\n\n\nFilter\n\n\nComing soon.\n\n\nCompare\n\n\nComing soon.\n\n\nGroup\n\n\nComing soon.\n\n\nSubset\n\n\nComing soon.\n\n\nJoin\n\n\nComing soon.\n\n\nRange\n\n\nComing soon.\n\n\nSort\n\n\nComing soon.\n\n\nExecute\n\n\nComing soon.\n\n\nAggregate\n\n\nComing soon.\n\n\nAll\n\n\nComing soon.\n\n\nFirst\n\n\nComing soon.\n\n\nQuery\n\n\nComing soon.", 
            "title": "Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#fluent-query-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#filter", 
            "text": "Coming soon.", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/query-builder/#compare", 
            "text": "Coming soon.", 
            "title": "Compare"
        }, 
        {
            "location": "/fluent/query-builder/#group", 
            "text": "Coming soon.", 
            "title": "Group"
        }, 
        {
            "location": "/fluent/query-builder/#subset", 
            "text": "Coming soon.", 
            "title": "Subset"
        }, 
        {
            "location": "/fluent/query-builder/#join", 
            "text": "Coming soon.", 
            "title": "Join"
        }, 
        {
            "location": "/fluent/query-builder/#range", 
            "text": "Coming soon.", 
            "title": "Range"
        }, 
        {
            "location": "/fluent/query-builder/#sort", 
            "text": "Coming soon.", 
            "title": "Sort"
        }, 
        {
            "location": "/fluent/query-builder/#execute", 
            "text": "Coming soon.", 
            "title": "Execute"
        }, 
        {
            "location": "/fluent/query-builder/#aggregate", 
            "text": "Coming soon.", 
            "title": "Aggregate"
        }, 
        {
            "location": "/fluent/query-builder/#all", 
            "text": "Coming soon.", 
            "title": "All"
        }, 
        {
            "location": "/fluent/query-builder/#first", 
            "text": "Coming soon.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/query-builder/#query", 
            "text": "Coming soon.", 
            "title": "Query"
        }, 
        {
            "location": "/fluent/migration/", 
            "text": "Fluent Migration\n\n\nComing soon.\n\n\nProtocol\n\n\nComing soon.\n\n\nConfig\n\n\nComing soon.", 
            "title": "Migration"
        }, 
        {
            "location": "/fluent/migration/#fluent-migration", 
            "text": "Coming soon.", 
            "title": "Fluent Migration"
        }, 
        {
            "location": "/fluent/migration/#protocol", 
            "text": "Coming soon.", 
            "title": "Protocol"
        }, 
        {
            "location": "/fluent/migration/#config", 
            "text": "Coming soon.", 
            "title": "Config"
        }, 
        {
            "location": "/fluent/schema-builder/", 
            "text": "Fluent Schema Builder\n\n\nComing soon.\n\n\nCreate\n\n\nComing soon.\n\n\nUpdate\n\n\nComing soon.\n\n\nDelete\n\n\nComing soon.\n\n\nReferences\n\n\nComing soon.", 
            "title": "Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#fluent-schema-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#create", 
            "text": "Coming soon.", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/schema-builder/#update", 
            "text": "Coming soon.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/schema-builder/#delete", 
            "text": "Coming soon.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/schema-builder/#references", 
            "text": "Coming soon.", 
            "title": "References"
        }, 
        {
            "location": "/fluent/relations/", 
            "text": "Fluent Relations\n\n\nComing soon.\n\n\nParent / Child\n\n\nComing soon.\n\n\nSiblings\n\n\nComing soon.", 
            "title": "Relations"
        }, 
        {
            "location": "/fluent/relations/#fluent-relations", 
            "text": "Coming soon.", 
            "title": "Fluent Relations"
        }, 
        {
            "location": "/fluent/relations/#parent-child", 
            "text": "Coming soon.", 
            "title": "Parent / Child"
        }, 
        {
            "location": "/fluent/relations/#siblings", 
            "text": "Coming soon.", 
            "title": "Siblings"
        }, 
        {
            "location": "/fluent/pivot/", 
            "text": "Fluent Pivot\n\n\nComing soon.", 
            "title": "Pivot"
        }, 
        {
            "location": "/fluent/pivot/#fluent-pivot", 
            "text": "Coming soon.", 
            "title": "Fluent Pivot"
        }, 
        {
            "location": "/fluent/transaction/", 
            "text": "Fluent Transactions\n\n\nComing soon.", 
            "title": "Transaction"
        }, 
        {
            "location": "/fluent/transaction/#fluent-transactions", 
            "text": "Coming soon.", 
            "title": "Fluent Transactions"
        }, 
        {
            "location": "/databases/sqlite/package/", 
            "text": "Using SQLite\n\n\nThe \nvapor/sqlite\n package is a lightweight, nonblocking/async wrapper around SQLite 3's C API. It provides an intuitive Swift interface for working with SQLite that can be used with any Swift project.\n\n\nOn top of \nvapor/sqlite\n, we have built \nvapor/fluent-sqlite\n which allows SQLite databases to be used with Fluent.\n\n\nWith Fluent\n\n\nSQLite works great with Fluent, you just need to make sure to add the \nvapor/fluent-sqlite\n\npackage to your project.\n\n\nTo do this, add the Fluent SQLite package to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/fluent-sqlite.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nFluentSQLite\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport FluentSQLite\n to access SQLite's Fluent compatible APIs.\n\n\nJust SQLite\n\n\nThis package was built to be a powerful interface for SQLite whether or not you use Fluent. To include this SQLite package in your project, simply add it to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/sqlite.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nSQLite\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport SQLite\n to access the Swift SQLite APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/databases/sqlite/package/#using-sqlite", 
            "text": "The  vapor/sqlite  package is a lightweight, nonblocking/async wrapper around SQLite 3's C API. It provides an intuitive Swift interface for working with SQLite that can be used with any Swift project.  On top of  vapor/sqlite , we have built  vapor/fluent-sqlite  which allows SQLite databases to be used with Fluent.", 
            "title": "Using SQLite"
        }, 
        {
            "location": "/databases/sqlite/package/#with-fluent", 
            "text": "SQLite works great with Fluent, you just need to make sure to add the  vapor/fluent-sqlite \npackage to your project.  To do this, add the Fluent SQLite package to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/fluent-sqlite.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ FluentSQLite ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import FluentSQLite  to access SQLite's Fluent compatible APIs.", 
            "title": "With Fluent"
        }, 
        {
            "location": "/databases/sqlite/package/#just-sqlite", 
            "text": "This package was built to be a powerful interface for SQLite whether or not you use Fluent. To include this SQLite package in your project, simply add it to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/sqlite.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ SQLite ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import SQLite  to access the Swift SQLite APIs.", 
            "title": "Just SQLite"
        }, 
        {
            "location": "/databases/sqlite/overview/", 
            "text": "SQLite Overview\n\n\nLet's dive into the \nvapor/sqlite\n package and\nsee how to connect to and query a database.\n\n\n\n\nWarning\n\n\nThis documentation provides an overview for the SQLite API.\nIf you are using SQLite with Fluent, you will likely never need to use\nthis API. Use \nFluent's APIs\n instead.\n\n\n\n\nFollow the instructions in the \npackage\n section to add the SQLite package to your project. Once its added, you should be able to use \nimport SQLite.\n\n\nDatabase\n\n\nThe first step to making a query is to create a \nDatabase\n.\n\n\nIn Memory\n\n\nIn-memory SQLite databases are great for testing as they aren't persisted between application boots.\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\n\n\n\n\nFile path\n\n\nSQLite requires a single file to persist the database contents.\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nfile\n(\npath\n:\n \n/tmp/db.sqlite\n))\n\n\n\n\n\n\n\n\nTip\n\n\nIf the database file does not already exist, it will be created.\n\n\n\n\nConnection\n\n\nOnce you have initialized your database, you can create a connection.\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n\n\n\n\n\n\n\n\nNote\n\n\nPay special attention to which \nDispatchQueue\n you pass to \nmakeConnection(on:)\n.\nThis will be the queue SQLite calls you back on.\n\n\n\n\n\n\nTip\n\n\nIf you are using SQLite with Vapor, make sure to pass the \nworker\n's queue here.\n\n\n\n\nQuery\n\n\nOnce you have a \nConnection\n, you can use it to create a \nQuery\n.\n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nSELECT * FROM users\n)\n\n\n\n\n\n\nBinding Values\n\n\nIf you are executing a query that has input values, you should bind these using parameters.\n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n\nquery\n.\nbind\n(\nAlbert\n)\n\n\nquery\n.\nbind\n(\n138\n)\n\n\n\n\n\n\nYou can also bind values using method chaining.\n\n\nlet\n \nquery\n \n=\n \nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n    \n.\nbind\n(\nAlbert\n)\n\n    \n.\nbind\n(\n138\n)\n\n\n\n\n\n\nOutput Stream\n\n\nIf you expect output from your query, you must attach a stream. The easiest way\nto do this is by using the \ndrain\n convenience.\n\n\nquery\n.\ndrain\n \n{\n \nrow\n \nin\n\n    \nprint\n(\nrow\n)\n\n\n}\n\n\n\n\n\n\nYou can also use \ndrain(into:)\n and pass in a custom \nInputStream\n to capture the query's results.\n\n\nRow\n\n\nThe \nQuery\n will output \nRow\ns. These are simple structs.\n\n\nstruct\n \nRow\n \n{\n\n    \nvar\n \nfields\n:\n \n[\nString\n:\n \nField\n]\n\n    \nsubscript\n(\nfield\n:\n \nString\n)\n \n-\n \nData\n?\n \n{\n \nget\n \n}\n\n\n}\n\n\n\n\n\n\nYou can subscript a \nRow\n object to get the optional \nData\n.\n\n\nlet\n \nnameData\n \n=\n \nrow\n[\nname\n]\n \n// Data?\n\n\n\n\n\n\nData\n is an enum that contains all possible types of SQLite data.\n\n\npublic\n \nenum\n \nData\n \n{\n\n    \ncase\n \ninteger\n(\nInt\n)\n\n    \ncase\n \nfloat\n(\nDouble\n)\n\n    \ncase\n \ntext\n(\nString\n)\n\n    \ncase\n \nblob\n(\nFoundation\n.\nData\n)\n\n    \ncase\n \nnull\n\n\n}\n\n\n\n\n\n\nFor each option, there are convenience properties for casting the \nData\n enum.\n\n\nlet\n \nname\n \n=\n \nrow\n[\nname\n]?.\ntext\n \n// String\n\n\n\n\n\n\nRun\n\n\nOnce your query is ready to execute, you simply call \n.execute()\n. This returns a \nFuture\nVoid\n\nthat will be completed when the query is done executing.\n\n\nquery\n.\nexecute\n().\nthen\n \n{\n\n    \nprint\n(\ndone!\n)\n\n\n}\n\n\n\n\n\n\nAll\n\n\nIf you simply want to fetch all of the results, you can use the \n.all()\n convenience.\nThis will automatically create a stream and return a future containing your results.\n\n\nquery\n.\nall\n().\nthen\n \n{\n \nrows\n \nin\n\n    \nprint\n(\nrows\n)\n\n\n}\n\n\n\n\n\n\nSync\n\n\nFor situations where blocking is appropriate (perhaps in tests) you can use \n.sync()\n to block\nuntil the query's results are ready and return them directly.\n\n\n// don\nt do this unless blocking is OK\n\n\nlet\n \nrows\n \n=\n \ntry\n \nconn\n.\nquery\n(\nSELECT * FROM users\n).\nsync\n()\n\n\n\n\n\n\nExample\n\n\nNow for the complete example:\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n \n// take care to use correct queue\n\n\nconn\n.\nquery\n(\nSELECT * FROM users\n)\n\n    \n.\nall\n()\n\n    \n.\nthen\n \n{\n \nrows\n \nin\n\n        \nprint\n(\nrows\n)\n\n    \n}\n\n    \n.\ncatch\n \n{\n \nerr\n \nin\n\n        \nprint\n(\nerr\n)\n\n    \n}\n\n\n\n// wait for results\n\n\n\n\n\n\nAn example with values being bound:\n\n\nimport\n \nSQLite\n\n\n\nlet\n \ndb\n \n=\n \nDatabase\n(\nstorage\n:\n \n.\nmemory\n)\n\n\nlet\n \nconn\n \n=\n \ntry\n \ndb\n.\nmakeConnection\n(\non\n:\n \n.\nglobal\n())\n \n// take care to use correct queue\n\n\nconn\n.\nquery\n(\nINSERT INTO users (name, age) VALUES (?, ?)\n)\n\n    \n.\nbind\n(\nAlbert\n)\n\n    \n.\nbind\n(\n138\n)\n\n    \n.\nexecute\n()\n\n    \n.\nthen\n \n{\n\n        \nprint\n(\ndone\n)\n\n    \n}\n\n    \n.\ncatch\n \n{\n \nerr\n \nin\n\n        \nprint\n(\nerr\n)\n\n    \n}\n\n\n\n// wait for results", 
            "title": "Overview"
        }, 
        {
            "location": "/databases/sqlite/overview/#sqlite-overview", 
            "text": "Let's dive into the  vapor/sqlite  package and\nsee how to connect to and query a database.   Warning  This documentation provides an overview for the SQLite API.\nIf you are using SQLite with Fluent, you will likely never need to use\nthis API. Use  Fluent's APIs  instead.   Follow the instructions in the  package  section to add the SQLite package to your project. Once its added, you should be able to use  import SQLite.", 
            "title": "SQLite Overview"
        }, 
        {
            "location": "/databases/sqlite/overview/#database", 
            "text": "The first step to making a query is to create a  Database .", 
            "title": "Database"
        }, 
        {
            "location": "/databases/sqlite/overview/#in-memory", 
            "text": "In-memory SQLite databases are great for testing as they aren't persisted between application boots.  import   SQLite  let   db   =   Database ( storage :   . memory )", 
            "title": "In Memory"
        }, 
        {
            "location": "/databases/sqlite/overview/#file-path", 
            "text": "SQLite requires a single file to persist the database contents.  import   SQLite  let   db   =   Database ( storage :   . file ( path :   /tmp/db.sqlite ))    Tip  If the database file does not already exist, it will be created.", 
            "title": "File path"
        }, 
        {
            "location": "/databases/sqlite/overview/#connection", 
            "text": "Once you have initialized your database, you can create a connection.  let   conn   =   try   db . makeConnection ( on :   . global ())    Note  Pay special attention to which  DispatchQueue  you pass to  makeConnection(on:) .\nThis will be the queue SQLite calls you back on.    Tip  If you are using SQLite with Vapor, make sure to pass the  worker 's queue here.", 
            "title": "Connection"
        }, 
        {
            "location": "/databases/sqlite/overview/#query", 
            "text": "Once you have a  Connection , you can use it to create a  Query .  let   query   =   conn . query ( SELECT * FROM users )", 
            "title": "Query"
        }, 
        {
            "location": "/databases/sqlite/overview/#binding-values", 
            "text": "If you are executing a query that has input values, you should bind these using parameters.  let   query   =   conn . query ( INSERT INTO users (name, age) VALUES (?, ?) )  query . bind ( Albert )  query . bind ( 138 )   You can also bind values using method chaining.  let   query   =   conn . query ( INSERT INTO users (name, age) VALUES (?, ?) ) \n     . bind ( Albert ) \n     . bind ( 138 )", 
            "title": "Binding Values"
        }, 
        {
            "location": "/databases/sqlite/overview/#output-stream", 
            "text": "If you expect output from your query, you must attach a stream. The easiest way\nto do this is by using the  drain  convenience.  query . drain   {   row   in \n     print ( row )  }   You can also use  drain(into:)  and pass in a custom  InputStream  to capture the query's results.", 
            "title": "Output Stream"
        }, 
        {
            "location": "/databases/sqlite/overview/#row", 
            "text": "The  Query  will output  Row s. These are simple structs.  struct   Row   { \n     var   fields :   [ String :   Field ] \n     subscript ( field :   String )   -   Data ?   {   get   }  }   You can subscript a  Row  object to get the optional  Data .  let   nameData   =   row [ name ]   // Data?   Data  is an enum that contains all possible types of SQLite data.  public   enum   Data   { \n     case   integer ( Int ) \n     case   float ( Double ) \n     case   text ( String ) \n     case   blob ( Foundation . Data ) \n     case   null  }   For each option, there are convenience properties for casting the  Data  enum.  let   name   =   row [ name ]?. text   // String", 
            "title": "Row"
        }, 
        {
            "location": "/databases/sqlite/overview/#run", 
            "text": "Once your query is ready to execute, you simply call  .execute() . This returns a  Future Void \nthat will be completed when the query is done executing.  query . execute (). then   { \n     print ( done! )  }", 
            "title": "Run"
        }, 
        {
            "location": "/databases/sqlite/overview/#all", 
            "text": "If you simply want to fetch all of the results, you can use the  .all()  convenience.\nThis will automatically create a stream and return a future containing your results.  query . all (). then   {   rows   in \n     print ( rows )  }", 
            "title": "All"
        }, 
        {
            "location": "/databases/sqlite/overview/#sync", 
            "text": "For situations where blocking is appropriate (perhaps in tests) you can use  .sync()  to block\nuntil the query's results are ready and return them directly.  // don t do this unless blocking is OK  let   rows   =   try   conn . query ( SELECT * FROM users ). sync ()", 
            "title": "Sync"
        }, 
        {
            "location": "/databases/sqlite/overview/#example", 
            "text": "Now for the complete example:  import   SQLite  let   db   =   Database ( storage :   . memory )  let   conn   =   try   db . makeConnection ( on :   . global ())   // take care to use correct queue  conn . query ( SELECT * FROM users ) \n     . all () \n     . then   {   rows   in \n         print ( rows ) \n     } \n     . catch   {   err   in \n         print ( err ) \n     }  // wait for results   An example with values being bound:  import   SQLite  let   db   =   Database ( storage :   . memory )  let   conn   =   try   db . makeConnection ( on :   . global ())   // take care to use correct queue  conn . query ( INSERT INTO users (name, age) VALUES (?, ?) ) \n     . bind ( Albert ) \n     . bind ( 138 ) \n     . execute () \n     . then   { \n         print ( done ) \n     } \n     . catch   {   err   in \n         print ( err ) \n     }  // wait for results", 
            "title": "Example"
        }, 
        {
            "location": "/databases/mysql/package/", 
            "text": "Using MySQL\n\n\nThe \nvapor/mysql\n package is a lightweight, async pure swift MySQL/MariaDB driver. It provides an intuitive Swift interface for working with MySQL that can be used with any Swift project.\n\n\n\n\n\n\n\n\nJust MySQL\n\n\nThis package was built to be a powerful interface for MySQL. To include this MySQL package in your project, simply add it to your Package manifest.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/mysql.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nMySQL\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport SQLite\n to access the Swift SQLite APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/databases/mysql/package/#using-mysql", 
            "text": "The  vapor/mysql  package is a lightweight, async pure swift MySQL/MariaDB driver. It provides an intuitive Swift interface for working with MySQL that can be used with any Swift project.", 
            "title": "Using MySQL"
        }, 
        {
            "location": "/databases/mysql/package/#just-mysql", 
            "text": "This package was built to be a powerful interface for MySQL. To include this MySQL package in your project, simply add it to your Package manifest.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/mysql.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ MySQL ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import SQLite  to access the Swift SQLite APIs.", 
            "title": "Just MySQL"
        }, 
        {
            "location": "/databases/mysql/setup/", 
            "text": "MySQL Setup\n\n\nThis page guides you through installing and connecting to MySQL or MariaDB.\n\n\nInstallation\n\n\nFirst, you need to install MySQL on your server or test environment.\n\n\nUbuntu\n\n\nUbuntu has a thorough guide \nhere\n outlining both basic installation, configuration as well as advanced configurations.\n\n\nmacOS\n\n\nAssuming you've installed \nhomebrew\n you can use the following command to set up MySQL.\n\n\nbrew install mysql\n\n\n\n\n\nAny issues and further configuration will be explained in the terminal on completion of the installation.\n\n\nConnecting\n\n\nThe MySQL driver works with an automatically managed connection pool.\n\n\nThe following code creates a new connectionpool to \nlocalhost\n and the default MySQL port. The user that's being authenticated with is \nroot\n and the password is \nnil\n for \"no password\". If you do set a password, even if it's empty \n\"\"\n it will be treated differently. Users without a password must specify \nnil\n and must not specify \n\"\"\n.\n\n\nThe database is the database that is selected and authenticated to. Any future queries will be sent to this database.\n\n\nThe \nworker\n is defined in \nthe async documentation\n.\n\n\nlet\n \nconnectionPool\n \n=\n \nConnectionPool\n(\nhostname\n:\n \nlocalhost\n,\n \nuser\n:\n \nroot\n,\n \npassword\n:\n \nnil\n,\n \ndatabase\n:\n \ntest-db\n,\n \nworker\n:\n \nworker\n)\n\n\n\n\n\n\nYou can set the maximum amount of connections after creating the \nConnectionPool\n.\n\n\nconnectionPool\n.\nmaxConnections\n \n=\n \n50\n\n\n\n\n\n\nCreating a connection pool successfully does not imply that the configuration is correct. The (first) query's success or failure will indicate the successful or unsuccessful connection. This way the API stays much simpler than it would otherwise be.\n\n\nLearn how you can execute queries here", 
            "title": "Setup"
        }, 
        {
            "location": "/databases/mysql/setup/#mysql-setup", 
            "text": "This page guides you through installing and connecting to MySQL or MariaDB.", 
            "title": "MySQL Setup"
        }, 
        {
            "location": "/databases/mysql/setup/#installation", 
            "text": "First, you need to install MySQL on your server or test environment.", 
            "title": "Installation"
        }, 
        {
            "location": "/databases/mysql/setup/#ubuntu", 
            "text": "Ubuntu has a thorough guide  here  outlining both basic installation, configuration as well as advanced configurations.", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/databases/mysql/setup/#macos", 
            "text": "Assuming you've installed  homebrew  you can use the following command to set up MySQL.  brew install mysql  Any issues and further configuration will be explained in the terminal on completion of the installation.", 
            "title": "macOS"
        }, 
        {
            "location": "/databases/mysql/setup/#connecting", 
            "text": "The MySQL driver works with an automatically managed connection pool.  The following code creates a new connectionpool to  localhost  and the default MySQL port. The user that's being authenticated with is  root  and the password is  nil  for \"no password\". If you do set a password, even if it's empty  \"\"  it will be treated differently. Users without a password must specify  nil  and must not specify  \"\" .  The database is the database that is selected and authenticated to. Any future queries will be sent to this database.  The  worker  is defined in  the async documentation .  let   connectionPool   =   ConnectionPool ( hostname :   localhost ,   user :   root ,   password :   nil ,   database :   test-db ,   worker :   worker )   You can set the maximum amount of connections after creating the  ConnectionPool .  connectionPool . maxConnections   =   50   Creating a connection pool successfully does not imply that the configuration is correct. The (first) query's success or failure will indicate the successful or unsuccessful connection. This way the API stays much simpler than it would otherwise be.  Learn how you can execute queries here", 
            "title": "Connecting"
        }, 
        {
            "location": "/databases/mysql/basics/", 
            "text": "MySQL Basics\n\n\nThis guide assumes you've set up MySQL and are connected to MySQL using a connection pool as described in \nthe setup guide\n.\n\n\nType safety\n\n\nThe MySQL driver is written to embrace type-safety and Codable. We currently \nonly\n expose Codable based results until we've found a good design for the non-codable API.\n\n\nRetaining a connection\n\n\nBefore you can send queries, you first need to retain a connection from the pool.\n\n\nYou are \nrequired\n to return a \nFuture\n from within the closure. This closure's completion will be used to determine when the connection can be released back into the pool for the next request.\n\n\n// The result from within the closure\n\n\n\n// Future\nResponse\n\n\nlet\n \nresult\n \n=\n \npool\n.\nretain\n \n{\n \nconnection\n \nin\n\n  \n// query the connection\n\n\n  \nreturn\n \nFuture\n(\nResponse\n(\nstatus\n:\n \n.\nok\n))\n\n\n}\n\n\n\n\n\n\nThe future returned from the retain call will be equal to the future returned within the retain call.\n\n\nThis way you can return the connection back into the pool after one or more successive operations and return the (final) result.\n\n\nQueries\n\n\nQueries are any type conforming to the protocol \nQuery\n, which requires being convertible to a \nString\n.\n\nString\n is a Query by default.\n\n\nYou can receive results from Queries in 4 kinds of formats.\n\n\n\n\nStream\n\n\nFuture\n\n\nforEach\n\n\nFuture\n\n\n\n\nAll examples assume the following model:\n\n\nstruct\n \nUser\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \npasswordHash\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nFutures\n\n\nFutures are often easier to use but significantly heavier on your memory and thus performance. \nThey are thoroughly described here\n\n\nQuerying a database for a future is achieved through the \nall\n function and requires specifying the \nDecodable\n type that the results need to be deserialized into.\n\n\n \n// Future\n[User]\n\n\nlet\n \nusers\n \n=\n \nconnection\n.\nall\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n\n\n\n\n\n\nFor partial results (\nSELECT username, age FROM\n) it is recommended to create a second decodable struct specifically for this query to ensure correctness and type-safety.\n\n\nstruct\n \nUserLoginDetails\n:\n \nDecodable\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n  \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nStreams\n\n\nStreams, \nas described on this page\n, are a source of information that calls a single reader's callback. Streams are best used in larger datasets to prevent the query from consuming a large amount of memory. The downside of a stream is that you cannot return all results in a single future. You'll need to stream the results to the other endpoint, too. For HTTP \nthis is described here.\n\n\nQuerying a database for a stream of results is achieved through the \nstream\n function and requires specifying the \nDecodable\n type that the results need to be deserialized into.\n\n\n \n// `ModelStream\nUser\n`\n\n\nlet\n \nusersStream\n \n=\n \nconnection\n.\nstream\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n\n\n\n\n\n\nThis stream will return all results in the ModelStream's output callback which you can drain. You can register a callback on \nusersStream.onClose\n that will trigger when the end of the \nModelStream\n has been reached.\n\n\nForEach\n\n\nIf you don't need to stream complex results to a third party such as using an HTTP Response you can use \nforEach\n. This is particularly useful for asynchronous actions such as sending a lot of email to the results of a query without depending on the completion/success of one email for the next email.\n\n\nconnection\n.\nforEach\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n}\n\n\n\n\n\n\nforEach\n returns a future that you can optionally capture. It will be completed when all users have been processed.\n\n\nlet\n \ncompleted\n \n=\n \nconnection\n.\nforEach\n(\nUser\n.\nself\n,\n \nin\n:\n \nSELECT * FROM users\n)\n \n{\n \nuser\n \nin\n\n  \nprint\n(\nuser\n.\nusername\n)\n\n\n}\n\n\n\ncompleted\n.\nthen\n \n{\n\n  \nprint\n(\nAll users printed\n)\n\n\n}\n\n\n\n\n\n\nResultless queries\n\n\nSome queries (mostly administrative queries) do not require/return a response. Instead, they only indicate success or error.\n\n\nYou can execute these queries using the \nadministrativeQuery\n command.\n\n\nconnection\n.\nadministrativeQuery\n(\nDROP TABLE users\n)\n\n\n\n\n\n\nYou can handle success or response using the returned future.\n\n\nconnection\n.\nadministrativeQuery\n(\nDROP TABLE users\n).\nthen\n \n{\n\n  \nprint\n(\nsuccess\n)\n\n\n}.\ncatch\n \n{\n\n  \nprint\n(\nfailure\n)\n\n\n}", 
            "title": "Basics"
        }, 
        {
            "location": "/databases/mysql/basics/#mysql-basics", 
            "text": "This guide assumes you've set up MySQL and are connected to MySQL using a connection pool as described in  the setup guide .", 
            "title": "MySQL Basics"
        }, 
        {
            "location": "/databases/mysql/basics/#type-safety", 
            "text": "The MySQL driver is written to embrace type-safety and Codable. We currently  only  expose Codable based results until we've found a good design for the non-codable API.", 
            "title": "Type safety"
        }, 
        {
            "location": "/databases/mysql/basics/#retaining-a-connection", 
            "text": "Before you can send queries, you first need to retain a connection from the pool.  You are  required  to return a  Future  from within the closure. This closure's completion will be used to determine when the connection can be released back into the pool for the next request.  // The result from within the closure  // Future Response  let   result   =   pool . retain   {   connection   in \n   // query the connection \n\n   return   Future ( Response ( status :   . ok ))  }   The future returned from the retain call will be equal to the future returned within the retain call.  This way you can return the connection back into the pool after one or more successive operations and return the (final) result.", 
            "title": "Retaining a connection"
        }, 
        {
            "location": "/databases/mysql/basics/#queries", 
            "text": "Queries are any type conforming to the protocol  Query , which requires being convertible to a  String . String  is a Query by default.  You can receive results from Queries in 4 kinds of formats.   Stream  Future  forEach  Future   All examples assume the following model:  struct   User   { \n   var   username :   String \n   var   passwordHash :   String \n   var   age :   Int  }", 
            "title": "Queries"
        }, 
        {
            "location": "/databases/mysql/basics/#futures", 
            "text": "Futures are often easier to use but significantly heavier on your memory and thus performance.  They are thoroughly described here  Querying a database for a future is achieved through the  all  function and requires specifying the  Decodable  type that the results need to be deserialized into.    // Future [User]  let   users   =   connection . all ( User . self ,   in :   SELECT * FROM users )   For partial results ( SELECT username, age FROM ) it is recommended to create a second decodable struct specifically for this query to ensure correctness and type-safety.  struct   UserLoginDetails :   Decodable   { \n   var   username :   String \n   var   age :   Int  }", 
            "title": "Futures"
        }, 
        {
            "location": "/databases/mysql/basics/#streams", 
            "text": "Streams,  as described on this page , are a source of information that calls a single reader's callback. Streams are best used in larger datasets to prevent the query from consuming a large amount of memory. The downside of a stream is that you cannot return all results in a single future. You'll need to stream the results to the other endpoint, too. For HTTP  this is described here.  Querying a database for a stream of results is achieved through the  stream  function and requires specifying the  Decodable  type that the results need to be deserialized into.    // `ModelStream User `  let   usersStream   =   connection . stream ( User . self ,   in :   SELECT * FROM users )   This stream will return all results in the ModelStream's output callback which you can drain. You can register a callback on  usersStream.onClose  that will trigger when the end of the  ModelStream  has been reached.", 
            "title": "Streams"
        }, 
        {
            "location": "/databases/mysql/basics/#foreach", 
            "text": "If you don't need to stream complex results to a third party such as using an HTTP Response you can use  forEach . This is particularly useful for asynchronous actions such as sending a lot of email to the results of a query without depending on the completion/success of one email for the next email.  connection . forEach ( User . self ,   in :   SELECT * FROM users )   {   user   in \n   print ( user . username )  }   forEach  returns a future that you can optionally capture. It will be completed when all users have been processed.  let   completed   =   connection . forEach ( User . self ,   in :   SELECT * FROM users )   {   user   in \n   print ( user . username )  }  completed . then   { \n   print ( All users printed )  }", 
            "title": "ForEach"
        }, 
        {
            "location": "/databases/mysql/basics/#resultless-queries", 
            "text": "Some queries (mostly administrative queries) do not require/return a response. Instead, they only indicate success or error.  You can execute these queries using the  administrativeQuery  command.  connection . administrativeQuery ( DROP TABLE users )   You can handle success or response using the returned future.  connection . administrativeQuery ( DROP TABLE users ). then   { \n   print ( success )  }. catch   { \n   print ( failure )  }", 
            "title": "Resultless queries"
        }, 
        {
            "location": "/databases/mysql/prepared-statements/", 
            "text": "Prepared statements\n\n\nPreparing statements is important in many SQL operations to prevent SQL injection.\n\n\nYou first have to set up your query to make use of statement binding.\n\n\nTo design your query for preparation you must replace all user inputted values with a \n?\n such as the following statement:\n\n\nSELECT\n \n*\n \nFROM\n \nusers\n \nWHERE\n \nusername\n \n=\n \n?\n\n\n\n\n\n\nPreparing a statement\n\n\nTo prepare a statement from a query you call the \nwithPreparation\n function on \nConnection\n.\n\n\ntry\n \nconnection\n.\nwithPreparation\n(\nstatement\n:\n \nSELECT * FROM users WHERE username = ?\n)\n \n{\n \nstatement\n \nin\n\n  \n// Bind\n\n\n}\n\n\n\n\n\n\nBinding to a statement\n\n\nThe statement can be bound by calling the \nbind\n function on \nstatement\n. This will provide you with a temporary binding context.\n\n\ntry\n \nstatement\n.\nbind\n \n{\n \nbinding\n \nin\n\n  \ntry\n \nbinding\n.\nbind\n(\nExampleUser\n)\n\n\n}\n\n\n\n\n\n\nBindings will throw an error if the inputted value did not meet the query's required type.\n\n\nReading the query's results\n\n\nYou can then use the \nFuture or Streaming query functions as described in the basics\n to receive the queried results from the prepared and bound \nstatement\n object.", 
            "title": "Prepared Statements"
        }, 
        {
            "location": "/databases/mysql/prepared-statements/#prepared-statements", 
            "text": "Preparing statements is important in many SQL operations to prevent SQL injection.  You first have to set up your query to make use of statement binding.  To design your query for preparation you must replace all user inputted values with a  ?  such as the following statement:  SELECT   *   FROM   users   WHERE   username   =   ?", 
            "title": "Prepared statements"
        }, 
        {
            "location": "/databases/mysql/prepared-statements/#preparing-a-statement", 
            "text": "To prepare a statement from a query you call the  withPreparation  function on  Connection .  try   connection . withPreparation ( statement :   SELECT * FROM users WHERE username = ? )   {   statement   in \n   // Bind  }", 
            "title": "Preparing a statement"
        }, 
        {
            "location": "/databases/mysql/prepared-statements/#binding-to-a-statement", 
            "text": "The statement can be bound by calling the  bind  function on  statement . This will provide you with a temporary binding context.  try   statement . bind   {   binding   in \n   try   binding . bind ( ExampleUser )  }   Bindings will throw an error if the inputted value did not meet the query's required type.", 
            "title": "Binding to a statement"
        }, 
        {
            "location": "/databases/mysql/prepared-statements/#reading-the-querys-results", 
            "text": "You can then use the  Future or Streaming query functions as described in the basics  to receive the queried results from the prepared and bound  statement  object.", 
            "title": "Reading the query's results"
        }, 
        {
            "location": "/databases/postgres/package/", 
            "text": "", 
            "title": "Package"
        }, 
        {
            "location": "/databases/postgres/setup/", 
            "text": "", 
            "title": "Setup"
        }, 
        {
            "location": "/databases/postgres/basics/", 
            "text": "", 
            "title": "Basics"
        }, 
        {
            "location": "/redis/package/", 
            "text": "Redis\n\n\nRedis is a Redis client library that can communicate with a Redis database.\n\n\nWhat is Redis?\n\n\nRedis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).\n\n\nRedis works as a key-value store, but allows querying the keys, unlike most databases.\n\n\nIndex\n\n\n\n\nBasics\n\n\nCustom commands\n\n\nPub/Sub\n\n\nPub/Sub\n\n\n\n\nWith and without Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/redis.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nRedis\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport Redis\n to access Redis' APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/redis/package/#redis", 
            "text": "Redis is a Redis client library that can communicate with a Redis database.", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/package/#what-is-redis", 
            "text": "Redis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).  Redis works as a key-value store, but allows querying the keys, unlike most databases.", 
            "title": "What is Redis?"
        }, 
        {
            "location": "/redis/package/#index", 
            "text": "Basics  Custom commands  Pub/Sub  Pub/Sub", 
            "title": "Index"
        }, 
        {
            "location": "/redis/package/#with-and-without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/redis.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Redis ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import Redis  to access Redis' APIs.", 
            "title": "With and without Vapor"
        }, 
        {
            "location": "/redis/basics/", 
            "text": "Redis basic usage\n\n\nTo interact with Redis, you first need to construct a Redis client.\n\n\nTo connect to Redis you can use a variety of methods. The Redis library primarily supports \nTCP sockets\n.\n\n\nThis requires a hostname, port and \nworker\n. The worker's DispatchQueue will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to \nlocalhost\n, and the port to Redis' default port \n6379\n.\n\n\nlet\n \nclient\n \n=\n \ntry\n \nRedisClient\n.\nconnect\n(\nworker\n:\n \nworker\n)\n \n// Future\nRedisClient\n\n\n\n\n\n\nThe \nconnect\n method will return a \nFuture\n containing the TCP based Redis Client.\n\n\nRedis Data Types\n\n\nRedis has 6 data types:\n\n\n\n\nnull\n\n\nInt\n\n\nError\n\n\nArray\n\n\nBasic String (used for command names and basic replies only)\n\n\nBulk String (used for Strings and binary data blobs)\n\n\n\n\nYou can instantiate one from the static functions and variables on \nRedisData\n.\n\n\nlet\n \nnull\n \n=\n \nRedisData\n.\nnull\n\n\n\nlet\n \nhelloWorld\n \n=\n \nRedisData\n.\nbulkString\n(\nHello World\n)\n\n\n\nlet\n \nthree\n \n=\n \nRedisData\n.\ninteger\n(\n3\n)\n\n\n\nlet\n \noneThroughTen\n \n=\n \nRedisData\n.\narray\n([\n\n  \n.\ninteger\n(\n1\n),\n\n  \n.\ninteger\n(\n2\n),\n\n  \n.\ninteger\n(\n3\n),\n\n  \n.\ninteger\n(\n4\n),\n\n  \n.\ninteger\n(\n5\n),\n\n  \n.\ninteger\n(\n6\n),\n\n  \n.\ninteger\n(\n7\n),\n\n  \n.\ninteger\n(\n8\n),\n\n  \n.\ninteger\n(\n9\n),\n\n  \n.\ninteger\n(\n10\n)\n\n\n])\n\n\n\n\n\n\nThe above is the explicit way of defining Redis Types. You can also use literals in most scenarios:\n\n\nlet\n \narray\n \n=\n \nRedisData\n.\narray\n([\n\n  \n[\n\n    \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n\n  \n],\n\n  \nHello World\n,\n\n  \nOne\n,\n\n  \nTwo\n,\n\n  \n.\nnull\n,\n\n  \n.\nnull\n,\n\n  \ntest\n\n\n])\n\n\n\n\n\n\nCRUD using Redis\n\n\nFrom here on it is assumed that your client has been successfully created and is available in the variable \nclient\n as a \nRedisClient\n.\n\n\nCreating a record\n\n\nCreating a record is done using a \nRedisData\n for a value and a key.\n\n\nclient\n.\nset\n(\nworld\n,\n \nforKey\n:\n \nhello\n)\n\n\n\n\n\n\nThis returns a future that'll indicate successful or unsuccessful insertion.\n\n\nReading a record\n\n\nReading a record is similar, only you'll get a warning if you don't use the returned future.\n\n\nThe \nFuture\nRedisData\n for the key \"hello\" will be \"world\" if you created the record as shown above.\n\n\nlet\n \nfutureRecord\n \n=\n \nclient\n.\ngetData\n(\nforKey\n:\n \nhello\n)\n \n// Future\nRedisData\n\n\n\n\n\n\nDeleting a record\n\n\nDeleting a record is similar but allows querying the keys, too.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\nhello\n])\n\n\n\n\n\n\nWhere the above command will remove the key \"hello\", the next command will delete \nall\n keys from the Redis database.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\n*\n])", 
            "title": "Basics"
        }, 
        {
            "location": "/redis/basics/#redis-basic-usage", 
            "text": "To interact with Redis, you first need to construct a Redis client.  To connect to Redis you can use a variety of methods. The Redis library primarily supports  TCP sockets .  This requires a hostname, port and  worker . The worker's DispatchQueue will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to  localhost , and the port to Redis' default port  6379 .  let   client   =   try   RedisClient . connect ( worker :   worker )   // Future RedisClient   The  connect  method will return a  Future  containing the TCP based Redis Client.", 
            "title": "Redis basic usage"
        }, 
        {
            "location": "/redis/basics/#redis-data-types", 
            "text": "Redis has 6 data types:   null  Int  Error  Array  Basic String (used for command names and basic replies only)  Bulk String (used for Strings and binary data blobs)   You can instantiate one from the static functions and variables on  RedisData .  let   null   =   RedisData . null  let   helloWorld   =   RedisData . bulkString ( Hello World )  let   three   =   RedisData . integer ( 3 )  let   oneThroughTen   =   RedisData . array ([ \n   . integer ( 1 ), \n   . integer ( 2 ), \n   . integer ( 3 ), \n   . integer ( 4 ), \n   . integer ( 5 ), \n   . integer ( 6 ), \n   . integer ( 7 ), \n   . integer ( 8 ), \n   . integer ( 9 ), \n   . integer ( 10 )  ])   The above is the explicit way of defining Redis Types. You can also use literals in most scenarios:  let   array   =   RedisData . array ([ \n   [ \n     1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 \n   ], \n   Hello World , \n   One , \n   Two , \n   . null , \n   . null , \n   test  ])", 
            "title": "Redis Data Types"
        }, 
        {
            "location": "/redis/basics/#crud-using-redis", 
            "text": "From here on it is assumed that your client has been successfully created and is available in the variable  client  as a  RedisClient .", 
            "title": "CRUD using Redis"
        }, 
        {
            "location": "/redis/basics/#creating-a-record", 
            "text": "Creating a record is done using a  RedisData  for a value and a key.  client . set ( world ,   forKey :   hello )   This returns a future that'll indicate successful or unsuccessful insertion.", 
            "title": "Creating a record"
        }, 
        {
            "location": "/redis/basics/#reading-a-record", 
            "text": "Reading a record is similar, only you'll get a warning if you don't use the returned future.  The  Future RedisData  for the key \"hello\" will be \"world\" if you created the record as shown above.  let   futureRecord   =   client . getData ( forKey :   hello )   // Future RedisData", 
            "title": "Reading a record"
        }, 
        {
            "location": "/redis/basics/#deleting-a-record", 
            "text": "Deleting a record is similar but allows querying the keys, too.  client . delete ( keys :   [ hello ])   Where the above command will remove the key \"hello\", the next command will delete  all  keys from the Redis database.  client . delete ( keys :   [ * ])", 
            "title": "Deleting a record"
        }, 
        {
            "location": "/redis/custom-commands/", 
            "text": "Custom commands\n\n\nMany commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.\n\n\n(Almost) all functions listed here\n work out of the box using custom commands.\n\n\nUsage\n\n\nThe Redis client has a \nrun\n function that allows you to run these commands.\n\n\nThe following code demonstrates a \"custom\" implementation for \nGET\n.\n\n\nlet\n \nfuture\n \n=\n \nclient\n.\nrun\n(\ncommand\n:\n \nGET\n,\n \narguments\n:\n \n[\nmy-key\n])\n \n// Future\nRedisData\n\n\n\n\n\n\nThis future will contain the result as specified in the article on the redis command page or an error.\n\n\nThe future can be used as described in the \nAsync API\n.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#custom-commands", 
            "text": "Many commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.  (Almost) all functions listed here  work out of the box using custom commands.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#usage", 
            "text": "The Redis client has a  run  function that allows you to run these commands.  The following code demonstrates a \"custom\" implementation for  GET .  let   future   =   client . run ( command :   GET ,   arguments :   [ my-key ])   // Future RedisData   This future will contain the result as specified in the article on the redis command page or an error.  The future can be used as described in the  Async API .", 
            "title": "Usage"
        }, 
        {
            "location": "/redis/pub-sub/", 
            "text": "Publish \n Subscribe\n\n\nRedis' Publish and Subscribe model is really useful for notifications.\n\n\nUse cases\n\n\nPub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.\n\n\nA channel consists of a name and group of listeners. Think of it as being \n[String: [Listener]]\n.\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.\n\n\nChannels must be a string. For chat groups, for example, you could use the database identifier.\n\n\nPublishing\n\n\nYou cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:\n\n\n// Any redis data\n\n\nlet\n \nnotification\n:\n \nRedisData\n \n=\n \nMy-Notification\n\n\n\nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n\n\n\n\n\n\nIf you want access to the listener count:\n\n\nlet\n \nnotifiedCount\n \n=\n \nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n \n// Future\nInt\n\n\n\n\n\n\nSubscribing\n\n\nTo subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.\n\n\nA single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a \nSubscriptionStream\n.\n\n\nlet\n \nnotifications\n \n=\n \nclient\n.\nsubscribe\n(\nto\n:\n \n[\nsome-notification-channel\n,\n \nother-notification-channel\n])\n\n\n\n\n\n\nIf you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.\n\n\nThis stream will receive messages asynchronously from the point of \ndraining\n. This works like \nany other async stream\n\n\nNotifications consist of the channel and payload.\n\n\nnotifications\n.\ndrain\n \n{\n \nnotification\n \nin\n\n  \nprint\n(\nnotification\n.\nchannel\n)\n\n\n  \nlet\n \npayload\n \n=\n \nnotification\n.\npayload\n\n\n  \n// \nTODO:\n Process the payload\n\n\n}", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#publish-subscribe", 
            "text": "Redis' Publish and Subscribe model is really useful for notifications.", 
            "title": "Publish &amp; Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#use-cases", 
            "text": "Pub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.  A channel consists of a name and group of listeners. Think of it as being  [String: [Listener]] .\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.  Channels must be a string. For chat groups, for example, you could use the database identifier.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pub-sub/#publishing", 
            "text": "You cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:  // Any redis data  let   notification :   RedisData   =   My-Notification  client . publish ( notification ,   to :   my-channel )   If you want access to the listener count:  let   notifiedCount   =   client . publish ( notification ,   to :   my-channel )   // Future Int", 
            "title": "Publishing"
        }, 
        {
            "location": "/redis/pub-sub/#subscribing", 
            "text": "To subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.  A single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a  SubscriptionStream .  let   notifications   =   client . subscribe ( to :   [ some-notification-channel ,   other-notification-channel ])   If you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.  This stream will receive messages asynchronously from the point of  draining . This works like  any other async stream  Notifications consist of the channel and payload.  notifications . drain   {   notification   in \n   print ( notification . channel ) \n\n   let   payload   =   notification . payload \n\n   //  TODO:  Process the payload  }", 
            "title": "Subscribing"
        }, 
        {
            "location": "/redis/pipeline/", 
            "text": "Pipelining\n\n\nPipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle. \n\n\nUse cases\n\n\nSometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.\n\n\nEnqueuing Commands\n\n\n \nlet\n \npipeline\n \n=\n \nconnection\n.\nmakePipeline\n()\n\n \nlet\n \nresult\n \n=\n \ntry\n \npipeline\n\n         \n.\nenqueue\n(\ncommand\n:\n \nSET\n,\n \narguments\n:\n \n[\nKEY\n,\n \nVALUE\n])\n\n         \n.\nenqueue\n(\ncommand\n:\n \nINCR\n,\n \narguments\n:\n \n[\nCOUNT\n])\n\n         \n.\nexecute\n()\n \n// Future\n[RedisData]\n\n\n\n\n\n\nNote: Commands will not be executed until execute is called.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/redis/pipeline/#pipelining", 
            "text": "Pipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle.", 
            "title": "Pipelining"
        }, 
        {
            "location": "/redis/pipeline/#use-cases", 
            "text": "Sometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pipeline/#enqueuing-commands", 
            "text": "let   pipeline   =   connection . makePipeline () \n  let   result   =   try   pipeline \n          . enqueue ( command :   SET ,   arguments :   [ KEY ,   VALUE ]) \n          . enqueue ( command :   INCR ,   arguments :   [ COUNT ]) \n          . execute ()   // Future [RedisData]   Note: Commands will not be executed until execute is called.", 
            "title": "Enqueuing Commands"
        }, 
        {
            "location": "/websocket/websocket/", 
            "text": "WebSocket\n\n\nWebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1.1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.\n\n\nVapor 3 supports both WebSocket \nClient\n and \nServer\n.\n\n\nUsing websockets\n\n\nWebSockets are interacted with using \nbinary streams\n or \ntext streams\n.\n\n\nErrors\n\n\nAny error in a WebSocket will close the connection.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#websocket", 
            "text": "WebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1.1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.  Vapor 3 supports both WebSocket  Client  and  Server .", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#using-websockets", 
            "text": "WebSockets are interacted with using  binary streams  or  text streams .", 
            "title": "Using websockets"
        }, 
        {
            "location": "/websocket/websocket/#errors", 
            "text": "Any error in a WebSocket will close the connection.", 
            "title": "Errors"
        }, 
        {
            "location": "/websocket/binary-stream/", 
            "text": "Binary Streams\n\n\nWebSockets have separate \ntext\n and binary data flows.\n\n\nSending binary input to a WebSocket sends it to the remote. Listening for binary on a WebSocket receives binary (and binary continuation) data from clients.\n\n\nSending binary data\n\n\nSending a \nData\n or \nByteBuffer\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nbyteBuffer\n)\n\n\nwebSocket\n.\nsend\n(\ndata\n)\n\n\n\n\n\n\nReceiving binary data\n\n\nBinary data can be read as a \nByteBuffer\n using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonBinary\n \n{\n \nbyteBuffer\n \nin\n\n  \n// use the `ByteBuffer`\n\n\n}\n\n\n\n\n\n\nBinary data can also, instead, be used as Foundation's \nData\n. This is less efficient than \nByteBuffer\n but often easier to use.\n\n\nwebSocket\n.\nonData\n \n{\n \ndata\n \nin\n\n  \n// use the `Data`\n\n\n}\n\n\n\n\n\n\nYou can only use one of the two listeners at a time.", 
            "title": "Binary"
        }, 
        {
            "location": "/websocket/binary-stream/#binary-streams", 
            "text": "WebSockets have separate  text  and binary data flows.  Sending binary input to a WebSocket sends it to the remote. Listening for binary on a WebSocket receives binary (and binary continuation) data from clients.", 
            "title": "Binary Streams"
        }, 
        {
            "location": "/websocket/binary-stream/#sending-binary-data", 
            "text": "Sending a  Data  or  ByteBuffer  using a WebSocket sends it to the remote.  webSocket . send ( byteBuffer )  webSocket . send ( data )", 
            "title": "Sending binary data"
        }, 
        {
            "location": "/websocket/binary-stream/#receiving-binary-data", 
            "text": "Binary data can be read as a  ByteBuffer  using the following function. Only one closure can read at a time.  webSocket . onBinary   {   byteBuffer   in \n   // use the `ByteBuffer`  }   Binary data can also, instead, be used as Foundation's  Data . This is less efficient than  ByteBuffer  but often easier to use.  webSocket . onData   {   data   in \n   // use the `Data`  }   You can only use one of the two listeners at a time.", 
            "title": "Receiving binary data"
        }, 
        {
            "location": "/websocket/text-stream/", 
            "text": "Text Streams\n\n\nWebSockets have separate text and \nbinary\n data flows.\n\n\nSending text input to a WebSocket sends it to the remote. Listening for text on a WebSocket receives text data from clients.\n\n\nSending strings\n\n\nSending a \nString\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nstring\n)\n\n\n\n\n\n\nReceiving strings\n\n\nString data can be read using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonText\n \n{\n \ntext\n \nin\n\n  \n// use the `String`\n\n\n}", 
            "title": "Text"
        }, 
        {
            "location": "/websocket/text-stream/#text-streams", 
            "text": "WebSockets have separate text and  binary  data flows.  Sending text input to a WebSocket sends it to the remote. Listening for text on a WebSocket receives text data from clients.", 
            "title": "Text Streams"
        }, 
        {
            "location": "/websocket/text-stream/#sending-strings", 
            "text": "Sending a  String  using a WebSocket sends it to the remote.  webSocket . send ( string )", 
            "title": "Sending strings"
        }, 
        {
            "location": "/websocket/text-stream/#receiving-strings", 
            "text": "String data can be read using the following function. Only one closure can read at a time.  webSocket . onText   {   text   in \n   // use the `String`  }", 
            "title": "Receiving strings"
        }, 
        {
            "location": "/websocket/client/", 
            "text": "WebSocket Client\n\n\nWebSocket clients work the same on the client side as the \nserver side\n.\n\n\nConnecting a WebSocket client\n\n\nWebSockets require an \nURI\n to connect to and a \nWorker\n to run on.\n\n\n\n\nWarning\n\n\nVapor does not retain the WebSocket. It is the responsibility of the user to keep the WebSocket active by means of strong references and pings.\n\n\n\n\nlet\n \nworker\n:\n \nWorker\n \n=\n \n...\n\n\n\nlet\n \nfutureWebSocket\n:\n \nFuture\nWebSocket\n \n=\n \ntry\n \nWebSocket\n.\nconnect\n(\nto\n:\n \nws://localhost/path\n,\n \nworker\n:\n \nworker\n)\n\n\n\n\n\n\nUsing websockets\n\n\nWebSockets are interacted with using \nbinary streams\n or \ntext streams\n.\n\n\nAll other information about websockets \nis defined here.", 
            "title": "Client"
        }, 
        {
            "location": "/websocket/client/#websocket-client", 
            "text": "WebSocket clients work the same on the client side as the  server side .", 
            "title": "WebSocket Client"
        }, 
        {
            "location": "/websocket/client/#connecting-a-websocket-client", 
            "text": "WebSockets require an  URI  to connect to and a  Worker  to run on.   Warning  Vapor does not retain the WebSocket. It is the responsibility of the user to keep the WebSocket active by means of strong references and pings.   let   worker :   Worker   =   ...  let   futureWebSocket :   Future WebSocket   =   try   WebSocket . connect ( to :   ws://localhost/path ,   worker :   worker )", 
            "title": "Connecting a WebSocket client"
        }, 
        {
            "location": "/websocket/client/#using-websockets", 
            "text": "WebSockets are interacted with using  binary streams  or  text streams .  All other information about websockets  is defined here.", 
            "title": "Using websockets"
        }, 
        {
            "location": "/websocket/upgrade/", 
            "text": "WebSocket Upgrading\n\n\nServers can upgrade HTTP requests to a WebSocket if the client indicated an upgrade.\n\n\nDetermining an upgrade\n\n\nYou will need to \nimport WebSocket\n for the upgrade functionality.\n\n\nCreate a basic \nGET\n route. WebSockets always connect with a GET \nmethod\n.\n\n\nimport\n \nWebSocket\n\n\n\ndrop\n.\nget\n(\napi/v1/websocket\n)\n \n{\n \nreq\n \nin\n\n  \nlet\n \nshouldUpgrade\n \n=\n \nWebSocket\n.\nshouldUpgrade\n(\nfor\n:\n \nreq\n)\n\n\n}\n\n\n\n\n\n\nUpgrading the connection\n\n\nThe WebSocket library can generate an appropriate \nResponse\n for you. You can return this in your route.\n\n\nYou will be able to set a handler inside \nonUpgrade\n in which a websocket will be returned after completion of the upgrade.\n\n\n\n\nWarning\n\n\nVapor does not retain the WebSocket. It is the responsibility of the user to keep the WebSocket active by means of strong references and pings.\n\n\n\n\nif\n \nshouldUpgrade\n \n{\n\n  \nlet\n \nresponse\n \n=\n \ntry\n \nWebSocket\n.\nupgradeResponse\n(\nfor\n:\n \nreq\n)\n\n\n  \nresponse\n.\nonUpgrade\n \n=\n \n{\n \nclient\n \nin\n\n      \nlet\n \nwebsocket\n \n=\n \nWebSocket\n(\nclient\n:\n \nclient\n)\n\n      \nwebsocket\n.\nonText\n \n{\n \ntext\n \nin\n\n          \nlet\n \nrev\n \n=\n \nString\n(\ntext\n.\nreversed\n())\n\n          \nwebsocket\n.\nsend\n(\nrev\n)\n\n      \n}\n\n      \nwebsocket\n.\nonBinary\n \n{\n \nbuffer\n \nin\n\n          \nwebsocket\n.\nsend\n(\nbuffer\n)\n\n      \n}\n\n  \n}\n\n\n  \nreturn\n \nresponse\n\n\n}\n\n\n\n\n\n\nUsing websockets\n\n\nWebSockets are interacted with using \nbinary streams\n or \ntext streams\n.\n\n\nAll other information about websockets \nis defined here.", 
            "title": "Server Upgrades"
        }, 
        {
            "location": "/websocket/upgrade/#websocket-upgrading", 
            "text": "Servers can upgrade HTTP requests to a WebSocket if the client indicated an upgrade.", 
            "title": "WebSocket Upgrading"
        }, 
        {
            "location": "/websocket/upgrade/#determining-an-upgrade", 
            "text": "You will need to  import WebSocket  for the upgrade functionality.  Create a basic  GET  route. WebSockets always connect with a GET  method .  import   WebSocket  drop . get ( api/v1/websocket )   {   req   in \n   let   shouldUpgrade   =   WebSocket . shouldUpgrade ( for :   req )  }", 
            "title": "Determining an upgrade"
        }, 
        {
            "location": "/websocket/upgrade/#upgrading-the-connection", 
            "text": "The WebSocket library can generate an appropriate  Response  for you. You can return this in your route.  You will be able to set a handler inside  onUpgrade  in which a websocket will be returned after completion of the upgrade.   Warning  Vapor does not retain the WebSocket. It is the responsibility of the user to keep the WebSocket active by means of strong references and pings.   if   shouldUpgrade   { \n   let   response   =   try   WebSocket . upgradeResponse ( for :   req ) \n\n   response . onUpgrade   =   {   client   in \n       let   websocket   =   WebSocket ( client :   client ) \n       websocket . onText   {   text   in \n           let   rev   =   String ( text . reversed ()) \n           websocket . send ( rev ) \n       } \n       websocket . onBinary   {   buffer   in \n           websocket . send ( buffer ) \n       } \n   } \n\n   return   response  }", 
            "title": "Upgrading the connection"
        }, 
        {
            "location": "/websocket/upgrade/#using-websockets", 
            "text": "WebSockets are interacted with using  binary streams  or  text streams .  All other information about websockets  is defined here.", 
            "title": "Using websockets"
        }, 
        {
            "location": "/routing/package/", 
            "text": "Using Routing\n\n\nRouting is a library containing all Routing related APIs.\n\n\nIndex\n\n\n\n\nBasics\n\n\nRoute Parameters\n\n\nRoute\n\n\nTrieRouter\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nRouting\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/routing.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nRouting\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport Routing\n to access Routing's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/routing/package/#using-routing", 
            "text": "Routing is a library containing all Routing related APIs.", 
            "title": "Using Routing"
        }, 
        {
            "location": "/routing/package/#index", 
            "text": "Basics  Route Parameters  Route  TrieRouter", 
            "title": "Index"
        }, 
        {
            "location": "/routing/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Routing", 
            "title": "With Vapor"
        }, 
        {
            "location": "/routing/package/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/routing.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Routing ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import Routing  to access Routing's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/routing/basics/", 
            "text": "Basics\n\n\nIn Vapor the default Router is the \nTrieRouter\n. You can implement custom routers by implementing one conformant to the \nRouter\n protocol.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \napp\n.\nmake\n(\nRouter\n.\nself\n)\n\n\n\n\n\n\nThere are two APIs available, one is supplied by the \nRouting\n library and a set of helpers is available in Vapor itself.\n\n\nRegistering a route using Routing\n\n\nThe \non\n function on a \nAsyncRouter\n registers a route to the provided path. The following registers a \nGET /hello/world\n route.\n\n\nIt responds with \n\"Hello world!\"\n using futures.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nhello\n,\n \nworld\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nFuture\n(\ntry\n \nResponse\n(\nbody\n:\n \nHello world!\n))\n\n\n}\n\n\n\n\n\n\nThe \n.get\n represents the \nMethod\n you want to use. \nto: \"hello\", \"world\"\n registers the path \n/hello/world\n.\n\n\nFor variable path components you can use \nparameters\n.\n\n\nThe trailing closure receives a \nRequest\n. The route can throw errors and needs to return a \nFuture\nResponseRepresentable\n conforming type.\n\n\nRegistering a route using Vapor\n\n\nIn Vapor we add support for routes using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands.\n\n\nFor variable path components you can use \nparameters\n here, too.\n\n\nVapor has an added benefit here in that you can return the \nResponse\n itself in addition to \nFuture\nResponseRepresentable\n or \nFuture\nResponse\n.\n\n\ndrop\n.\nget\n(\ncomponents\n,\n \nin\n,\n \npath\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}", 
            "title": "Basics"
        }, 
        {
            "location": "/routing/basics/#basics", 
            "text": "In Vapor the default Router is the  TrieRouter . You can implement custom routers by implementing one conformant to the  Router  protocol.  let   router   =   try   app . make ( Router . self )   There are two APIs available, one is supplied by the  Routing  library and a set of helpers is available in Vapor itself.", 
            "title": "Basics"
        }, 
        {
            "location": "/routing/basics/#registering-a-route-using-routing", 
            "text": "The  on  function on a  AsyncRouter  registers a route to the provided path. The following registers a  GET /hello/world  route.  It responds with  \"Hello world!\"  using futures.  router . on (. get ,   to :   hello ,   world )   {   request   in \n   return   Future ( try   Response ( body :   Hello world! ))  }   The  .get  represents the  Method  you want to use.  to: \"hello\", \"world\"  registers the path  /hello/world .  For variable path components you can use  parameters .  The trailing closure receives a  Request . The route can throw errors and needs to return a  Future ResponseRepresentable  conforming type.", 
            "title": "Registering a route using Routing"
        }, 
        {
            "location": "/routing/basics/#registering-a-route-using-vapor", 
            "text": "In Vapor we add support for routes using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands.  For variable path components you can use  parameters  here, too.  Vapor has an added benefit here in that you can return the  Response  itself in addition to  Future ResponseRepresentable  or  Future Response .  drop . get ( components ,   in ,   path )   {   request   in \n   return   Response ( status :   . ok )  }", 
            "title": "Registering a route using Vapor"
        }, 
        {
            "location": "/routing/parameters/", 
            "text": "Parameters\n\n\nParameters are a registered type that can be initialized from a String.\n\n\nThey can be part of a \nRoute\n, and be extracted from \nRequests\n that are called in that Route.\n\n\nCreating custom parameters\n\n\nTo create a custom parameter type, simply conform to \nParameter\n and implement the conversion function \nmake\n and a unique slug.\n\n\nIn this example, the \nUser\n class will be initialized from a parameter that represents it's identifier.\n\n\nWe recommend prefixing custom Parameter identifiers.\n\n\nclass\n \nUser\n \n:\n \nParameter\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n\n  \n// The unique (prefixed) identifier for this type\n\n  \nstatic\n \nvar\n \nuniqueSlug\n \n=\n \nmy-app:user\n\n\n  \n// Creates a new user from the raw `parameter`\n\n  \nstatic\n \nfunc\n \nmake\n(\nfor\n \nparameter\n:\n \nString\n,\n \nin\n \nrequest\n:\n \nRequest\n)\n \nthrows\n \n-\n \nUser\n \n{\n\n    \nreturn\n \nUser\n(\nnamed\n:\n \nparameter\n)\n\n  \n}\n\n\n  \ninit\n(\nnamed\n \nusername\n:\n \nString\n)\n \n{\n\n    \nself\n.\nusername\n \n=\n \nusername\n\n  \n}\n\n\n}\n\n\n\n\n\n\nUsing (custom) parameters\n\n\nAfter conforming a type to \nParameter\n you can access it's static property \nparameter\n as part of a path.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nusers\n,\n \nUser\n.\nparameter\n,\n \nprofile\n)\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nuser\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nUser\n.\nself\n)\n\n\n  \n// Return the user\ns Profile sync or async (depending on the router)\n\n\n}", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#parameters", 
            "text": "Parameters are a registered type that can be initialized from a String.  They can be part of a  Route , and be extracted from  Requests  that are called in that Route.", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#creating-custom-parameters", 
            "text": "To create a custom parameter type, simply conform to  Parameter  and implement the conversion function  make  and a unique slug.  In this example, the  User  class will be initialized from a parameter that represents it's identifier.  We recommend prefixing custom Parameter identifiers.  class   User   :   Parameter   { \n   var   username :   String \n\n   // The unique (prefixed) identifier for this type \n   static   var   uniqueSlug   =   my-app:user \n\n   // Creates a new user from the raw `parameter` \n   static   func   make ( for   parameter :   String ,   in   request :   Request )   throws   -   User   { \n     return   User ( named :   parameter ) \n   } \n\n   init ( named   username :   String )   { \n     self . username   =   username \n   }  }", 
            "title": "Creating custom parameters"
        }, 
        {
            "location": "/routing/parameters/#using-custom-parameters", 
            "text": "After conforming a type to  Parameter  you can access it's static property  parameter  as part of a path.  router . on (. get ,   to :   users ,   User . parameter ,   profile )   {   request   in \n   let   user   =   try   request . parameters . next ( User . self ) \n\n   // Return the user s Profile sync or async (depending on the router)  }", 
            "title": "Using (custom) parameters"
        }, 
        {
            "location": "/routing/route/", 
            "text": "Route\n\n\nRoute is an object that contains the essential information of an HTTP Route.\n\n\nIt contains the route's Method, path components and responder.\n\n\nExtensions\n\n\nRoutes are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nThe purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#route", 
            "text": "Route is an object that contains the essential information of an HTTP Route.  It contains the route's Method, path components and responder.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#extensions", 
            "text": "Routes are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.  The purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Extensions"
        }, 
        {
            "location": "/routing/router/", 
            "text": "Router\n\n\nRouter is a protocol that you can conform your own routers to.\n\n\nRegistering a route\n\n\nFirst, create a \nRoute\n using a \nMethod\n, path and a responder.\n\n\nThe following example shows a route with a constant path.\n\n\nlet\n \nresponder\n \n=\n \nBasicAsyncResponder\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nHello world\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\nhello\n),\n \n.\nconstant\n(\nworld\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nThe following example shows a with a \nParameter\n:\n\n\nlet\n \nresponder\n \n=\n \nBasicSyncResponder\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nname\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nString\n.\nself\n)\n\n  \nreturn\n \nHello \n\\(\nname\n)\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\ngreet\n),\n \n.\nparameter\n(\nString\n.\nself\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nRouting a request through a Router\n\n\nAssuming you have a request, like the following example:\n\n\nlet\n \nrequest\n \n=\n \nRequest\n(\nmethod\n:\n \n.\nget\n,\n \nURI\n(\npath\n:\n \n/hello/world\n))\n\n\n\n\n\n\nThe router should be able to route the \nRequest\n using\n\n\nlet\n \nresponder\n \n=\n \nrouter\n.\nroute\n(\nrequest\n:\n \nrequest\n)", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#router", 
            "text": "Router is a protocol that you can conform your own routers to.", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#registering-a-route", 
            "text": "First, create a  Route  using a  Method , path and a responder.  The following example shows a route with a constant path.  let   responder   =   BasicAsyncResponder   {   request   in \n   return   Hello world  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( hello ),   . constant ( world )],   responder :   responder )   The following example shows a with a  Parameter :  let   responder   =   BasicSyncResponder   {   request   in \n   let   name   =   try   request . parameters . next ( String . self ) \n   return   Hello  \\( name )  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( greet ),   . parameter ( String . self )],   responder :   responder )", 
            "title": "Registering a route"
        }, 
        {
            "location": "/routing/router/#routing-a-request-through-a-router", 
            "text": "Assuming you have a request, like the following example:  let   request   =   Request ( method :   . get ,   URI ( path :   /hello/world ))   The router should be able to route the  Request  using  let   responder   =   router . route ( request :   request )", 
            "title": "Routing a request through a Router"
        }, 
        {
            "location": "/services/getting-started/", 
            "text": "Configure\n\n\nYou configure the application in the \nconfigure.swift\n file. Here you can\nregister your own services, or override the ones provided by default.\n\n\nimport\n \nVapor\n\n\n\npublic\n \nfunc\n \nconfigure\n(...)\n \nthrows\n \n{\n\n    \nservices\n.\nregister\n \n{\n\n        \nlet\n \nfoo\n \n=\n \nFooService\n(...)\n\n        \nreturn\n \nfoo\n\n    \n}\n\n\n}\n\n\n\n\n\n\nLater, after your application has booted, you can then request your registered service.\n\n\nlet\n \nfoo\n \n=\n \ntry\n \napp\n.\nmake\n(\nFooService\n.\nself\n)\n\n\n\n\n\n\nProviders", 
            "title": "Getting Started"
        }, 
        {
            "location": "/services/getting-started/#configure", 
            "text": "You configure the application in the  configure.swift  file. Here you can\nregister your own services, or override the ones provided by default.  import   Vapor  public   func   configure (...)   throws   { \n     services . register   { \n         let   foo   =   FooService (...) \n         return   foo \n     }  }   Later, after your application has booted, you can then request your registered service.  let   foo   =   try   app . make ( FooService . self )", 
            "title": "Configure"
        }, 
        {
            "location": "/services/getting-started/#providers", 
            "text": "", 
            "title": "Providers"
        }, 
        {
            "location": "/jwt/package/", 
            "text": "JSON Web Token\n\n\nJSON Web Token is a library containing all JSON Web Token related APIs.\n\n\nWhat is JWT?\n\n\nJWT is a standard for managing client tokens. Tokens are a form of identification and proof to the server. JWT is cryptographically signed, so it is not possible to falsify the validity of a JWT unless any of the following conditions is met:\n\n\n\n\nA broken algorithm was used (such as MD5)\n\n\nA weak signing key was used and brute-forced\n\n\nThe signing key used was leaked out to a third party\n\n\n\n\nPlease note that any private/secret data \nmust not\n be stored inside a JSON Web Token since they're publically readable. They are \nnot\n encrypted.\n\n\nIndex\n\n\n\n\nJSON Web Signature\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nJWT\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/jwt.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nJWT\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport JWT\n to access JSON Web Token's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/jwt/package/#json-web-token", 
            "text": "JSON Web Token is a library containing all JSON Web Token related APIs.", 
            "title": "JSON Web Token"
        }, 
        {
            "location": "/jwt/package/#what-is-jwt", 
            "text": "JWT is a standard for managing client tokens. Tokens are a form of identification and proof to the server. JWT is cryptographically signed, so it is not possible to falsify the validity of a JWT unless any of the following conditions is met:   A broken algorithm was used (such as MD5)  A weak signing key was used and brute-forced  The signing key used was leaked out to a third party   Please note that any private/secret data  must not  be stored inside a JSON Web Token since they're publically readable. They are  not  encrypted.", 
            "title": "What is JWT?"
        }, 
        {
            "location": "/jwt/package/#index", 
            "text": "JSON Web Signature", 
            "title": "Index"
        }, 
        {
            "location": "/jwt/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   JWT", 
            "title": "With Vapor"
        }, 
        {
            "location": "/jwt/package/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/jwt.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ JWT ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import JWT  to access JSON Web Token's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/jwt/jws/", 
            "text": "JWS (JSON Web Signature) tokens\n\n\nJSON Web Signatures are a Base64 encoded token with a signature for verification.\n\n\nThis means signatures can be read by the client and \nmust not\n contain sensitive data such as passwords.\n\n\nIt can be used as an authentication token or \"proof\" by the client.\n\n\nIt does not need to be stored on the server and can be verified by any server that knows the key used for signing.\n\n\nCreating a token\n\n\nCreating a token is as simple as creating a Codable struct.\n\n\nstruct\n \nAuthorizationToken\n \n:\n \nCodable\n \n{\n\n  \nlet\n \nauthenticatedUsername\n:\n \nString\n\n\n}\n\n\n\n\n\n\nSending a signed token with the client\n\n\nTo send a token to the client, you need to sign it. Signing is done using a \"secret\". Secrets are a static key that stays the same across server reboots and is usually put inside a configuration file.\n\n\nSecrets \nshould\n be randomly generated. Longer secrets and less predictable are better, there is no limit.\n\n\nOnce a secret is available in the application you can sign your tokens.\n\n\nTo sign your token, you need to select an algorithm. We support \nhs256\n, \nhs384\n and \nhs512\n.\n\n\nlet\n \nheader\n \n=\n \nJWT\n.\nHeader\n.\nhs512\n()\n\n\n\n\n\n\nFor this example, the following token/payload is used:\n\n\nlet\n \ntoken\n \n=\n \nAuthorizationToken\n(\nauthenticatedUsername\n:\n \nExample Username\n)\n\n\n\n\n\n\nThen, create a signature.\n\n\nlet\n \nsecret\n:\n \nData\n \n=\n \n...\n \n// your secret\n\n\n\nlet\n \njws\n \n=\n \nJSONWebSignature\n(\nheaders\n:\n \n[\nheader\n],\n \npayload\n:\n \ntoken\n,\n \nsecret\n:\n \nsecret\n)\n\n\n\n\n\n\nSecrets are expected to be a \nFoundation.Data\n. If your secret is a \nString\n, convert it using \nData(stringSecret.utf8)\n.\n\n\nTo receive the signature as a String (for in a Cookie or JSON response) you can use \nsignedString\n.\n\n\nlet\n \nencodedSignature\n:\n \nString\n \n=\n \ntry\n \njws\n.\nsignedString\n()\n\n\n\n\n\n\nIf you want binary data instead, use \nsign\n:\n\n\nlet\n \nencodedSignature\n:\n \nData\n \n=\n \ntry\n \njws\n.\nsign\n()\n\n\n\n\n\n\nDecoding a token\n\n\nWhen the client interacts with your website again, they'll have a token this time. This token needs to be decoded and verified first.\n\n\nlet\n \nsignature\n:\n \ntry\n \nJSONWebSignature\nAuthorizationToken\n(\nfrom\n:\n \nencodedSignature\n,\n \nverifyingWith\n:\n \nsecret\n)\n\n\n\n\n\n\nThe \nsignature\n in this example is a \nData\n or \nString\n containing the encoded signature.\n\n\nThe secret is the same secret we used in the above example for signing.\n\n\nIf the message has been tampered with, the token will not be initialized and an error will be thrown instead.\n\n\nTo extract the \nAuthorizationToken\n, you access the \ntoken.payload\n.\n\n\nlet\n \ntoken\n:\n \nAuthorizationToken\n \n=\n \nsignature\n.\npayload\n\n\n\nprint\n(\ntoken\n.\nusername\n)\n \n// prints \nExample Username", 
            "title": "Signed Tokens"
        }, 
        {
            "location": "/jwt/jws/#jws-json-web-signature-tokens", 
            "text": "JSON Web Signatures are a Base64 encoded token with a signature for verification.  This means signatures can be read by the client and  must not  contain sensitive data such as passwords.  It can be used as an authentication token or \"proof\" by the client.  It does not need to be stored on the server and can be verified by any server that knows the key used for signing.", 
            "title": "JWS (JSON Web Signature) tokens"
        }, 
        {
            "location": "/jwt/jws/#creating-a-token", 
            "text": "Creating a token is as simple as creating a Codable struct.  struct   AuthorizationToken   :   Codable   { \n   let   authenticatedUsername :   String  }", 
            "title": "Creating a token"
        }, 
        {
            "location": "/jwt/jws/#sending-a-signed-token-with-the-client", 
            "text": "To send a token to the client, you need to sign it. Signing is done using a \"secret\". Secrets are a static key that stays the same across server reboots and is usually put inside a configuration file.  Secrets  should  be randomly generated. Longer secrets and less predictable are better, there is no limit.  Once a secret is available in the application you can sign your tokens.  To sign your token, you need to select an algorithm. We support  hs256 ,  hs384  and  hs512 .  let   header   =   JWT . Header . hs512 ()   For this example, the following token/payload is used:  let   token   =   AuthorizationToken ( authenticatedUsername :   Example Username )   Then, create a signature.  let   secret :   Data   =   ...   // your secret  let   jws   =   JSONWebSignature ( headers :   [ header ],   payload :   token ,   secret :   secret )   Secrets are expected to be a  Foundation.Data . If your secret is a  String , convert it using  Data(stringSecret.utf8) .  To receive the signature as a String (for in a Cookie or JSON response) you can use  signedString .  let   encodedSignature :   String   =   try   jws . signedString ()   If you want binary data instead, use  sign :  let   encodedSignature :   Data   =   try   jws . sign ()", 
            "title": "Sending a signed token with the client"
        }, 
        {
            "location": "/jwt/jws/#decoding-a-token", 
            "text": "When the client interacts with your website again, they'll have a token this time. This token needs to be decoded and verified first.  let   signature :   try   JSONWebSignature AuthorizationToken ( from :   encodedSignature ,   verifyingWith :   secret )   The  signature  in this example is a  Data  or  String  containing the encoded signature.  The secret is the same secret we used in the above example for signing.  If the message has been tampered with, the token will not be initialized and an error will be thrown instead.  To extract the  AuthorizationToken , you access the  token.payload .  let   token :   AuthorizationToken   =   signature . payload  print ( token . username )   // prints  Example Username", 
            "title": "Decoding a token"
        }, 
        {
            "location": "/crypto/package/", 
            "text": "Using Crypto\n\n\nCrypto is a library containing all common APIs related to cryptography and security.\n\n\nThis project does \nnot\n support TLS. For that, please see \nthe TLS package\n.\n\n\nIndex\n\n\n\n\nPassword hashing and verification\n\n\nMessage authentication\n\n\nBase64 (also Streaming)\n\n\nHashes (also Streaming)\n\n\nRandom\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nCrypto\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/crypto.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \nx.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nCrypto\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Crypto\n to access Crypto's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/crypto/package/#using-crypto", 
            "text": "Crypto is a library containing all common APIs related to cryptography and security.  This project does  not  support TLS. For that, please see  the TLS package .", 
            "title": "Using Crypto"
        }, 
        {
            "location": "/crypto/package/#index", 
            "text": "Password hashing and verification  Message authentication  Base64 (also Streaming)  Hashes (also Streaming)  Random", 
            "title": "Index"
        }, 
        {
            "location": "/crypto/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Crypto", 
            "title": "With Vapor"
        }, 
        {
            "location": "/crypto/package/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/crypto.git ,   . upToNextMajor ( from :   x.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Crypto ,   ...   ]) \n     ]  )   Use  import Crypto  to access Crypto's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/crypto/base64/", 
            "text": "Encoding\n\n\nBase64Encoder\n is used to encode Base64 data. It works either as a stream or as a bulk decoder.\n\n\nBulk Encoding\n\n\nBase64 can be bulk-encoded using a static method \nencode\n. This throws an error if the base64 is invalid.\n\n\nYou can encode \nString\n, \nData\n or \nByteBuffer\n input.\n\n\nlet\n \nencodedData\n:\n \nData\n \n=\n \nBase64Encoder\n.\nencode\n(\ninput\n)\n\n\n\n\n\n\nStream Encoding\n\n\nTo use the Base64 streaming encoder, you first need to initialize the \nBase64Encoder\n.\n\n\nlet\n \nencoder\n \n=\n \nBase64Encoder\n()\n\n\n\n\n\n\nThe input of the \nBase64Encoder\n is the raw data. The output is Base64 encoded data. The final Base64-padding will be applied only when the input stream closes.\n\n\nDecoding\n\n\nBase64Decoder\n is used to decode Base64 data. It works either as a stream or as a bulk decoder.\n\n\nBulk Decoding\n\n\nBase64 can be bulk-decoded using a static method \ndecode\n. This throws an error if the base64 is invalid.\n\n\nYou can decode \nString\n, \nData\n or \nByteBuffer\n input.\n\n\nlet\n \ndecodedData\n:\n \nData\n \n=\n \ntry\n \nBase64Decoder\n.\ndecode\n(\ninput\n)\n\n\n\n\n\n\nStream Decoding\n\n\nTo use the Base64 streaming decoder, you first need to initialize the \nBase64Decoder\n.\n\n\nlet\n \nencoder\n \n=\n \nBase64Decoder\n()\n\n\n\n\n\n\nThe input of the \nBase64Decoder\n is the Base64 encoded data. The output is raw data.\n\n\nTips\n\n\nTransforming binary streams\n\n\nBoth \nBase64Encoder\n and \nBase64Decoder\n have a static \ntransform\n function that transforms an existing stream of data using the en/decoder.\n\n\nlet\n \nbase64EncodedStream\n \n=\n \nBase64Encoder\n.\ntransform\n(\nbinaryStream\n)\n\n\nlet\n \nnewBinaryStream\n \n=\n \nBase64Decoder\n.\ntransform\n(\nbase64EncodedStream\n)\n\n\n\n\n\n\nOptimization\n\n\nBoth \nBase64Encoder\n as well as \nBase64Decoder\n accept the \ndecodedCapacity\n. This is the expected amount of decoded bytes you expect to input or receive.\n\n\nIf you expect to receive (a maximum of) \n100_000\n bytes of input to encode per event on the stream, you should make that the \ndecodedCapacity\n. By default it's set to \nUInt16.max\n, which is sensible for TCP sockets.", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/base64/#encoding", 
            "text": "Base64Encoder  is used to encode Base64 data. It works either as a stream or as a bulk decoder.", 
            "title": "Encoding"
        }, 
        {
            "location": "/crypto/base64/#bulk-encoding", 
            "text": "Base64 can be bulk-encoded using a static method  encode . This throws an error if the base64 is invalid.  You can encode  String ,  Data  or  ByteBuffer  input.  let   encodedData :   Data   =   Base64Encoder . encode ( input )", 
            "title": "Bulk Encoding"
        }, 
        {
            "location": "/crypto/base64/#stream-encoding", 
            "text": "To use the Base64 streaming encoder, you first need to initialize the  Base64Encoder .  let   encoder   =   Base64Encoder ()   The input of the  Base64Encoder  is the raw data. The output is Base64 encoded data. The final Base64-padding will be applied only when the input stream closes.", 
            "title": "Stream Encoding"
        }, 
        {
            "location": "/crypto/base64/#decoding", 
            "text": "Base64Decoder  is used to decode Base64 data. It works either as a stream or as a bulk decoder.", 
            "title": "Decoding"
        }, 
        {
            "location": "/crypto/base64/#bulk-decoding", 
            "text": "Base64 can be bulk-decoded using a static method  decode . This throws an error if the base64 is invalid.  You can decode  String ,  Data  or  ByteBuffer  input.  let   decodedData :   Data   =   try   Base64Decoder . decode ( input )", 
            "title": "Bulk Decoding"
        }, 
        {
            "location": "/crypto/base64/#stream-decoding", 
            "text": "To use the Base64 streaming decoder, you first need to initialize the  Base64Decoder .  let   encoder   =   Base64Decoder ()   The input of the  Base64Decoder  is the Base64 encoded data. The output is raw data.", 
            "title": "Stream Decoding"
        }, 
        {
            "location": "/crypto/base64/#tips", 
            "text": "", 
            "title": "Tips"
        }, 
        {
            "location": "/crypto/base64/#transforming-binary-streams", 
            "text": "Both  Base64Encoder  and  Base64Decoder  have a static  transform  function that transforms an existing stream of data using the en/decoder.  let   base64EncodedStream   =   Base64Encoder . transform ( binaryStream )  let   newBinaryStream   =   Base64Decoder . transform ( base64EncodedStream )", 
            "title": "Transforming binary streams"
        }, 
        {
            "location": "/crypto/base64/#optimization", 
            "text": "Both  Base64Encoder  as well as  Base64Decoder  accept the  decodedCapacity . This is the expected amount of decoded bytes you expect to input or receive.  If you expect to receive (a maximum of)  100_000  bytes of input to encode per event on the stream, you should make that the  decodedCapacity . By default it's set to  UInt16.max , which is sensible for TCP sockets.", 
            "title": "Optimization"
        }, 
        {
            "location": "/crypto/hash/", 
            "text": "Hash\n\n\nHashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.\n\n\nAvailable hashes\n\n\nCrypto currently supports a few hashes.\n\n\n\n\nMD5\n\n\nSHA1\n\n\nSHA2 (all variants)\n\n\n\n\nMD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.\n\n\nEvery Hash type has a set of helpers that you can use.\n\n\nHashing blobs of data\n\n\nEvery \nHash\n has a static method called \nhash\n that can be used for hashing the entire contents of \nFoundation.Data\n, \nByteBuffer\n or \nString\n.\n\n\nThe result is \nData\n containing the resulting hash. The hash's length is according to spec and defined in the static variable \ndigestSize\n.\n\n\n// MD5 with `Data`\n\n\nlet\n \nfileData\n \n=\n \nData\n()\n\n\nlet\n \nfileMD5\n \n=\n \nMD5\n.\nhash\n(\nfileData\n)\n\n\n\n// SHA1 with `ByteBuffer`\n\n\nlet\n \nfileBuffer\n:\n \nByteBuffer\n \n=\n \n...\n\n\nlet\n \nfileSHA1\n \n=\n \nSHA1\n.\nhash\n(\nfileBuffer\n)\n\n\n\n// SHA2 variants with String\n\n\nlet\n \nstaticUnsafeToken\n:\n \nString\n \n=\n \nrsadd14ndmasidfm12i4j\n\n\n\nlet\n \ntokenHashSHA224\n \n=\n \nSHA224\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA256\n \n=\n \nSHA256\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA384\n \n=\n \nSHA384\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA512\n \n=\n \nSHA512\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\n\n\n\n\nIncremental hashes (manual)\n\n\nTo incrementally process hashes you can create an instance of the Hash. This will set up a context.\n\n\nAll hash context initializers are empty:\n\n\n// Create an MD5 context\n\n\nlet\n \nmd5Context\n \n=\n \nMD5\n()\n\n\n\n\n\n\nTo process a single chunk of data, you can call the \nupdate\n function on a context using any \nSequence\n of \nUInt8\n. That means \nArray\n, \nData\n and \nByteBuffer\n work alongside any other sequence of bytes.\n\n\nmd5Context\n.\nupdate\n(\ndata\n)\n\n\n\n\n\n\nThe data data need not be a specific length. Any length works.\n\n\nWhen you need the result, you can call \nmd5Context.finalize()\n. This will finish calculating the hash by appending the standard \n1\n bit, padding and message bitlength.\n\n\nYou can optionally provide a last set of data to \nfinalize()\n.\n\n\nAfter calling \nfinalize()\n, do not update the hash if you want correct results.\n\n\nFetching the results\n\n\nThe context can then be accessed to extract the resulting Hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nmd5Context\n.\nhash\n\n\n\n\n\n\nStreaming hashes (Async)\n\n\nSometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use \nStreamHasher\n.\n\n\nFirst, create a new generic \nStreamHasher\nHash\n where \nHash\n is the hash you want to use. In this case, SHA512.\n\n\nlet\n \nstreamHasher\n \n=\n \nStreamHasher\nSHA512\n()\n\n\n\n\n\n\nThis stream works like any \ninputStream\n by consuming the incoming data and passing the buffers to the hash context.\n\n\nFor example, draining a TCP socket.\n\n\nlet\n \nsocket\n:\n \nTCP\n.\nSocket\n \n=\n \n...\n\n\n\nsocket\n.\ndrain\n(\ninto\n:\n \nstreamHasher\n)\n\n\n\n\n\n\nThis will incrementally update the hash using the provided TCP socket's data.\n\n\nWhen the hash has been completely accumulated, you can \ncomplete\n the hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nstreamHasher\n.\ncomplete\n()\n\n\n\n\n\n\nThis will reset the hash's context to the default configuration, ready to start over.\n\n\nUsing StreamHasher as a transparent component\n\n\nStreamHasher is only an \nInputStream\n, meaning it doesn't output anything. In some scenarios, like uploading a file, you want both the unaltered file data in addition to the hash. One solution is to split the stream. But that adds unnecessary complexity.\n\n\nPassthroughByteStreamHasher\n is a \nByteStreamHasher\n that's also an \nOutputStream\n. The output it emits is identical to the \nPassthroughByteStreamHasher\n's input.\n\n\nPassthroughByteStreamHasher\n functions exactly like \nByteStreamHasher", 
            "title": "Hashes"
        }, 
        {
            "location": "/crypto/hash/#hash", 
            "text": "Hashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.", 
            "title": "Hash"
        }, 
        {
            "location": "/crypto/hash/#available-hashes", 
            "text": "Crypto currently supports a few hashes.   MD5  SHA1  SHA2 (all variants)   MD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.  Every Hash type has a set of helpers that you can use.", 
            "title": "Available hashes"
        }, 
        {
            "location": "/crypto/hash/#hashing-blobs-of-data", 
            "text": "Every  Hash  has a static method called  hash  that can be used for hashing the entire contents of  Foundation.Data ,  ByteBuffer  or  String .  The result is  Data  containing the resulting hash. The hash's length is according to spec and defined in the static variable  digestSize .  // MD5 with `Data`  let   fileData   =   Data ()  let   fileMD5   =   MD5 . hash ( fileData )  // SHA1 with `ByteBuffer`  let   fileBuffer :   ByteBuffer   =   ...  let   fileSHA1   =   SHA1 . hash ( fileBuffer )  // SHA2 variants with String  let   staticUnsafeToken :   String   =   rsadd14ndmasidfm12i4j  let   tokenHashSHA224   =   SHA224 . hash ( staticUnsafeToken )  let   tokenHashSHA256   =   SHA256 . hash ( staticUnsafeToken )  let   tokenHashSHA384   =   SHA384 . hash ( staticUnsafeToken )  let   tokenHashSHA512   =   SHA512 . hash ( staticUnsafeToken )", 
            "title": "Hashing blobs of data"
        }, 
        {
            "location": "/crypto/hash/#incremental-hashes-manual", 
            "text": "To incrementally process hashes you can create an instance of the Hash. This will set up a context.  All hash context initializers are empty:  // Create an MD5 context  let   md5Context   =   MD5 ()   To process a single chunk of data, you can call the  update  function on a context using any  Sequence  of  UInt8 . That means  Array ,  Data  and  ByteBuffer  work alongside any other sequence of bytes.  md5Context . update ( data )   The data data need not be a specific length. Any length works.  When you need the result, you can call  md5Context.finalize() . This will finish calculating the hash by appending the standard  1  bit, padding and message bitlength.  You can optionally provide a last set of data to  finalize() .  After calling  finalize() , do not update the hash if you want correct results.", 
            "title": "Incremental hashes (manual)"
        }, 
        {
            "location": "/crypto/hash/#fetching-the-results", 
            "text": "The context can then be accessed to extract the resulting Hash.  let   hash :   Data   =   md5Context . hash", 
            "title": "Fetching the results"
        }, 
        {
            "location": "/crypto/hash/#streaming-hashes-async", 
            "text": "Sometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use  StreamHasher .  First, create a new generic  StreamHasher Hash  where  Hash  is the hash you want to use. In this case, SHA512.  let   streamHasher   =   StreamHasher SHA512 ()   This stream works like any  inputStream  by consuming the incoming data and passing the buffers to the hash context.  For example, draining a TCP socket.  let   socket :   TCP . Socket   =   ...  socket . drain ( into :   streamHasher )   This will incrementally update the hash using the provided TCP socket's data.  When the hash has been completely accumulated, you can  complete  the hash.  let   hash :   Data   =   streamHasher . complete ()   This will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Streaming hashes (Async)"
        }, 
        {
            "location": "/crypto/hash/#using-streamhasher-as-a-transparent-component", 
            "text": "StreamHasher is only an  InputStream , meaning it doesn't output anything. In some scenarios, like uploading a file, you want both the unaltered file data in addition to the hash. One solution is to split the stream. But that adds unnecessary complexity.  PassthroughByteStreamHasher  is a  ByteStreamHasher  that's also an  OutputStream . The output it emits is identical to the  PassthroughByteStreamHasher 's input.  PassthroughByteStreamHasher  functions exactly like  ByteStreamHasher", 
            "title": "Using StreamHasher as a transparent component"
        }, 
        {
            "location": "/crypto/mac/", 
            "text": "Message authentication\n\n\nMessage authentication is used for verifying message authenticity and validity.\n\n\nCommon use cases are JSON Web Tokens.\n\n\nFor message authentication, Vapor only supports HMAC.\n\n\nUsing HMAC\n\n\nTo use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.\n\n\nlet\n \nhash\n \n=\n \nHMAC\nSHA224\n.\nauthenticate\n(\nmessage\n,\n \nwithKey\n:\n \nauthenticationKey\n)", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#message-authentication", 
            "text": "Message authentication is used for verifying message authenticity and validity.  Common use cases are JSON Web Tokens.  For message authentication, Vapor only supports HMAC.", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#using-hmac", 
            "text": "To use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.  let   hash   =   HMAC SHA224 . authenticate ( message ,   withKey :   authenticationKey )", 
            "title": "Using HMAC"
        }, 
        {
            "location": "/crypto/passwords/", 
            "text": "Password hashing\n\n\nPassword management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.\n\n\nFor password hashing Vapor supports PBKDF2 and BCrypt.\n\n\nWe recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.\n\n\nBCrypt\n\n\nBCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.\n\n\nDeriving a key\n\n\nUnlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.\n\n\nThe output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.\n\n\nlet\n \nresult\n:\n \nData\n \n=\n \ntry\n \nBCrypt\n.\nmake\n(\nmessage\n:\n \nMyPassword\n)\n\n\n\nguard\n \ntry\n \nBCrypt\n.\nverify\n(\nmessage\n:\n \nMyPassword\n,\n \nmatches\n:\n \nresult\n)\n \nelse\n \n{\n\n    \nfatalError\n(\nThis never triggers, since the verification process will always be successful for the same password and conditions\n)\n\n\n}\n\n\n\n\n\n\nThe default cost factor is \n12\n, based on the official recommendations.\n\n\nStoring the derived key as a String\n\n\nBCrypt always outputs valid ASCII/UTF-8 for the resulting hash.\n\n\nThis means you can convert the output \nData\n to a \nString\n as such:\n\n\nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nresult\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n    \n// This must never trigger\n\n\n}\n\n\n\n\n\n\nPBKDF2\n\n\nPBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.\n\n\nPBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.\n\n\nFor PBKDF2 you also select the Hash using generics.\n\n\nDeriving a key\n\n\nIn the following example:\n\n\n\n\npassword\n is either a \nString\n or \nData\n\n\nThe \nsalt\n is \nData\n\n\nIterations is defaulted to \n10_000\n iterations\n\n\nThe keySize is equivalent to 1 hash's length.\n\n\n\n\n// Generate a random salt\n\n\nlet\n \nsalt\n:\n \nData\n \n=\n \nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n)\n\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n)\n\n\n\n\n\n\nYou can optionally configure PBKDF2 to use a different iteration count and output keysize.\n\n\n// Iterates 20\n000 times and outputs 100 bytes\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n,\n \niterating\n:\n \n20_000\n,\n \nderivedKeyLength\n:\n \n100\n)\n\n\n\n\n\n\nStoring the results\n\n\nWhen you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#password-hashing", 
            "text": "Password management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.  For password hashing Vapor supports PBKDF2 and BCrypt.  We recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#bcrypt", 
            "text": "BCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.", 
            "title": "BCrypt"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key", 
            "text": "Unlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.  The output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.  let   result :   Data   =   try   BCrypt . make ( message :   MyPassword )  guard   try   BCrypt . verify ( message :   MyPassword ,   matches :   result )   else   { \n     fatalError ( This never triggers, since the verification process will always be successful for the same password and conditions )  }   The default cost factor is  12 , based on the official recommendations.", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-derived-key-as-a-string", 
            "text": "BCrypt always outputs valid ASCII/UTF-8 for the resulting hash.  This means you can convert the output  Data  to a  String  as such:  guard   let   string   =   String ( bytes :   result ,   encoding :   . utf8 )   else   { \n     // This must never trigger  }", 
            "title": "Storing the derived key as a String"
        }, 
        {
            "location": "/crypto/passwords/#pbkdf2", 
            "text": "PBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.  PBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.  For PBKDF2 you also select the Hash using generics.", 
            "title": "PBKDF2"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key_1", 
            "text": "In the following example:   password  is either a  String  or  Data  The  salt  is  Data  Iterations is defaulted to  10_000  iterations  The keySize is equivalent to 1 hash's length.   // Generate a random salt  let   salt :   Data   =   OSRandom (). data ( count :   32 )  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt )   You can optionally configure PBKDF2 to use a different iteration count and output keysize.  // Iterates 20 000 times and outputs 100 bytes  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt ,   iterating :   20_000 ,   derivedKeyLength :   100 )", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-results", 
            "text": "When you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Storing the results"
        }, 
        {
            "location": "/crypto/random/", 
            "text": "Random\n\n\nCrypto has two primary random number generators.\n\n\nOSRandom generates random numbers by calling the operating system's random number generator.\n\n\nURandom generates random numbers by reading from \n/dev/urandom\n.\n\n\nAccessing random numbers\n\n\nFirst, create an instance of the preferred random number generator:\n\n\nlet\n \nrandom\n \n=\n \nOSRandom\n()\n\n\n\n\n\n\nor\n\n\nlet\n \nrandom\n \n=\n \ntry\n \nURandom\n()\n\n\n\n\n\n\nReading integers\n\n\nFor every Swift integer a random number function exists.\n\n\nlet\n \nint8\n:\n \nInt8\n \n=\n \ntry\n \nrandom\n.\nmakeInt8\n()\n\n\nlet\n \nuint8\n:\n \nUInt8\n \n=\n \ntry\n \nrandom\n.\nmakeUInt8\n()\n\n\nlet\n \nint16\n:\n \nInt16\n \n=\n \ntry\n \nrandom\n.\nmakeInt16\n()\n\n\nlet\n \nuint16\n:\n \nUInt16\n \n=\n \ntry\n \nrandom\n.\nmakeUInt16\n()\n\n\nlet\n \nint32\n:\n \nInt32\n \n=\n \ntry\n \nrandom\n.\nmakeInt32\n()\n\n\nlet\n \nuint32\n:\n \nUInt32\n \n=\n \ntry\n \nrandom\n.\nmakeUInt32\n()\n\n\nlet\n \nint64\n:\n \nInt64\n \n=\n \ntry\n \nrandom\n.\nmakeInt64\n()\n\n\nlet\n \nuint64\n:\n \nUInt64\n \n=\n \ntry\n \nrandom\n.\nmakeUInt64\n()\n\n\nlet\n \nint\n:\n \nInt\n \n=\n \ntry\n \nrandom\n.\nmakeInt\n()\n\n\nlet\n \nuint\n:\n \nUInt\n \n=\n \ntry\n \nrandom\n.\nmakeUInt\n()\n\n\n\n\n\n\nReading random data\n\n\nRandom buffers of data are useful when, for example, generating tokens or other unique strings/blobs.\n\n\nTo generate a buffer of random data:\n\n\n// generates 20 random bytes\n\n\nlet\n \ndata\n:\n \nData\n \n=\n \nrandom\n.\ndata\n(\ncount\n:\n \n20\n)", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#random", 
            "text": "Crypto has two primary random number generators.  OSRandom generates random numbers by calling the operating system's random number generator.  URandom generates random numbers by reading from  /dev/urandom .", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#accessing-random-numbers", 
            "text": "First, create an instance of the preferred random number generator:  let   random   =   OSRandom ()   or  let   random   =   try   URandom ()", 
            "title": "Accessing random numbers"
        }, 
        {
            "location": "/crypto/random/#reading-integers", 
            "text": "For every Swift integer a random number function exists.  let   int8 :   Int8   =   try   random . makeInt8 ()  let   uint8 :   UInt8   =   try   random . makeUInt8 ()  let   int16 :   Int16   =   try   random . makeInt16 ()  let   uint16 :   UInt16   =   try   random . makeUInt16 ()  let   int32 :   Int32   =   try   random . makeInt32 ()  let   uint32 :   UInt32   =   try   random . makeUInt32 ()  let   int64 :   Int64   =   try   random . makeInt64 ()  let   uint64 :   UInt64   =   try   random . makeUInt64 ()  let   int :   Int   =   try   random . makeInt ()  let   uint :   UInt   =   try   random . makeUInt ()", 
            "title": "Reading integers"
        }, 
        {
            "location": "/crypto/random/#reading-random-data", 
            "text": "Random buffers of data are useful when, for example, generating tokens or other unique strings/blobs.  To generate a buffer of random data:  // generates 20 random bytes  let   data :   Data   =   random . data ( count :   20 )", 
            "title": "Reading random data"
        }, 
        {
            "location": "/tls/package/", 
            "text": "TLS\n\n\nThe TLS packages allow writing TLS/SSL clients and servers.\n\n\nIndex\n\n\n\n\nClient\n\n\n\n\nPackage.swift\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/mysql.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nMySQL\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport MySQL\n to access MySQL' APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/tls/package/#tls", 
            "text": "The TLS packages allow writing TLS/SSL clients and servers.", 
            "title": "TLS"
        }, 
        {
            "location": "/tls/package/#index", 
            "text": "Client", 
            "title": "Index"
        }, 
        {
            "location": "/tls/package/#packageswift", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/mysql.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ MySQL ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import MySQL  to access MySQL' APIs.", 
            "title": "Package.swift"
        }, 
        {
            "location": "/tls/client/", 
            "text": "", 
            "title": "Client"
        }, 
        {
            "location": "/sockets/package/", 
            "text": "Using Sockets\n\n\nSockets is a library containing all Socket related APIs.\n\n\nIndex\n\n\n\n\nTCP Socket\n\n\nTCP Client\n\n\nTCP Server\n\n\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nSockets\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/sockets.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nSockets\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport Sockets\n to access Sockets's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/sockets/package/#using-sockets", 
            "text": "Sockets is a library containing all Socket related APIs.", 
            "title": "Using Sockets"
        }, 
        {
            "location": "/sockets/package/#index", 
            "text": "TCP Socket  TCP Client  TCP Server", 
            "title": "Index"
        }, 
        {
            "location": "/sockets/package/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Sockets", 
            "title": "With Vapor"
        }, 
        {
            "location": "/sockets/package/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/sockets.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Sockets ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import Sockets  to access Sockets's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/sockets/tcp-client/", 
            "text": "TCP Clients\n\n\nSockets are a connection to another endpoint. They're usually connected to the internet, but may also run over a VPN or the local loopback (to your own computer). Sockets in Vapor currently only support asynchronous TCP sockets.\n\n\nCreating and connecting a socket\n\n\nThe first step is to create a new socket.\n\n\nlet\n \nsocket\n \n=\n \ntry\n \nSocket\n()\n\n\n\n\n\n\nThis socket is not connected to anything yet. To connect it you need to call the \nconnect\n function with a hostname and port.\n\n\ntry\n \nsocket\n.\nconnect\n(\nhostname\n:\n \nexample.com\n,\n \nport\n:\n \n80\n)\n\n\n\n\n\n\nAfter connecting, your socket may not be ready yet. Since this socket is asynchronous, the \nconnect\n phase may not be over yet.\n\n\nYou'll have to add a \nwritable\n notification to a queue. This queue \nmust\n be the current queue you're working on. \nMore about this here.\n\n\nlet\n \nconnectedNotification\n \n=\n \ntry\n \nsocket\n.\nwritable\n(\nqueue\n:\n \nworker\n.\nqueue\n)\n \n// Future\nVoid\n\n\n\n\n\n\nAt this point, a successful client socket has been created. You can either \ninteract with sockets manually\n or continue using the \nTCPClient\n helpers. In the second case, continue reading this article and wrap the socket.\n\n\nlet\n \nclient\n \n=\n \nTCPClient\n(\nsocket\n:\n \nsocket\n,\n \nworker\n:\n \nworker\n)\n\n\n\n\n\n\nCommunicating\n\n\nNow that your socket is connected you can start communicating. First, you'll need to start by setting up the handlers for incoming data.\n\n\nSince \nTCPClient\n is a stream, you can use \nthe introduction\n of streams for reading the socket's output (incoming data).\n\n\nSending data is done through the \ninputStream\n function.\n\n\nclient\n.\ninputStream\n(\ndata\n)\n \n// Sends `Data`\n\n\n\n\n\n\nThis accepts \nByteBuffer\n, \nData\n and \nDispatchData\n. Chaining streams into this \nTCPClient\n, however, requires a \nByteBuffer\n.\n\n\nOnce your client is all set up, \nstart()\n reading.\n\n\nclient\n.\nstart\n()", 
            "title": "TCP Client"
        }, 
        {
            "location": "/sockets/tcp-client/#tcp-clients", 
            "text": "Sockets are a connection to another endpoint. They're usually connected to the internet, but may also run over a VPN or the local loopback (to your own computer). Sockets in Vapor currently only support asynchronous TCP sockets.", 
            "title": "TCP Clients"
        }, 
        {
            "location": "/sockets/tcp-client/#creating-and-connecting-a-socket", 
            "text": "The first step is to create a new socket.  let   socket   =   try   Socket ()   This socket is not connected to anything yet. To connect it you need to call the  connect  function with a hostname and port.  try   socket . connect ( hostname :   example.com ,   port :   80 )   After connecting, your socket may not be ready yet. Since this socket is asynchronous, the  connect  phase may not be over yet.  You'll have to add a  writable  notification to a queue. This queue  must  be the current queue you're working on.  More about this here.  let   connectedNotification   =   try   socket . writable ( queue :   worker . queue )   // Future Void   At this point, a successful client socket has been created. You can either  interact with sockets manually  or continue using the  TCPClient  helpers. In the second case, continue reading this article and wrap the socket.  let   client   =   TCPClient ( socket :   socket ,   worker :   worker )", 
            "title": "Creating and connecting a socket"
        }, 
        {
            "location": "/sockets/tcp-client/#communicating", 
            "text": "Now that your socket is connected you can start communicating. First, you'll need to start by setting up the handlers for incoming data.  Since  TCPClient  is a stream, you can use  the introduction  of streams for reading the socket's output (incoming data).  Sending data is done through the  inputStream  function.  client . inputStream ( data )   // Sends `Data`   This accepts  ByteBuffer ,  Data  and  DispatchData . Chaining streams into this  TCPClient , however, requires a  ByteBuffer .  Once your client is all set up,  start()  reading.  client . start ()", 
            "title": "Communicating"
        }, 
        {
            "location": "/sockets/tcp-server/", 
            "text": "TODO", 
            "title": "TCP Server"
        }, 
        {
            "location": "/sockets/tcp-socket/", 
            "text": "TODO", 
            "title": "TCP Socket"
        }, 
        {
            "location": "/testing/getting-started/", 
            "text": "Testing\n\n\nTODO", 
            "title": "Getting Started"
        }, 
        {
            "location": "/testing/getting-started/#testing", 
            "text": "TODO", 
            "title": "Testing"
        }, 
        {
            "location": "/security/", 
            "text": "Security\n\n\nSecurity is a critical part of any software and comes in many forms.\n\n\nIt is always important to understand some basics of security. Vapor 3 is designed to be secure by default and has many tools to support building secure applications.\n\n\nRecommended information\n\n\n\n\nPassword management\n\n\nJWT (Session) Tokens\n\n\n\n\nAdditional information\n\n\n\n\nDenial of Service prevention", 
            "title": "Index"
        }, 
        {
            "location": "/security/#security", 
            "text": "Security is a critical part of any software and comes in many forms.  It is always important to understand some basics of security. Vapor 3 is designed to be secure by default and has many tools to support building secure applications.", 
            "title": "Security"
        }, 
        {
            "location": "/security/#recommended-information", 
            "text": "Password management  JWT (Session) Tokens", 
            "title": "Recommended information"
        }, 
        {
            "location": "/security/#additional-information", 
            "text": "Denial of Service prevention", 
            "title": "Additional information"
        }, 
        {
            "location": "/security/dos/", 
            "text": "Denial of Service\n\n\nDenial of Service attacks are common and often easy to execute. They come in a few major categories.\nMost of the attacks can be countered by an application. This document outlines how Vapor 3 is designed against these attacks and how you can make use of the tools available.\n\n\nMemory buffer attacks\n\n\nMemory buffer attacks are achieved by draining the amount of memory a server has available.\n\n\nOne example in HTTP/1 is by sending an arbitrarily large POST data containing any data. The server might accept the data for an indefinite period of time causing the memory to fill up and the application to meet the hardware or virtual machine limits. This can cause swapping, a crash or both.\n\n\nA second example exploits the same principle in WebSockets, where the protocol allows sending data up to \nUInt64.max\n.\n\n\nSolution 1\n\n\nLimit the maximum amount of data on protocol level, rejecting any requests exceeding the limit. The follow-up behaviour of the server can be either closing the connection or returning a \"Bad Request\" response.\n\n\nSolution 2\n\n\nHTTP/2 is a protocol designed against these attacks. Hosting HTTP/2 as the protocol of choice can improve performance and reduce attack vectors in many ways.\n\n\nSolution 3\n\n\nNGINX is commonly used as a proxy between the public internet and an application such as a Vapor based application. Setting up a \"reverse-proxy\" can prevent a lot of attacks before they reach your application server.\n\n\nOpening many of connections\n\n\nOpening many (hundreds or thousands) connections to a server is really heavy. There are two attacks that can follow.\n\n\n\n\nSending a lot of data really quickly\n\n\nSending very little data, very slowly.\n\n\n\n\nThe first attack targets network bandwidth, and the second attack targets the CPU.\n\n\nBoth are (partially) prevented by default using the \nPeerValidator\n which is part of the \nServerSecurity\n module which is included with the Vapor framework. It is enabled by default as part of the \nEngineServer\n but needs to be added manually for other HTTP servers.\n\n\nHow PeerValidator works\n\n\nAs part of Vapor 3's design goals, all notification-like I/O is implemented using \nStreams\n. This also includes the \nTCP Server\n. The TCP server is seen as a stream of clients/peers that are accepted and then sent to the client. It has a hook called \nwillAccept\n. This closure's input is a \nTCPClient\n, and the output is a \nBool\n. If the returned boolean is \ntrue\n, the peer will be accepted where \nfalse\n will deny the peer and will close the connection.\n\n\nPeerValidator\n hooks into this capability by looking the peer's address up in it's cache and keeps track of the amount of connections this peer has currently opened to this server. If the counter exceeds a threshold as specified in the \nPeerValidator\n initializer, the connection will be rejected.\n\n\nUsing PeerValidator\n\n\nPeerValidator's \nwillAccept\n function can be hooked into the TCPServer's \nwillAccept\n.\n\n\nlet\n \nvalidator\n \n=\n \nPeerValidator\n(\nmaxConnectionsPerIP\n:\n \n100\n)\n\n\n\ntcpServer\n.\nwillAccept\n \n=\n \nvalidator\n.\nwillAccept", 
            "title": "Denial of Service"
        }, 
        {
            "location": "/security/dos/#denial-of-service", 
            "text": "Denial of Service attacks are common and often easy to execute. They come in a few major categories.\nMost of the attacks can be countered by an application. This document outlines how Vapor 3 is designed against these attacks and how you can make use of the tools available.", 
            "title": "Denial of Service"
        }, 
        {
            "location": "/security/dos/#memory-buffer-attacks", 
            "text": "Memory buffer attacks are achieved by draining the amount of memory a server has available.  One example in HTTP/1 is by sending an arbitrarily large POST data containing any data. The server might accept the data for an indefinite period of time causing the memory to fill up and the application to meet the hardware or virtual machine limits. This can cause swapping, a crash or both.  A second example exploits the same principle in WebSockets, where the protocol allows sending data up to  UInt64.max .", 
            "title": "Memory buffer attacks"
        }, 
        {
            "location": "/security/dos/#solution-1", 
            "text": "Limit the maximum amount of data on protocol level, rejecting any requests exceeding the limit. The follow-up behaviour of the server can be either closing the connection or returning a \"Bad Request\" response.", 
            "title": "Solution 1"
        }, 
        {
            "location": "/security/dos/#solution-2", 
            "text": "HTTP/2 is a protocol designed against these attacks. Hosting HTTP/2 as the protocol of choice can improve performance and reduce attack vectors in many ways.", 
            "title": "Solution 2"
        }, 
        {
            "location": "/security/dos/#solution-3", 
            "text": "NGINX is commonly used as a proxy between the public internet and an application such as a Vapor based application. Setting up a \"reverse-proxy\" can prevent a lot of attacks before they reach your application server.", 
            "title": "Solution 3"
        }, 
        {
            "location": "/security/dos/#opening-many-of-connections", 
            "text": "Opening many (hundreds or thousands) connections to a server is really heavy. There are two attacks that can follow.   Sending a lot of data really quickly  Sending very little data, very slowly.   The first attack targets network bandwidth, and the second attack targets the CPU.  Both are (partially) prevented by default using the  PeerValidator  which is part of the  ServerSecurity  module which is included with the Vapor framework. It is enabled by default as part of the  EngineServer  but needs to be added manually for other HTTP servers.", 
            "title": "Opening many of connections"
        }, 
        {
            "location": "/security/dos/#how-peervalidator-works", 
            "text": "As part of Vapor 3's design goals, all notification-like I/O is implemented using  Streams . This also includes the  TCP Server . The TCP server is seen as a stream of clients/peers that are accepted and then sent to the client. It has a hook called  willAccept . This closure's input is a  TCPClient , and the output is a  Bool . If the returned boolean is  true , the peer will be accepted where  false  will deny the peer and will close the connection.  PeerValidator  hooks into this capability by looking the peer's address up in it's cache and keeps track of the amount of connections this peer has currently opened to this server. If the counter exceeds a threshold as specified in the  PeerValidator  initializer, the connection will be rejected.", 
            "title": "How PeerValidator works"
        }, 
        {
            "location": "/security/dos/#using-peervalidator", 
            "text": "PeerValidator's  willAccept  function can be hooked into the TCPServer's  willAccept .  let   validator   =   PeerValidator ( maxConnectionsPerIP :   100 )  tcpServer . willAccept   =   validator . willAccept", 
            "title": "Using PeerValidator"
        }, 
        {
            "location": "/supplementary/architecture/", 
            "text": "TODO", 
            "title": "Architecture"
        }, 
        {
            "location": "/supplementary/performance/", 
            "text": "TODO", 
            "title": "Performance"
        }, 
        {
            "location": "/version/1_5/", 
            "text": "Redirecting...", 
            "title": "1.5"
        }, 
        {
            "location": "/version/1_5/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/2_0/", 
            "text": "Redirecting...", 
            "title": "2.0"
        }, 
        {
            "location": "/version/2_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/3_0/", 
            "text": "Redirecting...", 
            "title": "3.0-alpha"
        }, 
        {
            "location": "/version/3_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/support/", 
            "text": "Version Support\n\n\n\n\nVapor 3.0 is currently in beta.\n\n\nVapor 2.0 is currently active.\n\n\nVapor 1.5 is being maintained until November 2017.\n\n\n\n\nWarning\n\n\nDashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.\n\n\n\n\nCore\n\n\nAll packages in the \nVapor GitHub\n are maintained according to the following rules.\n\n\nActive\n\n\nWhile a version is active, reported security issues and bugs are fixed.\n\n\nAdditionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.\n\n\nMaintenance\n\n\nWhen a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.\n\n\n\n\nNote\n\n\nOnly the latest minor version will be maintained.\n\n\n\n\nUnstable\n\n\nThe master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.\n\n\nCommunity\n\n\nAll packages in the \nVapor Community GitHub\n are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Support"
        }, 
        {
            "location": "/version/support/#version-support", 
            "text": "Vapor 3.0 is currently in beta.  Vapor 2.0 is currently active.  Vapor 1.5 is being maintained until November 2017.   Warning  Dashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.", 
            "title": "Version Support"
        }, 
        {
            "location": "/version/support/#core", 
            "text": "All packages in the  Vapor GitHub  are maintained according to the following rules.", 
            "title": "Core"
        }, 
        {
            "location": "/version/support/#active", 
            "text": "While a version is active, reported security issues and bugs are fixed.  Additionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.", 
            "title": "Active"
        }, 
        {
            "location": "/version/support/#maintenance", 
            "text": "When a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.   Note  Only the latest minor version will be maintained.", 
            "title": "Maintenance"
        }, 
        {
            "location": "/version/support/#unstable", 
            "text": "The master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.", 
            "title": "Unstable"
        }, 
        {
            "location": "/version/support/#community", 
            "text": "All packages in the  Vapor Community GitHub  are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Community"
        }
    ]
}