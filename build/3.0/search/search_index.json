{
    "docs": [
        {
            "location": "/", 
            "text": "Vapor Documentation\n\n\nThis is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.\n\n\nVapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.\n\n\nGetting Started\n\n\nIf this is your first time using Vapor, head to the \nInstall \n macOS\n section to install Swift and Vapor.\n\n\nOnce you have Vapor installed, check out \nGetting Started \n Hello, world\n to create your first Vapor app!\n\n\nLike Vapor?\n\n\nOur small team works hard to make Vapor awesome (and free). Support the framework by \nstarring Vapor on GitHub\n\nor \ndonating $1 monthly\nit helps us a lot. Thanks!\n\n\nOther Sources\n\n\nHere are some other great places to find information about Vapor.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\nlink\n\n\n\n\n\n\n\n\n\n\nVapor Slack\n\n\nChat with ~5,000 Vapor developers.\n\n\nvisit \n\n\n\n\n\n\nAPI docs\n\n\nAuto-generated documentation from code comments.\n\n\nvisit \n\n\n\n\n\n\nStack Overflow\n\n\nAsk and answer questions with the \nvapor\n tag.\n\n\nvisit \n\n\n\n\n\n\nSource Code\n\n\nLearn how Vapor works under the hood.\n\n\nvisit \n\n\n\n\n\n\nGitHub Issues\n\n\nReport bugs or request features on GitHub.\n\n\nvisit \n\n\n\n\n\n\n\n\nProviders\n\n\nVapor providers are a convenient way to add functionality to your Vapor projects.\nFor a full list of providers, check out the \nvapor-provider\n tag on GitHub.\n\n\nAuthors\n\n\nTanner Nelson\n, \nLogan Wright\n, \nJoannis Orlandos\n, and the hundreds of members of Vapor.", 
            "title": "Overview"
        }, 
        {
            "location": "/#vapor-documentation", 
            "text": "This is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.  Vapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.", 
            "title": "Vapor Documentation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "If this is your first time using Vapor, head to the  Install   macOS  section to install Swift and Vapor.  Once you have Vapor installed, check out  Getting Started   Hello, world  to create your first Vapor app!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#like-vapor", 
            "text": "Our small team works hard to make Vapor awesome (and free). Support the framework by  starring Vapor on GitHub \nor  donating $1 monthly it helps us a lot. Thanks!", 
            "title": "Like Vapor?"
        }, 
        {
            "location": "/#other-sources", 
            "text": "Here are some other great places to find information about Vapor.     name  description  link      Vapor Slack  Chat with ~5,000 Vapor developers.  visit     API docs  Auto-generated documentation from code comments.  visit     Stack Overflow  Ask and answer questions with the  vapor  tag.  visit     Source Code  Learn how Vapor works under the hood.  visit     GitHub Issues  Report bugs or request features on GitHub.  visit", 
            "title": "Other Sources"
        }, 
        {
            "location": "/#providers", 
            "text": "Vapor providers are a convenient way to add functionality to your Vapor projects.\nFor a full list of providers, check out the  vapor-provider  tag on GitHub.", 
            "title": "Providers"
        }, 
        {
            "location": "/#authors", 
            "text": "Tanner Nelson ,  Logan Wright ,  Joannis Orlandos , and the hundreds of members of Vapor.", 
            "title": "Authors"
        }, 
        {
            "location": "/install/macos/", 
            "text": "Install on macOS\n\n\nTo use Vapor on macOS, you just need to have Xcode 9 or greater installed.\n\n\n\n\nTip\n\n\nYou need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.\n\n\n\n\nInstall Xcode\n\n\nInstall \nXcode 9 or greater\n from the Mac App Store.\n\n\n\n\n\n\nWarning\n\n\nAfter Xcode has been downloaded, you must open it to finish the installation. This may take a while.\n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nInstall Vapor\n\n\nNow that you have Swift 4, let's install the \nVapor Toolbox\n.\n\n\nThe toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.\n\n\nbrew install vapor/tap/vapor\n\n\n\n\n\n\n\nTip\n\n\nIf you don't already have Homebrew installed, install it at \nbrew.sh \n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.", 
            "title": "macOS"
        }, 
        {
            "location": "/install/macos/#install-on-macos", 
            "text": "To use Vapor on macOS, you just need to have Xcode 9 or greater installed.   Tip  You need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.", 
            "title": "Install on macOS"
        }, 
        {
            "location": "/install/macos/#install-xcode", 
            "text": "Install  Xcode 9 or greater  from the Mac App Store.    Warning  After Xcode has been downloaded, you must open it to finish the installation. This may take a while.", 
            "title": "Install Xcode"
        }, 
        {
            "location": "/install/macos/#verify-installation", 
            "text": "Double check the installation was successful by opening Terminal and running:  swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#install-vapor", 
            "text": "Now that you have Swift 4, let's install the  Vapor Toolbox .  The toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.  brew install vapor/tap/vapor   Tip  If you don't already have Homebrew installed, install it at  brew.sh", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/macos/#verify-installation_1", 
            "text": "Double check the installation was successful by opening Terminal and running:  vapor --help  You should see a long list of available commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/", 
            "text": "Install on Ubuntu\n\n\nInstalling Vapor on Ubuntu only takes a couple of minutes.\n\n\nSupported\n\n\nVapor supports the same versions of Ubuntu that Swift supports.\n\n\n\n\n\n\n\n\nVersion\n\n\nCodename\n\n\n\n\n\n\n\n\n\n\n16.10\n\n\nYakkety Yak\n\n\n\n\n\n\n16.04\n\n\nXenial Xerus\n\n\n\n\n\n\n14.04\n\n\nTrusty Tahr\n\n\n\n\n\n\n\n\nAPT Repo\n\n\nAdd Vapor's APT repo to get access to all of Vapor's Ubuntu packages.\n\n\nQuick Script\n\n\nEasily add Vapor's APT repo with this handy script.\n\n\neval\n \n$(\ncurl -sL https://apt.vapor.sh\n)\n\n\n\n\n\n\n\n\nTip\n\n\nThis command requires \ncurl\n which can be installed using \nsudo apt-get install curl\n\n\n\n\nDockerfile\n\n\nWhen configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:\n\n\nRUN /bin/bash -c \n$(\nwget -qO- https://apt.vapor.sh\n)\n\n\n\n\n\n\nManual\n\n\nOr add the repo manually.\n\n\nwget -q https://repo.vapor.codes/apt/keyring.gpg -O- \n|\n sudo apt-key add -\n\necho\n \ndeb https://repo.vapor.codes/apt \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update\n\n\n\n\n\nInstall Vapor\n\n\nNow that you have added Vapor's APT repo, you can install the required dependencies.\n\n\nsudo apt-get install swift vapor\n\n\n\n\n\nVerify Installation\n\n\nDouble check everything worked with the following commands.\n\n\nSwift\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nVapor Toolbox\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.\n\n\nSwift.org\n\n\nCheck out \nSwift.org\n's guide to \nusing downloads\n if you need more detailed instructions for installing Swift 4.", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#install-on-ubuntu", 
            "text": "Installing Vapor on Ubuntu only takes a couple of minutes.", 
            "title": "Install on Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#supported", 
            "text": "Vapor supports the same versions of Ubuntu that Swift supports.     Version  Codename      16.10  Yakkety Yak    16.04  Xenial Xerus    14.04  Trusty Tahr", 
            "title": "Supported"
        }, 
        {
            "location": "/install/ubuntu/#apt-repo", 
            "text": "Add Vapor's APT repo to get access to all of Vapor's Ubuntu packages.", 
            "title": "APT Repo"
        }, 
        {
            "location": "/install/ubuntu/#quick-script", 
            "text": "Easily add Vapor's APT repo with this handy script.  eval   $( curl -sL https://apt.vapor.sh )    Tip  This command requires  curl  which can be installed using  sudo apt-get install curl", 
            "title": "Quick Script"
        }, 
        {
            "location": "/install/ubuntu/#dockerfile", 
            "text": "When configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:  RUN /bin/bash -c  $( wget -qO- https://apt.vapor.sh )", 
            "title": "Dockerfile"
        }, 
        {
            "location": "/install/ubuntu/#manual", 
            "text": "Or add the repo manually.  wget -q https://repo.vapor.codes/apt/keyring.gpg -O-  |  sudo apt-key add - echo   deb https://repo.vapor.codes/apt  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update", 
            "title": "Manual"
        }, 
        {
            "location": "/install/ubuntu/#install-vapor", 
            "text": "Now that you have added Vapor's APT repo, you can install the required dependencies.  sudo apt-get install swift vapor", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/ubuntu/#verify-installation", 
            "text": "Double check everything worked with the following commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/ubuntu/#swift", 
            "text": "swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Swift"
        }, 
        {
            "location": "/install/ubuntu/#vapor-toolbox", 
            "text": "vapor --help  You should see a long list of available commands.", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/install/ubuntu/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/#swiftorg", 
            "text": "Check out  Swift.org 's guide to  using downloads  if you need more detailed instructions for installing Swift 4.", 
            "title": "Swift.org"
        }, 
        {
            "location": "/getting-started/hello-world/", 
            "text": "Hello, world\n\n\nNow that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.\n\n\nNew Project\n\n\nThe first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project \nHello\n.\n\n\nOpen up your terminal, and use \nVapor Toolbox's \nnew\n command.\n\n\nvapor new Hello\n\n\n\n\n\n\n\nWarning\n\n\nMake sure to add \n--branch=beta\n while using Vapor 3 pre-release.\n\n\nIf you receive an error that looks like this:  'Cloning Template [Failed]' then the template you are using is not           yet ready for the beta branch. Try a different template. \n\n\n\n\nOnce that finishes, change into the newly created directory.\n\n\ncd\n Hello\n\n\n\n\n\nGenerate Xcode Project\n\n\nLet's now use the \nVapor Toolbox's \nxcode\n command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.\n\n\nvapor xcode\n\n\n\n\n\nThe toolbox will ask you if you'd like to open Xcode automatically, select \nyes\n.\n\n\nBuild \n Run\n\n\nYou should now have Xcode open and running. Select the \nrun scheme\n from the scheme menu,\nthen click the play button.\n\n\nYou should see the terminal pop up at the bottom of the screen.\n\n\nServer starting on localhost:8080\n\n\n\n\n\nVisit Localhost\n\n\nOpen your web browser, and visit \nlocalhost:8080/hello \n\n\nYou should see the following page.\n\n\nHello, world!\n\n\n\n\n\nCongratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#hello-world", 
            "text": "Now that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#new-project", 
            "text": "The first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project  Hello .  Open up your terminal, and use  Vapor Toolbox's  new  command.  vapor new Hello   Warning  Make sure to add  --branch=beta  while using Vapor 3 pre-release.  If you receive an error that looks like this:  'Cloning Template [Failed]' then the template you are using is not           yet ready for the beta branch. Try a different template.    Once that finishes, change into the newly created directory.  cd  Hello", 
            "title": "New Project"
        }, 
        {
            "location": "/getting-started/hello-world/#generate-xcode-project", 
            "text": "Let's now use the  Vapor Toolbox's  xcode  command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.  vapor xcode  The toolbox will ask you if you'd like to open Xcode automatically, select  yes .", 
            "title": "Generate Xcode Project"
        }, 
        {
            "location": "/getting-started/hello-world/#build-run", 
            "text": "You should now have Xcode open and running. Select the  run scheme  from the scheme menu,\nthen click the play button.  You should see the terminal pop up at the bottom of the screen.  Server starting on localhost:8080", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/hello-world/#visit-localhost", 
            "text": "Open your web browser, and visit  localhost:8080/hello   You should see the following page.  Hello, world!  Congratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Visit Localhost"
        }, 
        {
            "location": "/getting-started/toolbox/", 
            "text": "Install Toolbox\n\n\nVapor's command line interface provides shortcuts and assistance for common tasks.\n\n\n\n\nHelp prints useful information about available commands and flags.\n\n\nvapor --help\n\n\n\n\n\nYou can also run the \n--help\n option on any Toolbox command.\n\n\nvapor new --help\n\n\n\n\n\nThe \n--help\n flag should be your goto for learning about the toolbox as it is the most up-to-date.\n\n\nNew\n\n\nThe Toolbox's most important feature is helping you create a new project.\n\n\nvapor new \nname\n\n\n\n\n\n\nJust pass the name of your project as the first argument to the \nnew\n command.\n\n\n\n\nNote\n\n\nProject names should be \nPascalCase \n, like \nHelloWorld\n or \nMyProject\n.\n\n\n\n\nTemplates\n\n\nBy default, Vapor will create your new project from the API template. You can choose\na different template by passing the \n--template\n flag.\n\n\n\n\n\n\n\n\nName\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\n--template=api\n\n\nJSON API with Fluent database.\n\n\n\n\n\n\nWeb\n\n\n--template=web\n\n\nHTML website with Leaf templates.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nThere are lots of unofficial Vapor templates on GitHub under the \nvapor\n + \ntemplate\n topcs \n.\nYou can use these by passing the full GitHub URL to the \n--template\n option.\n\n\n\n\nBuild \n Run\n\n\nYou can use the toolbox to build and run your Vapor app.\n\n\nvapor build\nvapor run\n\n\n\n\n\n\n\nTip\n\n\nWe recommend building and running through \nXcode\n if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use \nvapor xcode\n to generate an Xcode project.\n\n\n\n\nUpdating\n\n\nThe toolbox should be updated by the package manager it was installed with.\n\n\nHomebrew\n\n\nbrew upgrade vapor\n\n\n\n\n\nAPT\n\n\nsudo apt-get update\nsudo apt-get install vapor", 
            "title": "Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#install-toolbox", 
            "text": "Vapor's command line interface provides shortcuts and assistance for common tasks.   Help prints useful information about available commands and flags.  vapor --help  You can also run the  --help  option on any Toolbox command.  vapor new --help  The  --help  flag should be your goto for learning about the toolbox as it is the most up-to-date.", 
            "title": "Install Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#new", 
            "text": "The Toolbox's most important feature is helping you create a new project.  vapor new  name   Just pass the name of your project as the first argument to the  new  command.   Note  Project names should be  PascalCase  , like  HelloWorld  or  MyProject .", 
            "title": "New"
        }, 
        {
            "location": "/getting-started/toolbox/#templates", 
            "text": "By default, Vapor will create your new project from the API template. You can choose\na different template by passing the  --template  flag.     Name  Flag  Description      API  --template=api  JSON API with Fluent database.    Web  --template=web  HTML website with Leaf templates.      Info  There are lots of unofficial Vapor templates on GitHub under the  vapor  +  template  topcs  .\nYou can use these by passing the full GitHub URL to the  --template  option.", 
            "title": "Templates"
        }, 
        {
            "location": "/getting-started/toolbox/#build-run", 
            "text": "You can use the toolbox to build and run your Vapor app.  vapor build\nvapor run   Tip  We recommend building and running through  Xcode  if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use  vapor xcode  to generate an Xcode project.", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/toolbox/#updating", 
            "text": "The toolbox should be updated by the package manager it was installed with.", 
            "title": "Updating"
        }, 
        {
            "location": "/getting-started/toolbox/#homebrew", 
            "text": "brew upgrade vapor", 
            "title": "Homebrew"
        }, 
        {
            "location": "/getting-started/toolbox/#apt", 
            "text": "sudo apt-get update\nsudo apt-get install vapor", 
            "title": "APT"
        }, 
        {
            "location": "/getting-started/spm/", 
            "text": "Managing your project\n\n\nThe Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the \nVapor Toolbox\n will \ninteract with SPM on your behalf. However, it's important to understand the basics.\n\n\n\n\nTip\n\n\nLearn more about SPM on \nSwift.org \n \n\n\n\n\nPackage Manifest\n\n\nThe first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named \nPackage.swift\n.\n\n\nDependencies\n\n\nDependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n\n        \n// \ud83d\udca7 A server-side Swift web framework. \n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/vapor.git\n,\n \nfrom\n:\n \n3.0.0\n),\n\n    \n],\n\n    \ntargets\n:\n \n[\n \n...\n \n]\n\n\n)\n\n\n\n\n\n\nIn the above example, you can see \nvapor/vapor \n version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which \ntargets\n depend on\nthe newly available modules.\n\n\n\n\nWarning\n\n\nAnytime you modify the package manifest, call \nvapor update\n to effect the changes.\n\n\n\n\nTargets\n\n\nTargets are all of the modules, executables, and tests that your package contains. \n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n \n...\n \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\nname\n:\n \nApp\n,\n \ndependencies\n:\n \n[\nVapor\n]),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nMost Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to \nimport\n them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe \nmain dependencies\n array.\n\n\n\n\nTip\n\n\nExecutable targets (targets that contain a \nmain.swift\n file) cannot be imported by other modules.\nThis is why Vapor has both an \nApp\n and a \nRun\n target.\nAny code you include in \nApp\n can be tested in the \nAppTests\n.\n\n\n\n\nFolder Structure\n\n\nBelow is the typical folder structure for an SPM package.\n\n\n.\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nEach \n.target\n corresponds to a folder in the \nSources\n folder. \nEach \n.testTarget\n corresponds to a folder in the \nTests\n folder.\n\n\nTroubleshooting\n\n\nIf you are experiencing problems with SPM, sometimes cleaning your project can help.\n\n\nvapor clean", 
            "title": "SPM"
        }, 
        {
            "location": "/getting-started/spm/#managing-your-project", 
            "text": "The Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the  Vapor Toolbox  will \ninteract with SPM on your behalf. However, it's important to understand the basics.   Tip  Learn more about SPM on  Swift.org", 
            "title": "Managing your project"
        }, 
        {
            "location": "/getting-started/spm/#package-manifest", 
            "text": "The first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named  Package.swift .", 
            "title": "Package Manifest"
        }, 
        {
            "location": "/getting-started/spm/#dependencies", 
            "text": "Dependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [ \n         // \ud83d\udca7 A server-side Swift web framework.  \n         . package ( url :   https://github.com/vapor/vapor.git ,   from :   3.0.0 ), \n     ], \n     targets :   [   ...   ]  )   In the above example, you can see  vapor/vapor   version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which  targets  depend on\nthe newly available modules.   Warning  Anytime you modify the package manifest, call  vapor update  to effect the changes.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/getting-started/spm/#targets", 
            "text": "Targets are all of the modules, executables, and tests that your package contains.   // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [   ...   ], \n     targets :   [ \n         . target ( name :   App ,   dependencies :   [ Vapor ]), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   Most Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to  import  them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe  main dependencies  array.   Tip  Executable targets (targets that contain a  main.swift  file) cannot be imported by other modules.\nThis is why Vapor has both an  App  and a  Run  target.\nAny code you include in  App  can be tested in the  AppTests .", 
            "title": "Targets"
        }, 
        {
            "location": "/getting-started/spm/#folder-structure", 
            "text": "Below is the typical folder structure for an SPM package.  .\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Each  .target  corresponds to a folder in the  Sources  folder. \nEach  .testTarget  corresponds to a folder in the  Tests  folder.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/spm/#troubleshooting", 
            "text": "If you are experiencing problems with SPM, sometimes cleaning your project can help.  vapor clean", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/getting-started/xcode/", 
            "text": "Xcode\n\n\nIf you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.\n\n\n\n\nXcode is a great way to develop Vapor apps, but you can use any text editor you like.\n\n\nGenerate Project\n\n\nTo use Xcode, you just need to generate an Xcode project using \nVapor Toolbox\n.\n\n\nvapor xcode\n\n\n\n\n\n\n\nTip\n\n\nDon't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.\n\n\n\n\nRun\n\n\nTo build and run your Vapor app, first make sure you have the \nRun\n scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.\n\n\n\n\nOnce that's selected, just click the play button or press \nCommand + R\n on your keyboard.\n\n\nTest\n\n\nTo run your unit tests, select the scheme ending in \n-Package\n and press \nCommand + U\n.\n\n\n\n\nWarning\n\n\nThere may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#xcode", 
            "text": "If you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.   Xcode is a great way to develop Vapor apps, but you can use any text editor you like.", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#generate-project", 
            "text": "To use Xcode, you just need to generate an Xcode project using  Vapor Toolbox .  vapor xcode   Tip  Don't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.", 
            "title": "Generate Project"
        }, 
        {
            "location": "/getting-started/xcode/#run", 
            "text": "To build and run your Vapor app, first make sure you have the  Run  scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.   Once that's selected, just click the play button or press  Command + R  on your keyboard.", 
            "title": "Run"
        }, 
        {
            "location": "/getting-started/xcode/#test", 
            "text": "To run your unit tests, select the scheme ending in  -Package  and press  Command + U .   Warning  There may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Test"
        }, 
        {
            "location": "/getting-started/structure/", 
            "text": "Structure\n\n\nThis section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.\n\n\nFolder Structure\n\n\nVapor's folder structure builds on top of \nSPM's folder structure\n.\n\n\n.\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nLet's take a look at what each of these folders and files does.\n\n\nPublic\n\n\nThis folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.\n\n\nWhenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.\n\n\nFor example, a request to \nlocalhost:8080/favicon.ico\n will check to see\nif \nPublic/favicon.ico\n exists. If it does, Vapor will return it.\n\n\nSources\n\n\nThis folder contains all of the Swift source files for your project. \nThe top level folders (\nApp\n and \nRun\n) reflect your package's modules, \nas declared in the \npackage manifest\n.\n\n\nApp\n\n\nThis is the most important folder in your application, it's where all of\nthe application logic goes!\n\n\nControllers\n\n\nControllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.\n\n\n\n\nTip\n\n\nVapor supports, but does not enforce the MVC pattern\n\n\n\n\nModels\n\n\nThe \nModels\n folder is a great place to store your \nContent\n structs or\nFluent \nModel\ns.\n\n\nboot.swift\n\n\nThis file contains a function that will be called \nafter\n your application has booted,\nbut \nbefore\n it has started running. This is a great place do things that should happen \nevery time your application starts.\n\n\nYou have access to the \nApplication\n here which you can use to create\nany \nservices\n you might need.\n\n\nconfigure.swift\n\n\nThis file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register \n\nservices\n to your application.\n\n\nroutes.swift\n\n\nThis file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.\n\n\nYou'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.\n\n\nYou can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection. \n\n\nTests\n\n\nEach non-executable module in your \nSources\n folder should have a corresponding \n...Tests\n folder.\n\n\nAppTests\n\n\nThis folder contains the unit tests for code in your \nApp\n module. \nLearn more about testing in \nTesting \n Getting Started\n.\n\n\nPackage.swift\n\n\nFinally is SPM's \npackage manifest\n.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#structure", 
            "text": "This section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.", 
            "title": "Structure"
        }, 
        {
            "location": "/getting-started/structure/#folder-structure", 
            "text": "Vapor's folder structure builds on top of  SPM's folder structure .  .\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Let's take a look at what each of these folders and files does.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#public", 
            "text": "This folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.  Whenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.  For example, a request to  localhost:8080/favicon.ico  will check to see\nif  Public/favicon.ico  exists. If it does, Vapor will return it.", 
            "title": "Public"
        }, 
        {
            "location": "/getting-started/structure/#sources", 
            "text": "This folder contains all of the Swift source files for your project. \nThe top level folders ( App  and  Run ) reflect your package's modules, \nas declared in the  package manifest .", 
            "title": "Sources"
        }, 
        {
            "location": "/getting-started/structure/#app", 
            "text": "This is the most important folder in your application, it's where all of\nthe application logic goes!", 
            "title": "App"
        }, 
        {
            "location": "/getting-started/structure/#controllers", 
            "text": "Controllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.   Tip  Vapor supports, but does not enforce the MVC pattern", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/structure/#models", 
            "text": "The  Models  folder is a great place to store your  Content  structs or\nFluent  Model s.", 
            "title": "Models"
        }, 
        {
            "location": "/getting-started/structure/#bootswift", 
            "text": "This file contains a function that will be called  after  your application has booted,\nbut  before  it has started running. This is a great place do things that should happen \nevery time your application starts.  You have access to the  Application  here which you can use to create\nany  services  you might need.", 
            "title": "boot.swift"
        }, 
        {
            "location": "/getting-started/structure/#configureswift", 
            "text": "This file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register  services  to your application.", 
            "title": "configure.swift"
        }, 
        {
            "location": "/getting-started/structure/#routesswift", 
            "text": "This file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.  You'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.  You can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection.", 
            "title": "routes.swift"
        }, 
        {
            "location": "/getting-started/structure/#tests", 
            "text": "Each non-executable module in your  Sources  folder should have a corresponding  ...Tests  folder.", 
            "title": "Tests"
        }, 
        {
            "location": "/getting-started/structure/#apptests", 
            "text": "This folder contains the unit tests for code in your  App  module. \nLearn more about testing in  Testing   Getting Started .", 
            "title": "AppTests"
        }, 
        {
            "location": "/getting-started/structure/#packageswift", 
            "text": "Finally is SPM's  package manifest .", 
            "title": "Package.swift"
        }, 
        {
            "location": "/getting-started/application/", 
            "text": "Application\n\n\nEvery Vapor project has an \nApplication\n. You use the application to create any services\nyou might need while developing.\n\n\nThe best place to access the application is in your project's \nboot.swift\n file.\n\n\nimport\n \nVapor\n\n\n\npublic\n \nfunc\n \nboot\n(\n_\n \napp\n:\n \nApplication\n)\n \nthrows\n \n{\n\n    \n// your code here\n\n\n}\n\n\n\n\n\n\nYou can also access the application from your \nroutes.swift\n file. It's stored\nas a property there.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nUnlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.\n\n\n\n\nInfo\n\n\nAvoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.\n\n\n\n\nServices\n\n\nThe application's main function is to make services. For example, you might need a \nBCryptHasher\n to hash\nsome passwords before storing them in a database. You can use the application to create one.\n\n\nimport\n \nBCrypt\n\n\n\nlet\n \nbcryptHasher\n \n=\n \ntry\n \napp\n.\nmake\n(\nBCryptHasher\n.\nself\n)\n\n\n\n\n\n\nOr you might use the application to create an HTTP client.\n\n\nlet\n \nclient\n \n=\n \ntry\n \napp\n.\nmake\n(\nClient\n.\nself\n)\n\n\nlet\n \nres\n \n=\n \nclient\n.\nget\n(\nhttp://vapor.codes\n)\n\n\n\n\n\n\nLearn more about services in \nServices \n Getting Started\n.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#application", 
            "text": "Every Vapor project has an  Application . You use the application to create any services\nyou might need while developing.  The best place to access the application is in your project's  boot.swift  file.  import   Vapor  public   func   boot ( _   app :   Application )   throws   { \n     // your code here  }   You can also access the application from your  routes.swift  file. It's stored\nas a property there.  import   Vapor  final   class   Routes :   RouteCollection   { \n     ...  }   Unlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.   Info  Avoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#services", 
            "text": "The application's main function is to make services. For example, you might need a  BCryptHasher  to hash\nsome passwords before storing them in a database. You can use the application to create one.  import   BCrypt  let   bcryptHasher   =   try   app . make ( BCryptHasher . self )   Or you might use the application to create an HTTP client.  let   client   =   try   app . make ( Client . self )  let   res   =   client . get ( http://vapor.codes )   Learn more about services in  Services   Getting Started .", 
            "title": "Services"
        }, 
        {
            "location": "/getting-started/controllers/", 
            "text": "Controllers\n\n\nControllers are a great way to organize your code. They are collections of methods that accept\na request and return a response.\n\n\nA good place to put your controllers is in the \nControllers\n folder.\n\n\nMethods\n\n\nLet's take a look at an example controller.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nfunc\n \ngreet\n(\n_\n \nreq\n:\n \nRequest\n)\n \nthrows\n \n-\n \nString\n \n{\n\n        \nreturn\n \nHello!\n\n    \n}\n\n\n}\n\n\n\n\n\n\nController methods should always accept a \nRequest\n and return something \nResponseRepresentable\n.\nThis also includes \nfutures\n whose expectations are \nResponseRepresentable\n (i.e, \nFuture\nString\n).\n\n\nTo use this controller, we can simply initialize it, then pass the method to a router.\n\n\nlet\n \nhelloController\n \n=\n \nHelloController\n()\n\n\nrouter\n.\nget\n(\ngreet\n,\n \nuse\n:\n \nhelloController\n.\ngreet\n)\n\n\n\n\n\n\nUse Services\n\n\nYou will probably want to access your \napplication's services\n from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nlet\n \nhasher\n:\n \nBCryptHasher\n\n\n    \ninit\n(\nhasher\n:\n \nBCryptHasher\n)\n \n{\n\n        \nself\n.\nhasher\n \n=\n \nhasher\n\n    \n}\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nNext, use the \napplication\n to create these services when you initialize your controller.\n\n\nlet\n \nhelloController\n \n=\n \ntry\n \nHelloController\n(\n\n    \nhasher\n:\n \napp\n.\nmake\n()\n\n\n)", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#controllers", 
            "text": "Controllers are a great way to organize your code. They are collections of methods that accept\na request and return a response.  A good place to put your controllers is in the  Controllers  folder.", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#methods", 
            "text": "Let's take a look at an example controller.  import   Vapor  final   class   HelloController   { \n     func   greet ( _   req :   Request )   throws   -   String   { \n         return   Hello! \n     }  }   Controller methods should always accept a  Request  and return something  ResponseRepresentable .\nThis also includes  futures  whose expectations are  ResponseRepresentable  (i.e,  Future String ).  To use this controller, we can simply initialize it, then pass the method to a router.  let   helloController   =   HelloController ()  router . get ( greet ,   use :   helloController . greet )", 
            "title": "Methods"
        }, 
        {
            "location": "/getting-started/controllers/#use-services", 
            "text": "You will probably want to access your  application's services  from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.  final   class   HelloController   { \n     let   hasher :   BCryptHasher \n\n     init ( hasher :   BCryptHasher )   { \n         self . hasher   =   hasher \n     } \n\n     ...  }   Next, use the  application  to create these services when you initialize your controller.  let   helloController   =   try   HelloController ( \n     hasher :   app . make ()  )", 
            "title": "Use Services"
        }, 
        {
            "location": "/getting-started/routing/", 
            "text": "Routing\n\n\nRouting is the process of finding the appropriate response to an incoming request.\n\n\nMaking a Router\n\n\nIn Vapor the default Router is the \nEngineRouter\n. You can implement custom routers by implementing one conformant to the \nRouter\n protocol.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \nEngineRouter\n.\ndefault\n()\n\n\n\n\n\n\nThere are two APIs available, one is supplied by the \nRouting\n library and a set of helpers is available in Vapor itself.\n\n\nWe recommend using the helpers and will continue to describe those here.\n\n\nRegistering a route\n\n\nImagine you want to return a list of users when someone visits \nGET /users\n.\nLeaving authorization on the side, that would look something like this.\n\n\nrouter\n.\nget\n(\nusers\n)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \n// fetch the users\n\n\n}\n\n\n\n\n\n\nIn Vapor, routing is usually done using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands.\nYou can supply the path as \n/\n or comma-separated strings. We recommend comma separated, as it's more readable.\n\n\nrouter\n.\nget\n(\npath\n,\n \nto\n,\n \nsomething\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nRoutes\n\n\nThe best place to add routes is in the \nroutes.swift\n file.\nYou will find a router there that is ready to use.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \n...\n\n\n    \nfunc\n \nboot\n(\nrouter\n:\n \nRouter\n)\n \nthrows\n \n{\n\n        \nrouter\n.\nget\n(\nhello\n)\n \n{\n \nreq\n \nin\n\n            \nreturn\n \nHello, world!\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou \nmust\n return a Future containing a \nResponseEncodable\n here.\nThe most common \nResponseEncodable\n types are \nContent\n, \nResponse\n amd \nView\n.\n\n\nParameters\n\n\nSometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e., \nGET /users/:id\n\n\nrouter\n.\nget\n(\nusers\n,\n \nInt\n.\nparameter\n)\n \n{\n \nreq\n \n-\n \nFuture\nString\n \nin\n\n    \nlet\n \nid\n \n=\n \ntry\n \nreq\n.\nparameter\n(\nInt\n.\nself\n)\n\n    \nreturn\n \n// fetch the user with id\n\n\n}\n\n\n\n\n\n\nInstead of passing a string, pass the \ntype\n of parameter you expect. In this case, our \nUser\n has an \nInt\n ID.\n\n\n\n\nTip\n\n\nYou can define your own \ncustom parameter types\n as well.\n\n\n\n\nAfter registering your routes\n\n\nAfter registering your routes you must register the Router as a \nService", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#routing", 
            "text": "Routing is the process of finding the appropriate response to an incoming request.", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#making-a-router", 
            "text": "In Vapor the default Router is the  EngineRouter . You can implement custom routers by implementing one conformant to the  Router  protocol.  let   router   =   try   EngineRouter . default ()   There are two APIs available, one is supplied by the  Routing  library and a set of helpers is available in Vapor itself.  We recommend using the helpers and will continue to describe those here.", 
            "title": "Making a Router"
        }, 
        {
            "location": "/getting-started/routing/#registering-a-route", 
            "text": "Imagine you want to return a list of users when someone visits  GET /users .\nLeaving authorization on the side, that would look something like this.  router . get ( users )   {   req   in \n     return   // fetch the users  }   In Vapor, routing is usually done using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands.\nYou can supply the path as  /  or comma-separated strings. We recommend comma separated, as it's more readable.  router . get ( path ,   to ,   something )   {   ...   }", 
            "title": "Registering a route"
        }, 
        {
            "location": "/getting-started/routing/#routes", 
            "text": "The best place to add routes is in the  routes.swift  file.\nYou will find a router there that is ready to use.  import   Vapor  final   class   Routes :   RouteCollection   { \n     ... \n\n     func   boot ( router :   Router )   throws   { \n         router . get ( hello )   {   req   in \n             return   Hello, world! \n         } \n     }  }   You  must  return a Future containing a  ResponseEncodable  here.\nThe most common  ResponseEncodable  types are  Content ,  Response  amd  View .", 
            "title": "Routes"
        }, 
        {
            "location": "/getting-started/routing/#parameters", 
            "text": "Sometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e.,  GET /users/:id  router . get ( users ,   Int . parameter )   {   req   -   Future String   in \n     let   id   =   try   req . parameter ( Int . self ) \n     return   // fetch the user with id  }   Instead of passing a string, pass the  type  of parameter you expect. In this case, our  User  has an  Int  ID.   Tip  You can define your own  custom parameter types  as well.", 
            "title": "Parameters"
        }, 
        {
            "location": "/getting-started/routing/#after-registering-your-routes", 
            "text": "After registering your routes you must register the Router as a  Service", 
            "title": "After registering your routes"
        }, 
        {
            "location": "/getting-started/content/", 
            "text": "Content\n\n\nIn Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a \nCodable\n class or struct.\n\n\nFor this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.\n\n\nRequest\n\n\nLet's take a look at how you would parse the following HTTP request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nemail\n:\n \nuser@vapor.codes\n,\n\n    \npassword\n:\n \ndon\nt look!\n\n\n}\n\n\n\n\n\n\nDecode Request\n\n\nFirst, create a struct or class that represents the data you expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nLoginRequest\n:\n \nContent\n \n{\n\n    \nvar\n \nemail\n:\n \nString\n\n    \nvar\n \npassword\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen simply conform this struct or class to \nContent\n.\nNow we are ready to decode that HTTP request.\n\n\nrouter\n.\npost\n(\nlogin\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nloginRequest\n \n=\n \ntry\n \nreq\n.\ncontent\n.\ndecode\n(\nLoginRequest\n.\nself\n)\n\n\n    \nprint\n(\nloginRequest\n.\nemail\n)\n \n// user@vapor.codes\n\n    \nprint\n(\nloginRequest\n.\npassword\n)\n \n// don\nt look!\n\n\n    \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}\n\n\n\n\n\n\nIt's that simple!\n\n\nOther Request Types\n\n\nSince the request in the previous example declared JSON as it's content type,\nVapor knows to use a JSON decoder automatically.\nThis same method would work just as well for the following request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/x-www-form-urlencoded\n\n\nemail=user@vapor.codes\ndon\nt+look!\n\n\n\n\n\n\n\nTip\n\n\nYou can configure which encoders/decoders Vapor uses. Read on to learn more.\n\n\n\n\nResponse\n\n\nLet's take a look at how you would create the following HTTP response.\n\n\nHTTP\n/\n1.1\n \n200\n \nOK\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nname\n:\n \nVapor User\n,\n\n    \nemail\n:\n \nuser@vapor.codes\n\n\n}\n\n\n\n\n\n\nEncode Response\n\n\nJust like decoding, first create a struct or class that represents the data your expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nemail\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen just conform this struct or class to \nContent\n.\nNow we are ready to encode that HTTP response.\n\n\nrouter\n.\nget\n(\nuser\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nuser\n \n=\n \nUser\n(\n\n        \nname\n:\n \nVapor User\n,\n\n        \nemail\n:\n \nuser@vapor.codes\n\n    \n)\n\n\n    \nlet\n \nres\n \n=\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n    \ntry\n \nres\n.\ncontent\n.\nencode\n(\nuser\n,\n \nas\n:\n \n.\njson\n)\n\n    \nreturn\n \nres\n\n\n}\n\n\n\n\n\n\nOther Response Types\n\n\nContent will automatically encode as JSON by default. You can always override which content type is used\nusing the \nas:\n parameter.\n\n\ntry\n \nres\n.\ncontent\n.\nencode\n(\nuser\n,\n \nas\n:\n \n.\nformURLEncoded\n)\n\n\n\n\n\n\nYou can also change the default media type for any class or struct.\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \n/// See Content.defaultMediaType\n\n    \nstatic\n \nlet\n \ndefaultMediaType\n:\n \nMediaType\n \n=\n \n.\nformURLEncoded\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nConfiguring Content\n\n\nComing soon.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#content", 
            "text": "In Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a  Codable  class or struct.  For this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#request", 
            "text": "Let's take a look at how you would parse the following HTTP request.  POST   /login   HTTP / 1.1  Content-Type :   application/json  { \n     email :   user@vapor.codes , \n     password :   don t look!  }", 
            "title": "Request"
        }, 
        {
            "location": "/getting-started/content/#decode-request", 
            "text": "First, create a struct or class that represents the data you expect.  import   Foundation  import   Vapor  struct   LoginRequest :   Content   { \n     var   email :   String \n     var   password :   String  }   Then simply conform this struct or class to  Content .\nNow we are ready to decode that HTTP request.  router . post ( login )   {   req   -   Response   in \n     let   loginRequest   =   try   req . content . decode ( LoginRequest . self ) \n\n     print ( loginRequest . email )   // user@vapor.codes \n     print ( loginRequest . password )   // don t look! \n\n     return   Response ( status :   . ok )  }   It's that simple!", 
            "title": "Decode Request"
        }, 
        {
            "location": "/getting-started/content/#other-request-types", 
            "text": "Since the request in the previous example declared JSON as it's content type,\nVapor knows to use a JSON decoder automatically.\nThis same method would work just as well for the following request.  POST   /login   HTTP / 1.1  Content-Type :   application/x-www-form-urlencoded \n\nemail=user@vapor.codes don t+look!   Tip  You can configure which encoders/decoders Vapor uses. Read on to learn more.", 
            "title": "Other Request Types"
        }, 
        {
            "location": "/getting-started/content/#response", 
            "text": "Let's take a look at how you would create the following HTTP response.  HTTP / 1.1   200   OK  Content-Type :   application/json  { \n     name :   Vapor User , \n     email :   user@vapor.codes  }", 
            "title": "Response"
        }, 
        {
            "location": "/getting-started/content/#encode-response", 
            "text": "Just like decoding, first create a struct or class that represents the data your expect.  import   Foundation  import   Vapor  struct   User :   Content   { \n     var   name :   String \n     var   email :   String  }   Then just conform this struct or class to  Content .\nNow we are ready to encode that HTTP response.  router . get ( user )   {   req   -   Response   in \n     let   user   =   User ( \n         name :   Vapor User , \n         email :   user@vapor.codes \n     ) \n\n     let   res   =   Response ( status :   . ok ) \n     try   res . content . encode ( user ,   as :   . json ) \n     return   res  }", 
            "title": "Encode Response"
        }, 
        {
            "location": "/getting-started/content/#other-response-types", 
            "text": "Content will automatically encode as JSON by default. You can always override which content type is used\nusing the  as:  parameter.  try   res . content . encode ( user ,   as :   . formURLEncoded )   You can also change the default media type for any class or struct.  struct   User :   Content   { \n     /// See Content.defaultMediaType \n     static   let   defaultMediaType :   MediaType   =   . formURLEncoded \n\n     ...  }", 
            "title": "Other Response Types"
        }, 
        {
            "location": "/getting-started/content/#configuring-content", 
            "text": "Coming soon.", 
            "title": "Configuring Content"
        }, 
        {
            "location": "/getting-started/futures/", 
            "text": "Futures\n\n\nYou may have noticed some APIs in Vapor expect or return a \nFuture\nT\n type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.\n\n\nPromises and Futures are two strongly related types. Every promise has a future.\nA promise is a write-only entity that has the ability to complete (or fail) it's Future counterpart.\n\n\nFutures are a read-only entity that can have a successful or error case. Successful cases are called the \"Expectation\".\n\n\nFutures can be used to register callbacks to, which will always executed in the order of registration. Promises can only be completed once. If a promise is completed more than once the input will be \nignored\n.\n\n\nBasics\n\n\nCreating a promise is when the result is returned in the future at an unknown time.\nFor the sake of demonstration, however, the promise will be completed at a predefined point in time and execution.\n\n\nWithin the \n.do\n block you may not throw an error or return a result.\n\n\nlet\n \npromise\n \n=\n \nPromise\nString\n()\n\n\nlet\n \nfuture\n \n=\n \npromise\n.\nfuture\n \n// Future\nString\n\n\n\nfuture\n.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\nHello\n)\n\n\n\n\n\n\nThe above code prints \"Hello\" in the console.\n\n\nErrors\n\n\nWhen running the above code, you may have noticed a warning pop up. This is because the \n.do\n block only handles successful completions. If we were to replace the completion with the following code the \n.do\n block would never get run:\n\n\nstruct\n \nMyError\n:\n \nError\n \n{}\n\n\n\npromise\n.\nfail\n(\nMyError\n())\n\n\n\n\n\n\nInstead, a \n.catch\n block will be triggered.\n\n\nfuture\n.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\n\n\n\nIn this scenario the test \"Error 'MyError' occurred\" will appear.\n\n\nWithin the \n.catch\n block you may not throw an error or return a result.\n\n\nBasic Transformations\n\n\nTransformations are one of the more critical parts of Vapor 3's future system. They assist in reducing the complexity of futures and keep code isolated and readable. You can use the \n.map\n function to transform the future expectation to another future of the same or a different type. You need to explicitly state which type will be returned in the mapping closure.\n\n\nThe mapping closure(s) will \nonly\n be executed if an expectation has been received in the previous step. If at any point a transformation function throws an error, execution stops there and the \n.catch\n block will be executed.\n\n\nIf the promise that was mapped failed to begin with, the \n.catch\n block will also be executed \nwithout\n triggering \nany\n mapping closures.\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nfuture\n.\ndo\n \n{\n \nint\n \nin\n\n    \nprint\n(\nint\n)\n\n\n}.\nmap\n(\nto\n:\n \nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nint\n \n+\n \n4\n\n\n}.\nmap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nint\n.\ndescription\n\n\n}.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nThe above code will print the inputted integer. Then map the input to \n(integer + 4) == 7\n.\nThen the textual representation of the integer is returned as a \nString\n which will be printed.\n\n\nThis results in the following console output:\n\n\n3\n\n\n7\n\n\n\n\n\n\nRecursive futures\n\n\nIn the above \nmap\n function we returned a new result synchronously. In some situations, however, you'll need to dispatch another asynchronous call based on the result of a previous call.\n\n\nFirst, let's see how this would work out using \nmap\n by exaggerating synchronous code as if it were an asynchronous call.\n\n\n\n\nWarning\n\n\nDo not use this implementation, use the next one instead. This is an unnecessarily complicated way of nesting futures.\n\n\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nmap\n(\nto\n:\n \nFuture\nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\n(\nint\n \n+\n \n4\n)\n\n\n}.\nmap\n(\nto\n:\n \nFuture\nFuture\nString\n.\nself\n)\n \n{\n \nfutureInt\n \nin\n\n    \nreturn\n \nfutureInt\n.\nmap\n(\nto\n:\n \nFuture\nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n        \nreturn\n \nFuture\n(\nint\n.\ndescription\n)\n\n    \n}\n\n\n}.\ndo\n \n{\n \ndoubleFutureString\n \nin\n \n// Future\nFuture\nString\n\n    \ndoubleFutureString\n.\ndo\n \n{\n \nfutureString\n \nin\n \n// Future\nString\n\n      \nfutureString\n.\ndo\n \n{\n \nstring\n \nin\n\n          \nprint\n(\nstring\n)\n\n      \n}.\ncatch\n \n{\n \nerror\n \nin\n\n          \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n      \n}\n\n    \n}.\ncatch\n \n{\n \nerror\n \nin\n\n        \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n    \n}\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nTo flatten this asynchronous recursion, instead, we recommend using \nflatMap\n.\nThe type supplied in the \nto:\n argument is implied to be wrapped in a \nFuture\n.\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nflatMap\n(\nto\n:\n \nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\nInt\n(\nint\n \n+\n \n4\n)\n\n\n}.\nflatMap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\n(\nint\n.\ndescription\n)\n\n\n}.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nAlways\n\n\nSometimes you want to always execute a function as part of the cleanup phase.\nYou can use the \n.always\n block to execute a block of code after the future has been successfully executed (and mapped if applicable) or when an error occurs. Please do consider that \nalways\n also will be executed in the order in which it has been registered, like all other closures.\n\n\nvar\n \ni\n \n=\n \n0\n\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\nlet\n \nfuture\n \n=\n \npromise\n.\nfuture\n \n// Future\nInt\n\n\n\nfuture\n.\ndo\n \n{\n \nint\n \nin\n\n    \ni\n \n+=\n \nint\n \n*\n \n3\n\n\n}.\ndo\n \n{\n \nint\n \nin\n\n    \ni\n \n+=\n \n(\nint\n \n-\n \n1\n)\n\n\n}.\nalways\n \n{\n\n    \nprint\n(\ni\n)\n\n    \ni\n \n=\n \n0\n\n\n}.\ncatch\n \n{\n \n_\n \nin\n\n    \ni\n \n=\n \n-\n1\n\n\n}\n\n\n\n\n\n\nAt the end of the above function, \ni\n will \nalways\n be 0. If the promise is completed with the successful result \ni\n, the number \"11\" will be printed. On error, \"-1\" will be printed.\n\n\nSignals\n\n\nSignals, or \nFuture\nVoid\n is a Future that can contain either an Error or Void (the Expectation). \nFuture\nVoid\n is often used to indicate the successful or unsuccessful completion of a task.", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#futures", 
            "text": "You may have noticed some APIs in Vapor expect or return a  Future T  type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.  Promises and Futures are two strongly related types. Every promise has a future.\nA promise is a write-only entity that has the ability to complete (or fail) it's Future counterpart.  Futures are a read-only entity that can have a successful or error case. Successful cases are called the \"Expectation\".  Futures can be used to register callbacks to, which will always executed in the order of registration. Promises can only be completed once. If a promise is completed more than once the input will be  ignored .", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#basics", 
            "text": "Creating a promise is when the result is returned in the future at an unknown time.\nFor the sake of demonstration, however, the promise will be completed at a predefined point in time and execution.  Within the  .do  block you may not throw an error or return a result.  let   promise   =   Promise String ()  let   future   =   promise . future   // Future String  future . do   {   string   in \n     print ( string )  }  promise . complete ( Hello )   The above code prints \"Hello\" in the console.", 
            "title": "Basics"
        }, 
        {
            "location": "/getting-started/futures/#errors", 
            "text": "When running the above code, you may have noticed a warning pop up. This is because the  .do  block only handles successful completions. If we were to replace the completion with the following code the  .do  block would never get run:  struct   MyError :   Error   {}  promise . fail ( MyError ())   Instead, a  .catch  block will be triggered.  future . do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }   In this scenario the test \"Error 'MyError' occurred\" will appear.  Within the  .catch  block you may not throw an error or return a result.", 
            "title": "Errors"
        }, 
        {
            "location": "/getting-started/futures/#basic-transformations", 
            "text": "Transformations are one of the more critical parts of Vapor 3's future system. They assist in reducing the complexity of futures and keep code isolated and readable. You can use the  .map  function to transform the future expectation to another future of the same or a different type. You need to explicitly state which type will be returned in the mapping closure.  The mapping closure(s) will  only  be executed if an expectation has been received in the previous step. If at any point a transformation function throws an error, execution stops there and the  .catch  block will be executed.  If the promise that was mapped failed to begin with, the  .catch  block will also be executed  without  triggering  any  mapping closures.  let   promise   =   Promise Int ()  promise . future . do   {   int   in \n     print ( int )  }. map ( to :   Int . self )   {   int   in \n     return   int   +   4  }. map ( to :   String . self )   {   int   in \n     return   int . description  }. do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )   The above code will print the inputted integer. Then map the input to  (integer + 4) == 7 .\nThen the textual representation of the integer is returned as a  String  which will be printed.  This results in the following console output:  3  7", 
            "title": "Basic Transformations"
        }, 
        {
            "location": "/getting-started/futures/#recursive-futures", 
            "text": "In the above  map  function we returned a new result synchronously. In some situations, however, you'll need to dispatch another asynchronous call based on the result of a previous call.  First, let's see how this would work out using  map  by exaggerating synchronous code as if it were an asynchronous call.   Warning  Do not use this implementation, use the next one instead. This is an unnecessarily complicated way of nesting futures.   let   promise   =   Promise Int ()  promise . map ( to :   Future Int . self )   {   int   in \n     return   Future ( int   +   4 )  }. map ( to :   Future Future String . self )   {   futureInt   in \n     return   futureInt . map ( to :   Future String . self )   {   int   in \n         return   Future ( int . description ) \n     }  }. do   {   doubleFutureString   in   // Future Future String \n     doubleFutureString . do   {   futureString   in   // Future String \n       futureString . do   {   string   in \n           print ( string ) \n       }. catch   {   error   in \n           print ( Error  \\( error )  occurred ) \n       } \n     }. catch   {   error   in \n         print ( Error  \\( error )  occurred ) \n     }  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )   To flatten this asynchronous recursion, instead, we recommend using  flatMap .\nThe type supplied in the  to:  argument is implied to be wrapped in a  Future .  let   promise   =   Promise Int ()  promise . flatMap ( to :   Int . self )   {   int   in \n     return   Future Int ( int   +   4 )  }. flatMap ( to :   String . self )   {   int   in \n     return   Future ( int . description )  }. do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )", 
            "title": "Recursive futures"
        }, 
        {
            "location": "/getting-started/futures/#always", 
            "text": "Sometimes you want to always execute a function as part of the cleanup phase.\nYou can use the  .always  block to execute a block of code after the future has been successfully executed (and mapped if applicable) or when an error occurs. Please do consider that  always  also will be executed in the order in which it has been registered, like all other closures.  var   i   =   0  let   promise   =   Promise Int ()  let   future   =   promise . future   // Future Int  future . do   {   int   in \n     i   +=   int   *   3  }. do   {   int   in \n     i   +=   ( int   -   1 )  }. always   { \n     print ( i ) \n     i   =   0  }. catch   {   _   in \n     i   =   - 1  }   At the end of the above function,  i  will  always  be 0. If the promise is completed with the successful result  i , the number \"11\" will be printed. On error, \"-1\" will be printed.", 
            "title": "Always"
        }, 
        {
            "location": "/getting-started/futures/#signals", 
            "text": "Signals, or  Future Void  is a Future that can contain either an Error or Void (the Expectation).  Future Void  is often used to indicate the successful or unsuccessful completion of a task.", 
            "title": "Signals"
        }, 
        {
            "location": "/getting-started/services/", 
            "text": "Services\n\n\nServices is a framework for creating things you need in your application in a type-safe fashion with protocol and environment support.\n\n\nThe Services framework is designed to be thread unsafe. The framework aims to guarantee that a service exists on the same \nEventLoop\n it was created from and will be used on.\n\n\nGlossary\n\n\nContainer\n\n\nContainers are \nEventLoops\n that can create and cache services.\n\n\nRequest\n is the most common \nContainer\n type, which can be accessed in every \nRoute\n.\n\n\nContainers cache instances of a given service (keyed by the requested protocol) on a per-container basis.\n\n\n\n\nAny given container has its own cache. No two containers will ever share a service instance, whether singleton or not.\n\n\nA singleton service is chosen and cached only by which interface(s) it supports and the service tag.\nThere will only ever be one instance of a singleton service per-container, regardless of what requested it.\n\n\nA normal service is chosen and cached by which interface(s) it supports, the service tag, and the requesting client interface.\nThere will be as many instances of a normal service per-container as there are unique clients requesting it.\n(Remembering that clients are also interface types, not instances - that's the \nfor:\n parameter to \n.make()\n)\n\n\n\n\nEphemeralContainer\n\n\nEphemeralContainers are containers that are short-lived.\nTheir cache does not stretch beyond a short lifecycle.\nThe most common EphemeralContainer is an \nHTTP Request\n which lives for the duration of the route handler.\n\n\nService\n\n\nServices are a type that can be requested from a Container. They are registered as part of the application setup.\n\n\nServices are registered to a matching type or protocol it can represent, including it's own concrete type.\n\n\nServices are registered to a blueprint before the \nApplication\n is initialized. Together they make up the blueprint that Containers use to create an individual Service.\n\n\nEnvironment\n\n\nEnvironments indicate the type of deployment/situation in which an application is ran. Environments can be used to change database credentials or API tokens per environment automatically.\n\n\nRegistering\n\n\nServices are registered as a concrete (singleton) type or factories. Singleton types should be a struct, but can be a class.\n\n\nTo create an empty list of Services you can call the initializer without parameters\n\n\nvar\n \nservices\n \n=\n \nServices\n()\n\n\n\n\n\n\nThe Vapor framework has a default setup with the most common (and officially supported) Services already registered.\n\n\nvar\n \nservices\n \n=\n \nServices\n.\ndefault\n()\n\n\n\n\n\n\nConcrete implementations\n\n\nA common use case for registering a struct is for registering configurations.\nVapor 3 configurations are \nalways\n a concrete struct type. Registering a concrete type is simple:\n\n\nstruct\n \nEmptyService\n \n{}\n\n\n\nservices\n.\ninstance\n(\nEmptyService\n())\n\n\n\n\n\n\nSingletons\n\n\nSingleton services (which declare themselves, or were registered, as such) are cached on a per-container basis, but the singleton cache ignores which Client is requesting the service (whereas the normal cache does not).\n\n\nSingleton classes \nmust\n be thread-safe to prevent crashes. If you want your class to be a singleton type (across all threads):\n\n\nfinal\n \nclass\n \nSingletonService\n \n{\n\n  \ninit\n()\n \n{}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\nisSingleton\n:\n \ntrue\n,\n \nSingletonService\n())\n\n\n\n\n\n\nAssuming the above service, you can now make this service from a container. The global container in Vapor is \nApplication\n which \nmust not\n be used within routes.\n\n\nlet\n \napp\n \n=\n \ntry\n \nApplication\n(\nservices\n:\n \nservices\n)\n\n\nlet\n \nemptyService\n \n=\n \napp\n.\nmake\n(\nEmptyService\n.\nself\n)\n\n\n\n\n\n\nProtocol conforming services\n\n\nOften times when registering a service is conforms to one or more protocols for which it can be used. This is one of the more widely used use cases for Services.\n\n\nenum\n \nLevel\n \n{\n\n  \ncase\n \nverbose\n,\n \nerror\n\n\n}\n\n\n\nprotocol\n \nLogger\n \n{\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n\n\n}\n\n\n\nstruct\n \nPrintLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nPrintLogger\n())\n\n\n\n\n\n\nThe above can be combined with \nisSingleton: true\n\n\nRegistering multiple conformances\n\n\nA single type can conform to multiple protocols, and you might want to register a single service for all those conforming situations.\n\n\nprotocol\n \nConsole\n \n{\n\n  \nfunc\n \nwrite\n(\n_\n \nmessage\n:\n \nString\n,\n \ncolor\n:\n \nAnsiColor\n)\n\n\n}\n\n\n\nstruct\n \nPrintConsole\n:\n \nConsole\n,\n \nLogger\n \n{\n\n  \nfunc\n \nwrite\n(\n_\n \nmessage\n:\n \nString\n,\n \ncolor\n:\n \nAnsiColor\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n  \ninit\n()\n \n{}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\n\n  \nsupports\n:\n \n[\nLogger\n.\nself\n,\n \nConsole\n.\nself\n],\n\n  \nErrorLogger\n()\n\n\n)\n\n\n\n\n\n\nRegistering for a specific requester\n\n\nSometimes, the implementation should change depending on the user. A database connector might need to run over a VPN tunnel, redis might use an optimized local loopback whilst the default implementation is a normal TCP socket.\n\n\nOther times, you simply want to change the log destination depending on the type that's logging (such as logging HTTP errors differently from database errors).\n\n\nThis comes in useful when changing configurations per situation, too.\n\n\nstruct\n \nVerboseLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n}\n\n\n\nstruct\n \nErrorLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nif\n \nlevel\n \n==\n \n.\nerror\n \n{\n\n      \nprint\n(\nmessage\n)\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n// Only log errors\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nErrorLogger\n())\n\n\n\n// Except the router, do log not found errors verbosely\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nPrintLogger\n(),\n \nfor\n:\n \nRouter\n.\nself\n)\n\n\n\n\n\n\nFactorized services\n\n\nSome services have dependencies. An extremly useful use case is TLS, where the implementation is separated from the protocol. This allows users to create a TLS socket to connect to another host without relying on a specific implementation. Vapor uses this to better integrate with the operating system by changing the default TLS implementation from OpenSSL on Linux to the Transport Security Framework on macOS and iOS.\n\n\nFactorized services get access to the event loop to factorize dependencies.\n\n\nservices\n.\nregister\n \n{\n \ncontainer\n \n-\n \nGithubClient\n \nin\n\n  \n// Create an HTTP client for our GithubClient\n\n  \nlet\n \nclient\n \n=\n \ntry\n \ncontainer\n.\nmake\n(\nClient\n.\nself\n,\n \nfor\n:\n \nGithubClient\n.\nself\n)\n\n  \ntry\n \nclient\n.\nconnect\n(\nhostname\n:\n \ngithub.com\n,\n \nssl\n:\n \ntrue\n)\n\n\n  \nreturn\n \nGithubClient\n(\nusing\n:\n \nclient\n)\n\n\n}\n\n\n\n\n\n\nPlease do note that we explicitly stated that the \nGithubClient\n requests an (HTTP) Client. We recommend doing this at all times, so that you leave configuration options open.\n\n\nEnvironments\n\n\nVapor 3 supports (custom) environments. By default we recommend (and support) the \n.production\n, \n.development\n and \n.testing\n environments.\n\n\nYou can create a custom environment type as \n.custom(\nmy-environment-name\n)\n.\n\n\nlet\n \nenvironment\n \n=\n \nEnvironment\n.\ncustom\n(\nstaging\n)\n\n\n\n\n\n\nContainers give access to the current environment, so libraries may change behaviour depending on the environment.\n\n\nChanging configurations per environment\n\n\nFor easy of development, some parameters may and should change for easy of debugging.\nPassword hashes can be made intentionally weaker in development scenarios to compensate for debug compilation performance, or API tokens may change to the correct one for your environment.\n\n\nservices\n.\nregister\n \n{\n \ncontainer\n \n-\n \nBCryptConfig\n \nin\n\n  \nlet\n \ncost\n:\n \nInt\n\n\n  \nswitch\n \ncontainer\n.\nenvironment\n \n{\n\n  \ncase\n \n.\nproduction\n:\n\n      \ncost\n \n=\n \n12\n\n  \ndefault\n:\n\n      \ncost\n \n=\n \n4\n\n  \n}\n\n\n  \nreturn\n \nBCryptConfig\n(\ncost\n:\n \ncost\n)\n\n\n}\n\n\n\n\n\n\nGetting a Service\n\n\nTo get a service you need an existing container matching the current EventLoop.\nIf you're processing a \nRequest\n, you should almost always use the Request as a Container type.\n\n\n// ErrorLogger\n\n\nlet\n \nerrorLogger\n \n=\n \nmyContainerType\n.\nmake\n(\nLogger\n.\nself\n,\n \nfor\n:\n \nRequest\n.\nself\n)\n\n\n\n// PrintLogger\n\n\nlet\n \nprintLogger\n \n=\n \nmyContainerType\n.\nmake\n(\nLogger\n.\nself\n,\n \nfor\n:\n \nRouter\n.\nself\n)", 
            "title": "Services"
        }, 
        {
            "location": "/getting-started/services/#services", 
            "text": "Services is a framework for creating things you need in your application in a type-safe fashion with protocol and environment support.  The Services framework is designed to be thread unsafe. The framework aims to guarantee that a service exists on the same  EventLoop  it was created from and will be used on.", 
            "title": "Services"
        }, 
        {
            "location": "/getting-started/services/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/getting-started/services/#container", 
            "text": "Containers are  EventLoops  that can create and cache services.  Request  is the most common  Container  type, which can be accessed in every  Route .  Containers cache instances of a given service (keyed by the requested protocol) on a per-container basis.   Any given container has its own cache. No two containers will ever share a service instance, whether singleton or not.  A singleton service is chosen and cached only by which interface(s) it supports and the service tag.\nThere will only ever be one instance of a singleton service per-container, regardless of what requested it.  A normal service is chosen and cached by which interface(s) it supports, the service tag, and the requesting client interface.\nThere will be as many instances of a normal service per-container as there are unique clients requesting it.\n(Remembering that clients are also interface types, not instances - that's the  for:  parameter to  .make() )", 
            "title": "Container"
        }, 
        {
            "location": "/getting-started/services/#ephemeralcontainer", 
            "text": "EphemeralContainers are containers that are short-lived.\nTheir cache does not stretch beyond a short lifecycle.\nThe most common EphemeralContainer is an  HTTP Request  which lives for the duration of the route handler.", 
            "title": "EphemeralContainer"
        }, 
        {
            "location": "/getting-started/services/#service", 
            "text": "Services are a type that can be requested from a Container. They are registered as part of the application setup.  Services are registered to a matching type or protocol it can represent, including it's own concrete type.  Services are registered to a blueprint before the  Application  is initialized. Together they make up the blueprint that Containers use to create an individual Service.", 
            "title": "Service"
        }, 
        {
            "location": "/getting-started/services/#environment", 
            "text": "Environments indicate the type of deployment/situation in which an application is ran. Environments can be used to change database credentials or API tokens per environment automatically.", 
            "title": "Environment"
        }, 
        {
            "location": "/getting-started/services/#registering", 
            "text": "Services are registered as a concrete (singleton) type or factories. Singleton types should be a struct, but can be a class.  To create an empty list of Services you can call the initializer without parameters  var   services   =   Services ()   The Vapor framework has a default setup with the most common (and officially supported) Services already registered.  var   services   =   Services . default ()", 
            "title": "Registering"
        }, 
        {
            "location": "/getting-started/services/#concrete-implementations", 
            "text": "A common use case for registering a struct is for registering configurations.\nVapor 3 configurations are  always  a concrete struct type. Registering a concrete type is simple:  struct   EmptyService   {}  services . instance ( EmptyService ())", 
            "title": "Concrete implementations"
        }, 
        {
            "location": "/getting-started/services/#singletons", 
            "text": "Singleton services (which declare themselves, or were registered, as such) are cached on a per-container basis, but the singleton cache ignores which Client is requesting the service (whereas the normal cache does not).  Singleton classes  must  be thread-safe to prevent crashes. If you want your class to be a singleton type (across all threads):  final   class   SingletonService   { \n   init ()   {}  }  services . instance ( isSingleton :   true ,   SingletonService ())   Assuming the above service, you can now make this service from a container. The global container in Vapor is  Application  which  must not  be used within routes.  let   app   =   try   Application ( services :   services )  let   emptyService   =   app . make ( EmptyService . self )", 
            "title": "Singletons"
        }, 
        {
            "location": "/getting-started/services/#protocol-conforming-services", 
            "text": "Often times when registering a service is conforms to one or more protocols for which it can be used. This is one of the more widely used use cases for Services.  enum   Level   { \n   case   verbose ,   error  }  protocol   Logger   { \n   func   log ( _   message :   String ,   level :   Level )  }  struct   PrintLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   }  }  services . instance ( Logger . self ,   PrintLogger ())   The above can be combined with  isSingleton: true", 
            "title": "Protocol conforming services"
        }, 
        {
            "location": "/getting-started/services/#registering-multiple-conformances", 
            "text": "A single type can conform to multiple protocols, and you might want to register a single service for all those conforming situations.  protocol   Console   { \n   func   write ( _   message :   String ,   color :   AnsiColor )  }  struct   PrintConsole :   Console ,   Logger   { \n   func   write ( _   message :   String ,   color :   AnsiColor )   { \n     print ( message ) \n   } \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   } \n\n   init ()   {}  }  services . instance ( \n   supports :   [ Logger . self ,   Console . self ], \n   ErrorLogger ()  )", 
            "title": "Registering multiple conformances"
        }, 
        {
            "location": "/getting-started/services/#registering-for-a-specific-requester", 
            "text": "Sometimes, the implementation should change depending on the user. A database connector might need to run over a VPN tunnel, redis might use an optimized local loopback whilst the default implementation is a normal TCP socket.  Other times, you simply want to change the log destination depending on the type that's logging (such as logging HTTP errors differently from database errors).  This comes in useful when changing configurations per situation, too.  struct   VerboseLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   }  }  struct   ErrorLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     if   level   ==   . error   { \n       print ( message ) \n     } \n   }  }  // Only log errors  services . instance ( Logger . self ,   ErrorLogger ())  // Except the router, do log not found errors verbosely  services . instance ( Logger . self ,   PrintLogger (),   for :   Router . self )", 
            "title": "Registering for a specific requester"
        }, 
        {
            "location": "/getting-started/services/#factorized-services", 
            "text": "Some services have dependencies. An extremly useful use case is TLS, where the implementation is separated from the protocol. This allows users to create a TLS socket to connect to another host without relying on a specific implementation. Vapor uses this to better integrate with the operating system by changing the default TLS implementation from OpenSSL on Linux to the Transport Security Framework on macOS and iOS.  Factorized services get access to the event loop to factorize dependencies.  services . register   {   container   -   GithubClient   in \n   // Create an HTTP client for our GithubClient \n   let   client   =   try   container . make ( Client . self ,   for :   GithubClient . self ) \n   try   client . connect ( hostname :   github.com ,   ssl :   true ) \n\n   return   GithubClient ( using :   client )  }   Please do note that we explicitly stated that the  GithubClient  requests an (HTTP) Client. We recommend doing this at all times, so that you leave configuration options open.", 
            "title": "Factorized services"
        }, 
        {
            "location": "/getting-started/services/#environments", 
            "text": "Vapor 3 supports (custom) environments. By default we recommend (and support) the  .production ,  .development  and  .testing  environments.  You can create a custom environment type as  .custom( my-environment-name ) .  let   environment   =   Environment . custom ( staging )   Containers give access to the current environment, so libraries may change behaviour depending on the environment.", 
            "title": "Environments"
        }, 
        {
            "location": "/getting-started/services/#changing-configurations-per-environment", 
            "text": "For easy of development, some parameters may and should change for easy of debugging.\nPassword hashes can be made intentionally weaker in development scenarios to compensate for debug compilation performance, or API tokens may change to the correct one for your environment.  services . register   {   container   -   BCryptConfig   in \n   let   cost :   Int \n\n   switch   container . environment   { \n   case   . production : \n       cost   =   12 \n   default : \n       cost   =   4 \n   } \n\n   return   BCryptConfig ( cost :   cost )  }", 
            "title": "Changing configurations per environment"
        }, 
        {
            "location": "/getting-started/services/#getting-a-service", 
            "text": "To get a service you need an existing container matching the current EventLoop.\nIf you're processing a  Request , you should almost always use the Request as a Container type.  // ErrorLogger  let   errorLogger   =   myContainerType . make ( Logger . self ,   for :   Request . self )  // PrintLogger  let   printLogger   =   myContainerType . make ( Logger . self ,   for :   Router . self )", 
            "title": "Getting a Service"
        }, 
        {
            "location": "/getting-started/cloud/", 
            "text": "Deployment\n\n\nDeploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.\n\n\nVapor Cloud\n\n\nThe best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.\n\n\nDeploying your project to Vapor Cloud is simple, it's built right into the \nVapor Toolbox\n.\nJust run this command from within the root directory of your project.\n\n\nvapor cloud deploy\n\n\n\n\n\nFor a detailed guide, visit \nVapor Cloud \n Quick Start\n.\n\n\nOther Options\n\n\nVapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout \nDeploy \n Getting Started", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#deployment", 
            "text": "Deploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#vapor-cloud", 
            "text": "The best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.  Deploying your project to Vapor Cloud is simple, it's built right into the  Vapor Toolbox .\nJust run this command from within the root directory of your project.  vapor cloud deploy  For a detailed guide, visit  Vapor Cloud   Quick Start .", 
            "title": "Vapor Cloud"
        }, 
        {
            "location": "/getting-started/cloud/#other-options", 
            "text": "Vapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout  Deploy   Getting Started", 
            "title": "Other Options"
        }, 
        {
            "location": "/routing/getting-started/", 
            "text": "Basics\n\n\nIn Vapor the default Router is the \nEngineRouter\n. You can implement custom routers by implementing one conformant to the \nRouter\n protocol.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \nEngineRouter\n.\ndefault\n()\n\n\n\n\n\n\nThere are two APIs available, one is supplied by the \nRouting\n library and a set of helpers is available in Vapor itself.\n\n\nRegistering a route using Routing\n\n\nThe \non\n function on a \nAsyncRouter\n registers a route to the provided path. The following registers a \nGET /hello/world\n route.\n\n\nIt responds with \n\"Hello world!\"\n using futures.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nhello\n,\n \nworld\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \ntry\n \nResponse\n(\nbody\n:\n \nHello world!\n)\n \n\n}\n\n\n\n\n\n\nThe \n.get\n represents the \nMethod\n you want to use. \nto: \"hello\", \"world\"\n registers the path \n/hello/world\n.\n\n\nFor variable path components you can use \nparameters\n.\n\n\nThe trailing closure receives a \nRequest\n. The route can throw errors and needs to return a \nFuture\nResponseRepresentable\n conforming type.\n\n\nRegistering a route using Vapor\n\n\nIn Vapor we add support for routes using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands.\n\n\nFor variable path components you can use \nparameters\n here, too.\n\n\nVapor has an added benefit here in that you can return the \nResponse\n itself in addition to \nFuture\nResponseRepresentable\n or \nFuture\nResponse\n.\n\n\nrouter\n.\nget\n(\ncomponents\n,\n \nin\n,\n \npath\n)\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}\n\n\n\n\n\n\nAfter registering your routes\n\n\nAfter registering routes to the Router, you must add the router to your services.\n\n\nservices\n.\ninstance\n(\nRouter\n.\nself\n,\n \nrouter\n)\n\n\n\n\n\n\nMore about services here.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/routing/getting-started/#basics", 
            "text": "In Vapor the default Router is the  EngineRouter . You can implement custom routers by implementing one conformant to the  Router  protocol.  let   router   =   try   EngineRouter . default ()   There are two APIs available, one is supplied by the  Routing  library and a set of helpers is available in Vapor itself.", 
            "title": "Basics"
        }, 
        {
            "location": "/routing/getting-started/#registering-a-route-using-routing", 
            "text": "The  on  function on a  AsyncRouter  registers a route to the provided path. The following registers a  GET /hello/world  route.  It responds with  \"Hello world!\"  using futures.  router . on (. get ,   to :   hello ,   world )   {   request   in \n   return   try   Response ( body :   Hello world! )   }   The  .get  represents the  Method  you want to use.  to: \"hello\", \"world\"  registers the path  /hello/world .  For variable path components you can use  parameters .  The trailing closure receives a  Request . The route can throw errors and needs to return a  Future ResponseRepresentable  conforming type.", 
            "title": "Registering a route using Routing"
        }, 
        {
            "location": "/routing/getting-started/#registering-a-route-using-vapor", 
            "text": "In Vapor we add support for routes using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands.  For variable path components you can use  parameters  here, too.  Vapor has an added benefit here in that you can return the  Response  itself in addition to  Future ResponseRepresentable  or  Future Response .  router . get ( components ,   in ,   path )   {   request   in \n   return   Response ( status :   . ok )  }", 
            "title": "Registering a route using Vapor"
        }, 
        {
            "location": "/routing/getting-started/#after-registering-your-routes", 
            "text": "After registering routes to the Router, you must add the router to your services.  services . instance ( Router . self ,   router )   More about services here.", 
            "title": "After registering your routes"
        }, 
        {
            "location": "/routing/parameters/", 
            "text": "Parameters\n\n\nParameters are a registered type that can be initialized from a String.\n\n\nThey can be part of a \nRoute\n, and be extracted from \nRequests\n that are called in that Route.\n\n\nCreating custom parameters\n\n\nTo create a custom parameter type, simply conform to \nParameter\n and implement the conversion function \nmake\n and a unique slug.\n\n\nIn this example, the \nUser\n class will be initialized from a parameter that represents it's identifier.\n\n\nWe recommend prefixing custom Parameter identifiers.\n\n\nclass\n \nUser\n \n:\n \nParameter\n \n{\n\n  \nvar\n \nusername\n:\n \nString\n\n\n  \n// The unique (prefixed) identifier for this type\n\n  \nstatic\n \nvar\n \nuniqueSlug\n \n=\n \nmy-app:user\n\n\n  \n// Creates a new user from the raw `parameter`\n\n  \nstatic\n \nfunc\n \nmake\n(\nfor\n \nparameter\n:\n \nString\n,\n \nin\n \nrequest\n:\n \nRequest\n)\n \nthrows\n \n-\n \nUser\n \n{\n\n    \nreturn\n \nUser\n(\nnamed\n:\n \nparameter\n)\n\n  \n}\n\n\n  \ninit\n(\nnamed\n \nusername\n:\n \nString\n)\n \n{\n\n    \nself\n.\nusername\n \n=\n \nusername\n\n  \n}\n\n\n}\n\n\n\n\n\n\nUsing (custom) parameters\n\n\nAfter conforming a type to \nParameter\n you can access it's static property \nparameter\n as part of a path.\n\n\nrouter\n.\non\n(.\nget\n,\n \nto\n:\n \nusers\n,\n \nUser\n.\nparameter\n,\n \nprofile\n)\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nuser\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nUser\n.\nself\n)\n\n\n  \n// Return the user\ns Profile sync or async (depending on the router)\n\n\n}", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#parameters", 
            "text": "Parameters are a registered type that can be initialized from a String.  They can be part of a  Route , and be extracted from  Requests  that are called in that Route.", 
            "title": "Parameters"
        }, 
        {
            "location": "/routing/parameters/#creating-custom-parameters", 
            "text": "To create a custom parameter type, simply conform to  Parameter  and implement the conversion function  make  and a unique slug.  In this example, the  User  class will be initialized from a parameter that represents it's identifier.  We recommend prefixing custom Parameter identifiers.  class   User   :   Parameter   { \n   var   username :   String \n\n   // The unique (prefixed) identifier for this type \n   static   var   uniqueSlug   =   my-app:user \n\n   // Creates a new user from the raw `parameter` \n   static   func   make ( for   parameter :   String ,   in   request :   Request )   throws   -   User   { \n     return   User ( named :   parameter ) \n   } \n\n   init ( named   username :   String )   { \n     self . username   =   username \n   }  }", 
            "title": "Creating custom parameters"
        }, 
        {
            "location": "/routing/parameters/#using-custom-parameters", 
            "text": "After conforming a type to  Parameter  you can access it's static property  parameter  as part of a path.  router . on (. get ,   to :   users ,   User . parameter ,   profile )   {   request   in \n   let   user   =   try   request . parameters . next ( User . self ) \n\n   // Return the user s Profile sync or async (depending on the router)  }", 
            "title": "Using (custom) parameters"
        }, 
        {
            "location": "/routing/route/", 
            "text": "Route\n\n\nRoute is an object that contains the essential information of an HTTP Route.\n\n\nIt contains the route's Method, path components and responder.\n\n\nExtensions\n\n\nRoutes are Extensible using the \nextend\n property. This allow storing additional data for use by integrating libraries.\n\n\nThe purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#route", 
            "text": "Route is an object that contains the essential information of an HTTP Route.  It contains the route's Method, path components and responder.", 
            "title": "Route"
        }, 
        {
            "location": "/routing/route/#extensions", 
            "text": "Routes are Extensible using the  extend  property. This allow storing additional data for use by integrating libraries.  The purpose is to allow tools (such as documentation tools) to hook into the Vapor routing process.", 
            "title": "Extensions"
        }, 
        {
            "location": "/routing/router/", 
            "text": "Router\n\n\nRouter is a protocol that you can conform your own routers to.\n\n\nRegistering a route\n\n\nFirst, create a \nRoute\n using a \nMethod\n, path and a responder.\n\n\nThe following example shows a route with a constant path.\n\n\nlet\n \nresponder\n \n=\n \nBasicAsyncResponder\n \n{\n \nrequest\n \nin\n\n  \nreturn\n \nHello world\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\nhello\n),\n \n.\nconstant\n(\nworld\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nThe following example shows a with a \nParameter\n:\n\n\nlet\n \nresponder\n \n=\n \nBasicSyncResponder\n \n{\n \nrequest\n \nin\n\n  \nlet\n \nname\n \n=\n \ntry\n \nrequest\n.\nparameters\n.\nnext\n(\nString\n.\nself\n)\n\n  \nreturn\n \nHello \n\\(\nname\n)\n\n\n}\n\n\n\nlet\n \nroute\n \n=\n \nRoute\n(\nmethod\n:\n \n.\nget\n,\n \npath\n:\n \n[.\nconstant\n(\ngreet\n),\n \n.\nparameter\n(\nString\n.\nself\n)],\n \nresponder\n:\n \nresponder\n)\n\n\n\n\n\n\nRouting a request through a Router\n\n\nAssuming you have a request, like the following example:\n\n\nlet\n \nrequest\n \n=\n \nRequest\n(\nmethod\n:\n \n.\nget\n,\n \nURI\n(\npath\n:\n \n/hello/world\n))\n\n\n\n\n\n\nThe router should be able to route the \nRequest\n using\n\n\nlet\n \nresponder\n \n=\n \nrouter\n.\nroute\n(\nrequest\n:\n \nrequest\n)", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#router", 
            "text": "Router is a protocol that you can conform your own routers to.", 
            "title": "Router"
        }, 
        {
            "location": "/routing/router/#registering-a-route", 
            "text": "First, create a  Route  using a  Method , path and a responder.  The following example shows a route with a constant path.  let   responder   =   BasicAsyncResponder   {   request   in \n   return   Hello world  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( hello ),   . constant ( world )],   responder :   responder )   The following example shows a with a  Parameter :  let   responder   =   BasicSyncResponder   {   request   in \n   let   name   =   try   request . parameters . next ( String . self ) \n   return   Hello  \\( name )  }  let   route   =   Route ( method :   . get ,   path :   [. constant ( greet ),   . parameter ( String . self )],   responder :   responder )", 
            "title": "Registering a route"
        }, 
        {
            "location": "/routing/router/#routing-a-request-through-a-router", 
            "text": "Assuming you have a request, like the following example:  let   request   =   Request ( method :   . get ,   URI ( path :   /hello/world ))   The router should be able to route the  Request  using  let   responder   =   router . route ( request :   request )", 
            "title": "Routing a request through a Router"
        }, 
        {
            "location": "/fluent/getting-started/", 
            "text": "Getting Started with Fluent\n\n\nFluent (\nvapor/fluent\n) is a type-safe, fast, and easy-to-use ORM framework built for Swift.\nIt takes advantage of Swift's strong type system to provide an elegant foundation for building database integrations.\n\n\nDatabase\n\n\nFluent is just a framework for building ORMs, not an ORM itself. To get started using Fluent, pick one of the databases below.\n\n\n\n\n\n\n\n\ndatabase\n\n\nlibrary\n\n\ndriver\n\n\nguide\n\n\n\n\n\n\n\n\n\n\nPostgreSQL\n\n\nvapor/postgresql\n\n\nvapor/fluent-postgresql\n\n\nGetting Started \n\n\n\n\n\n\nMySQL\n\n\nvapor/mysql\n\n\nvapor/fluent-mysql\n\n\nGetting Started \n\n\n\n\n\n\nSQLite\n\n\nvapor/sqlite\n\n\nvapor/fluent-sqlite\n\n\nGetting Started \n\n\n\n\n\n\n\n\nAfter you get started, come back to the other sections in this guide for a more in-depth look at Fluent's features.\n\n\n\n\nTip\n\n\nYou can also search GitHub for the tag \nfluent-database\n for a full list of official and third-party Fluent databases.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/fluent/getting-started/#getting-started-with-fluent", 
            "text": "Fluent ( vapor/fluent ) is a type-safe, fast, and easy-to-use ORM framework built for Swift.\nIt takes advantage of Swift's strong type system to provide an elegant foundation for building database integrations.", 
            "title": "Getting Started with Fluent"
        }, 
        {
            "location": "/fluent/getting-started/#database", 
            "text": "Fluent is just a framework for building ORMs, not an ORM itself. To get started using Fluent, pick one of the databases below.     database  library  driver  guide      PostgreSQL  vapor/postgresql  vapor/fluent-postgresql  Getting Started     MySQL  vapor/mysql  vapor/fluent-mysql  Getting Started     SQLite  vapor/sqlite  vapor/fluent-sqlite  Getting Started      After you get started, come back to the other sections in this guide for a more in-depth look at Fluent's features.   Tip  You can also search GitHub for the tag  fluent-database  for a full list of official and third-party Fluent databases.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/models/", 
            "text": "Getting Started with Models\n\n\nModels are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped\narrays or dictionaries for queries. Instead, you query the database using models. This allows the\nSwift compiler to catch many errors that have burdened ORM users for ages.\n\n\nIn this guide, we will cover the creation of a basic \nUser\n model.\n\n\nClass\n\n\nEvery Fluent model starts with a \nCodable\n class. You can make any \nCodable\n class a Fluent model,\neven ones that come from a different module. All you have to do is conform to \nModel\n.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nContent\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\n\n\n\nAlthough it's not necessary, adding \nfinal\n to your Swift classes can make them more performant\nand also make adding \ninit\n methods in extensions easier.\n\n\nConforming to Model\n\n\nNow that we have our \nUser\n class, let's conform it to \nModel\n.\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n\n\n}\n\n\n\n\n\n\nOnce you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make \nUser\n conform to model.\n\n\n\n\nTip\n\n\nWe recommend adding \nModel\n conformance in an extension to help keep your code clean.\n\n\n\n\nDatabase\n\n\nThe first step to conforming to \nModel\n is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.\n\n\nimport\n \nFluentMySQL\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n}\n\n\n\n\n\n\nID\n\n\nNow we can tell Fluent what type of ID this model uses. In this example, our \nUser\n model\nhas an ID property of type \nUUID\n named \nid\n.\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFoundation\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n...\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can use any type that conforms to \nIDType\n as a Fluent ID. See \nFluent \n Model \n ID\n for more information.\nYou can also use any property name you'd like for the id.\n\n\n\n\nWarning\n\n\nSome databases require certain ID keys. For example, MongoDB requires \n_id\n.\n\n\n\n\nExample\n\n\nWe now have a fully-conformed Fluent model!\n\n\nimport\n \nFluentMySQL\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nUser\n:\n \nCodable\n \n{\n\n    \nvar\n \nid\n:\n \nUUID\n?\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nage\n:\n \nInt\n\n\n}\n\n\n\nextension\n \nUser\n:\n \nModel\n \n{\n\n    \n/// See Model.Database\n\n    \ntypealias\n \nDatabase\n \n=\n \nMySQLDatabase\n\n\n    \n/// See Model.ID\n\n    \ntypealias\n \nID\n \n=\n \nUUID\n\n\n    \n/// See Model.idKey\n\n    \nstatic\n \nvar\n \nidKey\n:\n \nIDKey\n \n{\n\n        \nreturn\n \n\\\n.\nid\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model, you can move onto \nquerying\n your model.\nHowever, if your database uses schemas, you may need to create a \nmigration\n for your model first.", 
            "title": "Models"
        }, 
        {
            "location": "/fluent/models/#getting-started-with-models", 
            "text": "Models are the heart of Fluent. Unlike ORMs in other languages, Fluent doesn't return untyped\narrays or dictionaries for queries. Instead, you query the database using models. This allows the\nSwift compiler to catch many errors that have burdened ORM users for ages.  In this guide, we will cover the creation of a basic  User  model.", 
            "title": "Getting Started with Models"
        }, 
        {
            "location": "/fluent/models/#class", 
            "text": "Every Fluent model starts with a  Codable  class. You can make any  Codable  class a Fluent model,\neven ones that come from a different module. All you have to do is conform to  Model .  import   Foundation  import   Vapor  final   class   User :   Content   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }   Although it's not necessary, adding  final  to your Swift classes can make them more performant\nand also make adding  init  methods in extensions easier.", 
            "title": "Class"
        }, 
        {
            "location": "/fluent/models/#conforming-to-model", 
            "text": "Now that we have our  User  class, let's conform it to  Model .  import   FluentMySQL  extension   User :   Model   {  }   Once you add this conformance requirement, Swift will tell you that it does not yet conform.\nLet's add the necessary items to make  User  conform to model.   Tip  We recommend adding  Model  conformance in an extension to help keep your code clean.", 
            "title": "Conforming to Model"
        }, 
        {
            "location": "/fluent/models/#database", 
            "text": "The first step to conforming to  Model  is to let Fluent know which type of database you plan\non using this model with. This allows Fluent to enable database-specific features wherever you\nuse this model.  import   FluentMySQL  extension   User :   Model   { \n     ... \n\n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase  }", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/models/#id", 
            "text": "Now we can tell Fluent what type of ID this model uses. In this example, our  User  model\nhas an ID property of type  UUID  named  id .  import   FluentMySQL  import   Foundation  extension   User :   Model   { \n     ... \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     }  }   You can use any type that conforms to  IDType  as a Fluent ID. See  Fluent   Model   ID  for more information.\nYou can also use any property name you'd like for the id.   Warning  Some databases require certain ID keys. For example, MongoDB requires  _id .", 
            "title": "ID"
        }, 
        {
            "location": "/fluent/models/#example", 
            "text": "We now have a fully-conformed Fluent model!  import   FluentMySQL  import   Foundation  import   Vapor  final   class   User :   Codable   { \n     var   id :   UUID ? \n     var   name :   String \n     var   age :   Int  }  extension   User :   Model   { \n     /// See Model.Database \n     typealias   Database   =   MySQLDatabase \n\n     /// See Model.ID \n     typealias   ID   =   UUID \n\n     /// See Model.idKey \n     static   var   idKey :   IDKey   { \n         return   \\ . id \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/models/#done", 
            "text": "Now that you have a working Fluent model, you can move onto  querying  your model.\nHowever, if your database uses schemas, you may need to create a  migration  for your model first.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/migrations/", 
            "text": "Getting Started with Migrations\n\n\nMigrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!\n\n\nMigrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.\n\n\nIn this guide we will cover creating both types of migrations.\n\n\nModel Schema\n\n\nLet's take a look at how we can prepare a schema supporting database to accept the \n\nUser\n model from the \nprevious section\n.\n\n\nJust like we did with the \nModel\n protocol, we will conform our \nUser\n to \nMigration\n.\n\n\nimport\n \nFluent\n\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n\n\n}\n\n\n\n\n\n\nSwift will inform us that \nUser\n does not yet conform. Let's add the required methods!\n\n\nPrepare\n\n\nThe first method to implement is \nprepare\n. This method is where you make any of your \ndesired changes to the database.\n\n\nFor our \nUser\n model, we simply want to create a table that can store one or more users. To do this,\nwe will use the \n.create(...)\n function on the supplied database connection.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe pass \nself\n (shorthand for \nUser.self\n since this is a static method) as the first argument to the \n.create\n method. This indicates\nto Fluent that we would like to create a schema for the \nUser\n model.\n\n\nNext, we pass a closure that accepts a \nSchemaBuilder\n for our \nUser\n model.\nWe can then call \n.field\non this builder to describe what fields we'd like our table to have.\n\n\nSince we are passing key paths to our \nUser\n model (indicated by \n\\.\n), Fluent can see what type those properties are.\nFor most common types (\nString\n, \nInt\n, \nDouble\n, etc) Fluent will automatically be able to determine the best\ndatabase field type to use.\n\n\nYou can also choose to manually select which database field type to use for a given field.\n\n\ntry\n \nbuilder\n.\nfield\n(\ntype\n:\n \n.\ntext\n,\n \nfor\n:\n \n\\\n.\nname\n)\n\n\n\n\n\n\nLearn more about creating, updating, and deleting schemas in \nFluent \n Schema Builder\n.\n\n\nRevert\n\n\nRevert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the \n--revert\n option. See \nFluent \n Migration\n for more information.\n\n\nTo implement \nrevert\n for our model, we simply use \n.delete\n to indicate that we would like to delete the schema created for \nUser\n.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nMySQLConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExample\n\n\nWe now have a fully functioning model with migration!\n\n\nextension\n \nTestUser\n:\n \nMigration\n \n{\n\n    \n/// See Migration.prepare\n\n    \nstatic\n \nfunc\n \nprepare\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ncreate\n(\nself\n)\n \n{\n \nbuilder\n \nin\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nid\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nname\n)\n\n            \ntry\n \nbuilder\n.\nfield\n(\nfor\n:\n \n\\\n.\nage\n)\n\n        \n}\n\n    \n}\n\n\n    \n/// See Migration.revert\n\n    \nstatic\n \nfunc\n \nrevert\n(\non\n \nconnection\n:\n \nSQLiteConnection\n)\n \n-\n \nFuture\nVoid\n \n{\n\n        \nreturn\n \nconnection\n.\ndelete\n(\nself\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDone\n\n\nNow that you have a working Fluent model and migration, you can move onto \nquerying\n your model.", 
            "title": "Migrations"
        }, 
        {
            "location": "/fluent/migrations/#getting-started-with-migrations", 
            "text": "Migrations are a way of making organized, testable, and reliable changes to your database's structure--\neven while it's in production!  Migrations are often used for preparing a database schema for your models. However, they can also be used to \nmake normal queries to your database.  In this guide we will cover creating both types of migrations.", 
            "title": "Getting Started with Migrations"
        }, 
        {
            "location": "/fluent/migrations/#model-schema", 
            "text": "Let's take a look at how we can prepare a schema supporting database to accept the  User  model from the  previous section .  Just like we did with the  Model  protocol, we will conform our  User  to  Migration .  import   Fluent  extension   User :   Migration   {  }   Swift will inform us that  User  does not yet conform. Let's add the required methods!", 
            "title": "Model Schema"
        }, 
        {
            "location": "/fluent/migrations/#prepare", 
            "text": "The first method to implement is  prepare . This method is where you make any of your \ndesired changes to the database.  For our  User  model, we simply want to create a table that can store one or more users. To do this,\nwe will use the  .create(...)  function on the supplied database connection.  extension   User :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     }  }   We pass  self  (shorthand for  User.self  since this is a static method) as the first argument to the  .create  method. This indicates\nto Fluent that we would like to create a schema for the  User  model.  Next, we pass a closure that accepts a  SchemaBuilder  for our  User  model.\nWe can then call  .field on this builder to describe what fields we'd like our table to have.  Since we are passing key paths to our  User  model (indicated by  \\. ), Fluent can see what type those properties are.\nFor most common types ( String ,  Int ,  Double , etc) Fluent will automatically be able to determine the best\ndatabase field type to use.  You can also choose to manually select which database field type to use for a given field.  try   builder . field ( type :   . text ,   for :   \\ . name )   Learn more about creating, updating, and deleting schemas in  Fluent   Schema Builder .", 
            "title": "Prepare"
        }, 
        {
            "location": "/fluent/migrations/#revert", 
            "text": "Revert is the opposite of prepare. It's job is to undo anything that was done in prepare. It is used when you boot your \napp with the  --revert  option. See  Fluent   Migration  for more information.  To implement  revert  for our model, we simply use  .delete  to indicate that we would like to delete the schema created for  User .  extension   User :   Migration   { \n     /// See Migration.revert \n     static   func   revert ( on   connection :   MySQLConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Revert"
        }, 
        {
            "location": "/fluent/migrations/#example", 
            "text": "We now have a fully functioning model with migration!  extension   TestUser :   Migration   { \n     /// See Migration.prepare \n     static   func   prepare ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . create ( self )   {   builder   in \n             try   builder . field ( for :   \\ . id ) \n             try   builder . field ( for :   \\ . name ) \n             try   builder . field ( for :   \\ . age ) \n         } \n     } \n\n     /// See Migration.revert \n     static   func   revert ( on   connection :   SQLiteConnection )   -   Future Void   { \n         return   connection . delete ( self ) \n     }  }", 
            "title": "Example"
        }, 
        {
            "location": "/fluent/migrations/#done", 
            "text": "Now that you have a working Fluent model and migration, you can move onto  querying  your model.", 
            "title": "Done"
        }, 
        {
            "location": "/fluent/querying/", 
            "text": "Querying Models\n\n\nOnce you have a \nmodel\n (and optionally a \nmigration\n) you can start\nquerying your database to create, read, update, and delete data.\n\n\nConnection\n\n\nThe first thing you need to query your database, is a connection to it. Luckily, they are easy to get.\n\n\nYou can use either the application or an incoming request to create a database connection. You just need\naccess to the \nDatabaseIdentifier\n.\n\n\nRequest\n\n\nThe preferred method for getting access to a database connection is via an incoming request.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \nin\n\n        \n// use the db here\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first parameter is the database's \nidentifier\n. The second parameter is a closure\nthat accepts a connection to that database.\n\n\n\n\nTip\n\n\nAlthough the closure to \n.withConnection(to: ...)\n accepts a database \nconnection\n, we often use just \ndb\n for short.\n\n\n\n\nThe closure is expected to return a \nFuture\nVoid\n. When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.\n\n\nApplication\n\n\nYou can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.\n\n\nlet\n \nres\n \n=\n \napp\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \nin\n\n    \n// use the db here\n\n\n}\n\n\nprint\n(\nres\n)\n \n// Future\nT\n\n\n\n\n\n\nThis is usually done in the \nboot section\n of your application.\n\n\n\n\nWarning\n\n\nDo not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.\n\n\n\n\nCreate\n\n\nTo create (save) a model to the database, first initialize an instance of your model, then call \n.save(on: )\n.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\ntransform\n(\nto\n:\n \nuser\n)\n \n// Future\nUser\n\n    \n}\n\n\n}\n\n\n\n\n\n\nResponse\n\n\n.save(on: )\n returns a \nFuture\nVoid\n that completes when the user has finished saving. In this example, we then\nmap that \nFuture\nVoid\n to a \nFuture\nUser\n by calling \n.map\n and passing in the recently-saved user.\n\n\nYou can also use \n.map\n to return a simple success response.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nHTTPResponse\n \nin\n\n        \nlet\n \nuser\n \n=\n \nUser\n(\nname\n:\n \nVapor\n,\n \nage\n:\n \n3\n)\n\n        \nreturn\n \nuser\n.\nsave\n(\non\n:\n \ndb\n).\nmap\n(\nto\n:\n \nHTTPResponse\n.\nself\n)\n \n{\n\n            \nreturn\n \nHTTPResponse\n(\nstatus\n:\n \n.\ncreated\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMultiple\n\n\nIf you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.\n\n\nrouter\n.\npost\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nHTTPResponse\n \nin\n\n        \nlet\n \nmarie\n \n=\n \nUser\n(\nname\n:\n \nMarie Curie\n,\n \nage\n:\n \n66\n)\n\n        \nlet\n \ncharles\n \n=\n \nUser\n(\nname\n:\n \nCharles Darwin\n,\n \nage\n:\n \n73\n)\n\n        \nreturn\n \n[\n\n            \nmarie\n.\nsave\n(\non\n:\n \ndb\n),\n\n            \ncharles\n.\nsave\n(\non\n:\n \ndb\n)\n\n        \n].\nmap\n(\nto\n:\n \nHTTPResponse\n.\nself\n)\n \n{\n\n            \nreturn\n \nHTTPResponse\n(\nstatus\n:\n \n.\ncreated\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRead\n\n\nTo read models from the database, use \n.query()\n on the database connection to create a \nQueryBuilder\n.\n\n\nAll\n\n\nFetch all instances of a model from the database using \n.all()\n.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFilter\n\n\nUse \n.filter(...)\n to apply \nfilters\n to your query.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\n[\nUser\n]\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nage\n \n \n50\n).\nall\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFirst\n\n\nYou can also use \n.first()\n to just get the first result.\n\n\nrouter\n.\nget\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nreturn\n \ntry\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfilter\n(\n\\\nUser\n.\nname\n \n==\n \nVapor\n).\nfirst\n().\nmap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \nin\n\n            \nguard\n \nlet\n \nuser\n \n=\n \nuser\n \nelse\n \n{\n\n                \nthrow\n \nAbort\n(.\nnotFound\n,\n \nreason\n:\n \nCould not find user.\n)\n\n            \n}\n\n\n            \nreturn\n \nuser\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice we use \n.map(to:)\n here to convert the optional user returned by \n.first()\n to a non-optional\nuser, or we throw an error.\n\n\nUpdate\n\n\nrouter\n.\nput\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nreturn\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfirst\n().\nmap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \nin\n\n            \nguard\n \nlet\n \nuser\n \n=\n \n$0\n \nelse\n \n{\n\n                \nthrow\n \nAbort\n(.\nnotFound\n,\n \nreason\n:\n \nCould not find user.\n)\n\n            \n}\n\n\n            \nreturn\n \nuser\n\n        \n}.\nflatMap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \nin\n\n            \nuser\n.\nage\n \n+=\n \n1\n\n            \nreturn\n \nuser\n.\nupdate\n(\non\n:\n \ndb\n).\nmap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \n}\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice we use \n.map(to:)\n here to convert the optional user returned by \n.first()\n to a non-optional\nuser, or we throw an error.\n\n\nDelete\n\n\nrouter\n.\ndelete\n(...)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\nfoo\n)\n \n{\n \ndb\n \n-\n \nFuture\nUser\n \nin\n\n        \nreturn\n \ndb\n.\nquery\n(\nUser\n.\nself\n).\nfirst\n().\nmap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \nin\n\n            \nguard\n \nlet\n \nuser\n \n=\n \n$0\n \nelse\n \n{\n\n                \nthrow\n \nAbort\n(.\nnotFound\n,\n \nreason\n:\n \nCould not find user.\n)\n\n            \n}\n\n            \nreturn\n \nuser\n\n        \n}.\nflatMap\n(\nto\n:\n \nUser\n.\nself\n)\n \n{\n \nuser\n \nin\n\n            \nreturn\n \nuser\n.\ndelete\n(\non\n:\n \ndb\n).\ntransfom\n(\nto\n:\n \nuser\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice we use \n.map(to:)\n here to convert the optional user returned by \n.first()\n to a non-optional\nuser, or we throw an error.", 
            "title": "Querying"
        }, 
        {
            "location": "/fluent/querying/#querying-models", 
            "text": "Once you have a  model  (and optionally a  migration ) you can start\nquerying your database to create, read, update, and delete data.", 
            "title": "Querying Models"
        }, 
        {
            "location": "/fluent/querying/#connection", 
            "text": "The first thing you need to query your database, is a connection to it. Luckily, they are easy to get.  You can use either the application or an incoming request to create a database connection. You just need\naccess to the  DatabaseIdentifier .", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/querying/#request", 
            "text": "The preferred method for getting access to a database connection is via an incoming request.  router . get (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   in \n         // use the db here \n     }  }   The first parameter is the database's  identifier . The second parameter is a closure\nthat accepts a connection to that database.   Tip  Although the closure to  .withConnection(to: ...)  accepts a database  connection , we often use just  db  for short.   The closure is expected to return a  Future Void . When this future is completed, the connection will be released\nback into Fluent's connection pool. This is usually acheived by simply returning the query as we will soon see.", 
            "title": "Request"
        }, 
        {
            "location": "/fluent/querying/#application", 
            "text": "You can also create a database connection using the application. This is useful for cases where you must access\nthe database from outside a request/response event.  let   res   =   app . withConnection ( to :   . foo )   {   db   in \n     // use the db here  }  print ( res )   // Future T   This is usually done in the  boot section  of your application.   Warning  Do not use database connections created by the application in a route closure (when responding to a request).\nAlways use the incoming request to create a connection to avoid threading issues.", 
            "title": "Application"
        }, 
        {
            "location": "/fluent/querying/#create", 
            "text": "To create (save) a model to the database, first initialize an instance of your model, then call  .save(on: ) .  router . post (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future User   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). transform ( to :   user )   // Future User \n     }  }", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/querying/#response", 
            "text": ".save(on: )  returns a  Future Void  that completes when the user has finished saving. In this example, we then\nmap that  Future Void  to a  Future User  by calling  .map  and passing in the recently-saved user.  You can also use  .map  to return a simple success response.  router . post (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future HTTPResponse   in \n         let   user   =   User ( name :   Vapor ,   age :   3 ) \n         return   user . save ( on :   db ). map ( to :   HTTPResponse . self )   { \n             return   HTTPResponse ( status :   . created ) \n         } \n     }  }", 
            "title": "Response"
        }, 
        {
            "location": "/fluent/querying/#multiple", 
            "text": "If you have multiple instances to save, do so using an array. Arrays containing only futures behave like futures.  router . post (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future HTTPResponse   in \n         let   marie   =   User ( name :   Marie Curie ,   age :   66 ) \n         let   charles   =   User ( name :   Charles Darwin ,   age :   73 ) \n         return   [ \n             marie . save ( on :   db ), \n             charles . save ( on :   db ) \n         ]. map ( to :   HTTPResponse . self )   { \n             return   HTTPResponse ( status :   . created ) \n         } \n     }  }", 
            "title": "Multiple"
        }, 
        {
            "location": "/fluent/querying/#read", 
            "text": "To read models from the database, use  .query()  on the database connection to create a  QueryBuilder .", 
            "title": "Read"
        }, 
        {
            "location": "/fluent/querying/#all", 
            "text": "Fetch all instances of a model from the database using  .all() .  router . get (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future [ User ]   in \n         return   db . query ( User . self ). all () \n     }  }", 
            "title": "All"
        }, 
        {
            "location": "/fluent/querying/#filter", 
            "text": "Use  .filter(...)  to apply  filters  to your query.  router . get (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future [ User ]   in \n         return   try   db . query ( User . self ). filter ( \\ User . age     50 ). all () \n     }  }", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/querying/#first", 
            "text": "You can also use  .first()  to just get the first result.  router . get (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future User   in \n         return   try   db . query ( User . self ). filter ( \\ User . name   ==   Vapor ). first (). map ( to :   User . self )   {   user   in \n             guard   let   user   =   user   else   { \n                 throw   Abort (. notFound ,   reason :   Could not find user. ) \n             } \n\n             return   user \n         } \n     }  }   Notice we use  .map(to:)  here to convert the optional user returned by  .first()  to a non-optional\nuser, or we throw an error.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/querying/#update", 
            "text": "router . put (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future User   in \n         return   db . query ( User . self ). first (). map ( to :   User . self )   {   user   in \n             guard   let   user   =   $0   else   { \n                 throw   Abort (. notFound ,   reason :   Could not find user. ) \n             } \n\n             return   user \n         }. flatMap ( to :   User . self )   {   user   in \n             user . age   +=   1 \n             return   user . update ( on :   db ). map ( to :   User . self )   {   user   } \n         } \n     }  }   Notice we use  .map(to:)  here to convert the optional user returned by  .first()  to a non-optional\nuser, or we throw an error.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/querying/#delete", 
            "text": "router . delete (...)   {   req   in \n     return   req . withConnection ( to :   . foo )   {   db   -   Future User   in \n         return   db . query ( User . self ). first (). map ( to :   User . self )   {   user   in \n             guard   let   user   =   $0   else   { \n                 throw   Abort (. notFound ,   reason :   Could not find user. ) \n             } \n             return   user \n         }. flatMap ( to :   User . self )   {   user   in \n             return   user . delete ( on :   db ). transfom ( to :   user ) \n         } \n     }  }   Notice we use  .map(to:)  here to convert the optional user returned by  .first()  to a non-optional\nuser, or we throw an error.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/query-builder/", 
            "text": "Fluent Query Builder\n\n\nComing soon.\n\n\nFilter\n\n\nComing soon.\n\n\nCompare\n\n\nComing soon.\n\n\nGroup\n\n\nComing soon.\n\n\nSubset\n\n\nComing soon.\n\n\nJoin\n\n\nComing soon.\n\n\nRange\n\n\nComing soon.\n\n\nSort\n\n\nComing soon.\n\n\nExecute\n\n\nComing soon.\n\n\nAggregate\n\n\nComing soon.\n\n\nAll\n\n\nComing soon.\n\n\nFirst\n\n\nComing soon.\n\n\nQuery\n\n\nComing soon.", 
            "title": "Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#fluent-query-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Query Builder"
        }, 
        {
            "location": "/fluent/query-builder/#filter", 
            "text": "Coming soon.", 
            "title": "Filter"
        }, 
        {
            "location": "/fluent/query-builder/#compare", 
            "text": "Coming soon.", 
            "title": "Compare"
        }, 
        {
            "location": "/fluent/query-builder/#group", 
            "text": "Coming soon.", 
            "title": "Group"
        }, 
        {
            "location": "/fluent/query-builder/#subset", 
            "text": "Coming soon.", 
            "title": "Subset"
        }, 
        {
            "location": "/fluent/query-builder/#join", 
            "text": "Coming soon.", 
            "title": "Join"
        }, 
        {
            "location": "/fluent/query-builder/#range", 
            "text": "Coming soon.", 
            "title": "Range"
        }, 
        {
            "location": "/fluent/query-builder/#sort", 
            "text": "Coming soon.", 
            "title": "Sort"
        }, 
        {
            "location": "/fluent/query-builder/#execute", 
            "text": "Coming soon.", 
            "title": "Execute"
        }, 
        {
            "location": "/fluent/query-builder/#aggregate", 
            "text": "Coming soon.", 
            "title": "Aggregate"
        }, 
        {
            "location": "/fluent/query-builder/#all", 
            "text": "Coming soon.", 
            "title": "All"
        }, 
        {
            "location": "/fluent/query-builder/#first", 
            "text": "Coming soon.", 
            "title": "First"
        }, 
        {
            "location": "/fluent/query-builder/#query", 
            "text": "Coming soon.", 
            "title": "Query"
        }, 
        {
            "location": "/fluent/schema-builder/", 
            "text": "Fluent Schema Builder\n\n\nComing soon.\n\n\nCreate\n\n\nComing soon.\n\n\nUpdate\n\n\nComing soon.\n\n\nDelete\n\n\nComing soon.\n\n\nReferences\n\n\nComing soon.", 
            "title": "Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#fluent-schema-builder", 
            "text": "Coming soon.", 
            "title": "Fluent Schema Builder"
        }, 
        {
            "location": "/fluent/schema-builder/#create", 
            "text": "Coming soon.", 
            "title": "Create"
        }, 
        {
            "location": "/fluent/schema-builder/#update", 
            "text": "Coming soon.", 
            "title": "Update"
        }, 
        {
            "location": "/fluent/schema-builder/#delete", 
            "text": "Coming soon.", 
            "title": "Delete"
        }, 
        {
            "location": "/fluent/schema-builder/#references", 
            "text": "Coming soon.", 
            "title": "References"
        }, 
        {
            "location": "/fluent/relations/", 
            "text": "Fluent Relations\n\n\nComing soon.\n\n\nParent / Child\n\n\nComing soon.\n\n\nSiblings\n\n\nComing soon.", 
            "title": "Relations"
        }, 
        {
            "location": "/fluent/relations/#fluent-relations", 
            "text": "Coming soon.", 
            "title": "Fluent Relations"
        }, 
        {
            "location": "/fluent/relations/#parent-child", 
            "text": "Coming soon.", 
            "title": "Parent / Child"
        }, 
        {
            "location": "/fluent/relations/#siblings", 
            "text": "Coming soon.", 
            "title": "Siblings"
        }, 
        {
            "location": "/fluent/pivot/", 
            "text": "Fluent Pivot\n\n\nComing soon.", 
            "title": "Pivot"
        }, 
        {
            "location": "/fluent/pivot/#fluent-pivot", 
            "text": "Coming soon.", 
            "title": "Fluent Pivot"
        }, 
        {
            "location": "/fluent/transaction/", 
            "text": "Fluent Transactions\n\n\nComing soon.", 
            "title": "Transaction"
        }, 
        {
            "location": "/fluent/transaction/#fluent-transactions", 
            "text": "Coming soon.", 
            "title": "Fluent Transactions"
        }, 
        {
            "location": "/fluent/database/", 
            "text": "Fluent Database\n\n\nComing soon.\n\n\nConnection\n\n\nComing soon.\n\n\nLogger\n\n\nComing soon.", 
            "title": "Database"
        }, 
        {
            "location": "/fluent/database/#fluent-database", 
            "text": "Coming soon.", 
            "title": "Fluent Database"
        }, 
        {
            "location": "/fluent/database/#connection", 
            "text": "Coming soon.", 
            "title": "Connection"
        }, 
        {
            "location": "/fluent/database/#logger", 
            "text": "Coming soon.", 
            "title": "Logger"
        }, 
        {
            "location": "/postgresql/getting-started/", 
            "text": "Getting Started with PostgreSQL\n\n\nPostgreSQL\n is a powerful, open-source database that puts an emphasis on standards compliance. PostgreSQL's strong type-system make it a great fit with Swift, and it is the preferred database for use with Vapor.\n\n\nYou can use PostgreSQL with Vapor (or any server-side Swift framework) by either:\n\n\n\n\nUsing \nFluent PostgreSQL\n ORM.\n\n\nUse just \nPostgreSQL core\n.\n\n\n\n\nWe recommend using the ORM since it does a lot of the hard work for you. Check out the respective guides to learn more.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/postgresql/getting-started/#getting-started-with-postgresql", 
            "text": "PostgreSQL  is a powerful, open-source database that puts an emphasis on standards compliance. PostgreSQL's strong type-system make it a great fit with Swift, and it is the preferred database for use with Vapor.  You can use PostgreSQL with Vapor (or any server-side Swift framework) by either:   Using  Fluent PostgreSQL  ORM.  Use just  PostgreSQL core .   We recommend using the ORM since it does a lot of the hard work for you. Check out the respective guides to learn more.", 
            "title": "Getting Started with PostgreSQL"
        }, 
        {
            "location": "/postgresql/fluent/", 
            "text": "Fluent PostgreSQL\n\n\nFluent PostgreSQL (\nvapor/fluent-postgresql\n) is a type-safe, fast, and easy-to-use ORM for PostgreSQL built on top of \nFluent\n.\n\n\n\n\nSeealso\n\n\nThe Fluent PostgreSQL package is built on top of \nFluent\n and the pure Swift, NIO-based \nPostgreSQL core\n. You should refer to their guides for more information about subjects not covered here.\n\n\n\n\nGetting Started\n\n\nThis section will show you how to add Fluent PostgreSQL to your project and create your first \nPostgreSQLModel\n.\n\n\nPackage\n\n\nThe first step to using Fluent PostgreSQL is adding it as a dependency to your project in your SPM package manifest file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nMyApp\n,\n\n    \ndependencies\n:\n \n[\n\n        \n/// Any other dependencies ...\n\n\n        \n// \ud83d\udd8b\ud83d\udc18 Swift ORM (queries, models, relations, etc) built on PostgreSQL.\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/fluent-postgresql.git\n,\n \nfrom\n:\n \n1.0.0-rc\n),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\nname\n:\n \nApp\n,\n \ndependencies\n:\n \n[\nFluentPostgreSQL\n,\n \n...]),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nDon't forget to add the module as a dependency in the \ntargets\n array. Once you have added the dependency, regenerate your Xcode project with the following command:\n\n\nvapor xcode\n\n\n\n\n\nModel\n\n\nNow let's create our first \nPostgreSQLModel\n. Models represent tables in your PostgreSQL database and they are the primary method of interacting with your data. \n\n\n/// A simple user.\n\n\nfinal\n \nclass\n \nUser\n:\n \nPostgreSQLModel\n \n{\n\n    \n/// The unique identifier for this user.\n\n    \nvar\n \nid\n:\n \nInt\n?\n\n\n    \n/// The user\ns full name.\n\n    \nvar\n \nname\n:\n \nString\n\n\n    \n/// The user\ns current age in years.\n\n    \nvar\n \nage\n:\n \nInt\n\n\n    \n/// Creates a new user.\n\n    \ninit\n(\nid\n:\n \nInt\n?\n \n=\n \nnil\n,\n \nname\n:\n \nString\n,\n \nage\n:\n \nInt\n)\n \n{\n\n        \nself\n.\nid\n \n=\n \nid\n\n        \nself\n.\nname\n \n=\n \nname\n\n        \nself\n.\nage\n \n=\n \nage\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe example above shows a \nPostgreSQLModel\n for a simple model representing a user. You can make both \nstruct\ns and \nclass\nes a model. You can even conform types that come from external modules. The only requirement is that these types conform to \nCodable\n, which must be declared on the base type for synthesized (automatic) conformance.\n\n\nStandard practice with PostgreSQL databases is using an auto-generated \nINTEGER\n for creating and storing unique identifiers in the \nid\n column. It's also possible to use \nUUID\ns or even \nString\ns for your identifiers. There are convenience protocol for that. \n\n\n\n\n\n\n\n\nprotocol\n\n\ntype\n\n\nkey\n\n\n\n\n\n\n\n\n\n\nPostgreSQLModel\n\n\nInt\n\n\nid\n\n\n\n\n\n\nPostgreSQLUUIDModel\n\n\nUUID\n\n\nid\n\n\n\n\n\n\nPostgreSQLStringModel\n\n\nString\n\n\nid\n\n\n\n\n\n\n\n\n\n\nSeealso\n\n\nTake a look at \nFluent \n Model\n for more information on creating models with custom ID types and keys.\n\n\n\n\nMigration\n\n\nAll of your models (with some rare exceptions) should have a corresponding table\nor \nschema\nin your database. You can use a \nFluent \n Migration\n to automatically generate this schema in a testable, maintainable way. Fluent makes it easy to automatically generate a migration for your model\n\n\n\n\nTip\n\n\nIf you are creating models to represent an existing table or database, you can skip this step.\n\n\n\n\n/// Allows `User` to be used as a migration.\n\n\nextension\n \nUser\n:\n \nMigration\n \n{\n \n}\n\n\n\n\n\n\nThat's all it takes. Fluent uses Codable to analyze your model and will attempt to create the best possible schema for it.\n\n\nTake a look at \nFluent \n Migration\n if you are interested in customizing this migration.\n\n\nConfigure\n\n\nThe final step is to configure your database. At a minimum, this requires adding two things to your \nconfigure.swift\n file.\n\n\n\n\nFluentPostgreSQLProvider\n\n\nMigrationConfig\n\n\n\n\nLet's take a look.\n\n\nimport\n \nFluentPostgreSQL\n\n\n\n/// ...\n\n\n\n/// Register providers first\n\n\ntry\n \nservices\n.\nregister\n(\nFluentPostgreSQLProvider\n())\n\n\n\n/// Configure migrations\n\n\nvar\n \nmigrations\n \n=\n \nMigrationConfig\n()\n\n\nmigrations\n.\nadd\n(\nmodel\n:\n \nUser\n.\nself\n,\n \ndatabase\n:\n \n.\npsql\n)\n\n\nservices\n.\nregister\n(\nmigrations\n)\n\n\n\n/// Other services....\n\n\n\n\n\n\nRegistering the provider will add all of the services required for Fluent PostgreSQL to work properly. It also includes a default database config struct that uses typical development environment credentials. \n\n\nYou can of course override this config struct if you have non-standard credentials.\n\n\n/// Register custom PostgreSQL Config\n\n\nlet\n \npsqlConfig\n \n=\n \nPostgreSQLDatabaseConfig\n(\nhostname\n:\n \nlocalhost\n,\n \nport\n:\n \n5432\n,\n \nusername\n:\n \nvapor\n)\n\n\nservices\n.\nregister\n(\npsqlConfig\n)\n\n\n\n\n\n\nOnce you have the \nMigrationConfig\n added, you should be able to run your application and see the following:\n\n\nMigrating psql DB\nMigrations \ncomplete\n\nServer starting on http://localhost:8080\n\n\n\n\n\nQuery\n\n\nNow that you have created a model and a corresponding schema in your database, let's make your first query.\n\n\nrouter\n.\nget\n(\nusers\n)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \nUser\n.\nquery\n(\non\n:\n \nreq\n).\nall\n()\n\n\n}\n\n\n\n\n\n\nIf you run your app, and query that route, you should see an empty array returned. Now you just need to add some users! Congratulations on getting your first Fluent PostgreSQL model and migration working.\n\n\nConnection\n\n\nWith Fluent, you always have access to the underlying database driver. Using this underlying driver to perform a query is sometimes called a \"raw query\".\n\n\nLet's take a look at a raw PostgreSQL query.\n\n\nrouter\n.\nget\n(\npsql-version\n)\n \n{\n \nreq\n \n-\n \nFuture\nString\n \nin\n\n    \nreturn\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n        \nreturn\n \ntry\n \nconn\n.\nquery\n(\nselect version() as v;\n).\nmap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nrows\n \nin\n\n            \nreturn\n \ntry\n \nrows\n[\n0\n].\nfirstValue\n(\nforColumn\n:\n \nv\n)?.\ndecode\n(\nString\n.\nself\n)\n \n??\n \nn/a\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the above example, \nwithPooledConnection(to:)\n is used to create a connection to the database identified by \n.psql\n. This is the default database identifier. See \nFluent \n Database\n to learn more.\n\n\nOnce we have the \nPostgreSQLConnection\n, we can perform a query on it. You can learn more about the methods available in \nPostgreSQL \n Core\n.", 
            "title": "Fluent PostgreSQL"
        }, 
        {
            "location": "/postgresql/fluent/#fluent-postgresql", 
            "text": "Fluent PostgreSQL ( vapor/fluent-postgresql ) is a type-safe, fast, and easy-to-use ORM for PostgreSQL built on top of  Fluent .   Seealso  The Fluent PostgreSQL package is built on top of  Fluent  and the pure Swift, NIO-based  PostgreSQL core . You should refer to their guides for more information about subjects not covered here.", 
            "title": "Fluent PostgreSQL"
        }, 
        {
            "location": "/postgresql/fluent/#getting-started", 
            "text": "This section will show you how to add Fluent PostgreSQL to your project and create your first  PostgreSQLModel .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/postgresql/fluent/#package", 
            "text": "The first step to using Fluent PostgreSQL is adding it as a dependency to your project in your SPM package manifest file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   MyApp , \n     dependencies :   [ \n         /// Any other dependencies ... \n\n         // \ud83d\udd8b\ud83d\udc18 Swift ORM (queries, models, relations, etc) built on PostgreSQL. \n         . package ( url :   https://github.com/vapor/fluent-postgresql.git ,   from :   1.0.0-rc ), \n     ], \n     targets :   [ \n         . target ( name :   App ,   dependencies :   [ FluentPostgreSQL ,   ...]), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   Don't forget to add the module as a dependency in the  targets  array. Once you have added the dependency, regenerate your Xcode project with the following command:  vapor xcode", 
            "title": "Package"
        }, 
        {
            "location": "/postgresql/fluent/#model", 
            "text": "Now let's create our first  PostgreSQLModel . Models represent tables in your PostgreSQL database and they are the primary method of interacting with your data.   /// A simple user.  final   class   User :   PostgreSQLModel   { \n     /// The unique identifier for this user. \n     var   id :   Int ? \n\n     /// The user s full name. \n     var   name :   String \n\n     /// The user s current age in years. \n     var   age :   Int \n\n     /// Creates a new user. \n     init ( id :   Int ?   =   nil ,   name :   String ,   age :   Int )   { \n         self . id   =   id \n         self . name   =   name \n         self . age   =   age \n     }  }   The example above shows a  PostgreSQLModel  for a simple model representing a user. You can make both  struct s and  class es a model. You can even conform types that come from external modules. The only requirement is that these types conform to  Codable , which must be declared on the base type for synthesized (automatic) conformance.  Standard practice with PostgreSQL databases is using an auto-generated  INTEGER  for creating and storing unique identifiers in the  id  column. It's also possible to use  UUID s or even  String s for your identifiers. There are convenience protocol for that.      protocol  type  key      PostgreSQLModel  Int  id    PostgreSQLUUIDModel  UUID  id    PostgreSQLStringModel  String  id      Seealso  Take a look at  Fluent   Model  for more information on creating models with custom ID types and keys.", 
            "title": "Model"
        }, 
        {
            "location": "/postgresql/fluent/#migration", 
            "text": "All of your models (with some rare exceptions) should have a corresponding table or  schema in your database. You can use a  Fluent   Migration  to automatically generate this schema in a testable, maintainable way. Fluent makes it easy to automatically generate a migration for your model   Tip  If you are creating models to represent an existing table or database, you can skip this step.   /// Allows `User` to be used as a migration.  extension   User :   Migration   {   }   That's all it takes. Fluent uses Codable to analyze your model and will attempt to create the best possible schema for it.  Take a look at  Fluent   Migration  if you are interested in customizing this migration.", 
            "title": "Migration"
        }, 
        {
            "location": "/postgresql/fluent/#configure", 
            "text": "The final step is to configure your database. At a minimum, this requires adding two things to your  configure.swift  file.   FluentPostgreSQLProvider  MigrationConfig   Let's take a look.  import   FluentPostgreSQL  /// ...  /// Register providers first  try   services . register ( FluentPostgreSQLProvider ())  /// Configure migrations  var   migrations   =   MigrationConfig ()  migrations . add ( model :   User . self ,   database :   . psql )  services . register ( migrations )  /// Other services....   Registering the provider will add all of the services required for Fluent PostgreSQL to work properly. It also includes a default database config struct that uses typical development environment credentials.   You can of course override this config struct if you have non-standard credentials.  /// Register custom PostgreSQL Config  let   psqlConfig   =   PostgreSQLDatabaseConfig ( hostname :   localhost ,   port :   5432 ,   username :   vapor )  services . register ( psqlConfig )   Once you have the  MigrationConfig  added, you should be able to run your application and see the following:  Migrating psql DB\nMigrations  complete \nServer starting on http://localhost:8080", 
            "title": "Configure"
        }, 
        {
            "location": "/postgresql/fluent/#query", 
            "text": "Now that you have created a model and a corresponding schema in your database, let's make your first query.  router . get ( users )   {   req   in \n     return   User . query ( on :   req ). all ()  }   If you run your app, and query that route, you should see an empty array returned. Now you just need to add some users! Congratulations on getting your first Fluent PostgreSQL model and migration working.", 
            "title": "Query"
        }, 
        {
            "location": "/postgresql/fluent/#connection", 
            "text": "With Fluent, you always have access to the underlying database driver. Using this underlying driver to perform a query is sometimes called a \"raw query\".  Let's take a look at a raw PostgreSQL query.  router . get ( psql-version )   {   req   -   Future String   in \n     return   req . withPooledConnection ( to :   . psql )   {   conn   in \n         return   try   conn . query ( select version() as v; ). map ( to :   String . self )   {   rows   in \n             return   try   rows [ 0 ]. firstValue ( forColumn :   v )?. decode ( String . self )   ??   n/a \n         } \n     }  }   In the above example,  withPooledConnection(to:)  is used to create a connection to the database identified by  .psql . This is the default database identifier. See  Fluent   Database  to learn more.  Once we have the  PostgreSQLConnection , we can perform a query on it. You can learn more about the methods available in  PostgreSQL   Core .", 
            "title": "Connection"
        }, 
        {
            "location": "/postgresql/core/", 
            "text": "PostgreSQL Core\n\n\nPostgreSQL (\nvapor/postgresql\n) is a pure-Swift (no \nlibpq\n dependency), event-driven, non-blocking driver for PostgreSQL. It's build on top of the \nSwift NIO\n networking library.\n\n\n\n\nSeealso\n\n\nThe higher-level, Fluent PostgreSQL ORM guide is located at \nPostgreSQL \n Fluent\n\n\n\n\nUsing just the PostgreSQL package for your project may be a good idea if any of the following are true.\n\n\n\n\nYou have an existing DB with non-standard structure.\n\n\nYou rely heavily on custom or complex SQL queries.\n\n\nYou just plain don't like ORMs.\n\n\n\n\nPostgreSQL core is built on top of DatabaseKit which provides some conveniences like connection pooling and integrations with Vapor's \nServices\n architecture.\n\n\n\n\nTip\n\n\nEven if you do choose to use \nFluent PostgreSQL\n, all of the features of PostgreSQL core will be available to you.\n\n\n\n\nGetting Started\n\n\nLet's take a look at how you can get started using PostgreSQL core.\n\n\nPackage\n\n\nThe first step to using PostgreSQL core is adding it as a dependency to your project in your SPM package manifest file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nMyApp\n,\n\n    \ndependencies\n:\n \n[\n\n        \n/// Any other dependencies ...\n\n\n        \n// \ud83d\udc18 Non-blocking, event-driven Swift client for PostgreSQL.\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/postgresql.git\n,\n \nfrom\n:\n \n1.0.0-rc\n),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\nname\n:\n \nApp\n,\n \ndependencies\n:\n \n[\nPostgreSQL\n,\n \n...]),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nDon't forget to add the module as a dependency in the \ntargets\n array. Once you have added the dependency, regenerate your Xcode project with the following command:\n\n\nvapor xcode\n\n\n\n\n\nConfig\n\n\nThe next step is to configure the database in your \nconfigure.swift\n file.\n\n\nimport\n \nPostgreSQL\n\n\n\n/// ...\n\n\n\n/// Register providers first\n\n\ntry\n \nservices\n.\nregister\n(\nPostgreSQLProvider\n())\n\n\n\n\n\n\nRegistering the provider will add all of the services required for PostgreSQL to work properly. It also includes a default database config struct that uses typical development environment credentials. \n\n\nYou can of course override this config struct if you have non-standard credentials.\n\n\n/// Register custom PostgreSQL Config\n\n\nlet\n \npsqlConfig\n \n=\n \nPostgreSQLDatabaseConfig\n(\nhostname\n:\n \nlocalhost\n,\n \nport\n:\n \n5432\n,\n \nusername\n:\n \nvapor\n)\n\n\nservices\n.\nregister\n(\npsqlConfig\n)\n\n\n\n\n\n\nQuery\n\n\nNow that the database is configured, you can make your first query.\n\n\nrouter\n.\nget\n(\npsql-version\n)\n \n{\n \nreq\n \n-\n \nFuture\nString\n \nin\n\n    \nreturn\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n        \nreturn\n \ntry\n \nconn\n.\nquery\n(\nselect version() as v;\n).\nmap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nrows\n \nin\n\n            \nreturn\n \ntry\n \nrows\n[\n0\n].\nfirstValue\n(\nforColumn\n:\n \nv\n)?.\ndecode\n(\nString\n.\nself\n)\n \n??\n \nn/a\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nVisiting this route should display your PostgreSQL version.\n\n\nConnection\n\n\nA \nPostgreSQLConnection\n is normally created using the \nRequest\n container and can perform two different types of queries.\n\n\nCreate\n\n\nThere are two methods for creating a \nPostgreSQLConnection\n.\n\n\nreturn\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n    \n/// ...\n\n\n}\n\n\nreturn\n \nreq\n.\nwithConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n    \n/// ...\n\n\n}\n\n\n\n\n\n\nAs the names imply,  \nwithPooledConnection(to:)\n utilizes a connection pool. \nwithConnection(to:)\n does not. Connection pooling is a great way to ensure your application does not exceed the limits of your database, even under peak load.\n\n\nSimply Query\n\n\nUse \n.simpleQuery(_:)\n to perform a query on your PostgreSQL database that does not bind any parameters. Some queries you send to PostgreSQL may actually require that you use the \nsimpleQuery(_:)\n method instead of the parameterized method. \n\n\n\n\nNote\n\n\nThis method sends and receives data as text-encoded, meaning it is not optimal for transmitting things like integers.\n\n\n\n\nlet\n \nrows\n \n=\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n    \nreturn\n \nconn\n.\nsimpleQuery\n(\nSELECT * FROM users;\n)\n\n\n}\n\n\nprint\n(\nrows\n)\n \n// Future\n[[PostgreSQLColumn: PostgreSQLData]]\n\n\n\n\n\n\nYou can also choose to receive each row in a callback, which is great for conserving memory for large queries.\n\n\nlet\n \ndone\n \n=\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n    \nreturn\n \nconn\n.\nsimpleQuery\n(\nSELECT * FROM users;\n)\n \n{\n \nrow\n \nin\n\n        \nprint\n(\nrow\n)\n \n// [PostgreSQLColumn: PostgreSQLData]\n\n    \n}\n\n\n}\n\n\nprint\n(\ndone\n)\n \n// Future\nVoid\n\n\n\n\n\n\nParameterized Query\n\n\nPostgreSQL also supports sending parameterized queries (sometimes called prepared statements). This method allows you to insert data placeholders into the SQL string and send the values separately.\n\n\nData sent via parameterized queries is binary encoded, making it more efficient for sending some data types. In general, you should use parameterized queries where ever possible.\n\n\nlet\n \nusers\n \n=\n \nreq\n.\nwithPooledConnection\n(\nto\n:\n \n.\npsql\n)\n \n{\n \nconn\n \nin\n\n    \nreturn\n \ntry\n \nconn\n.\nquery\n(\nSELECT *  users WHERE name = $1;\n,\n \n[\nVapor\n])\n\n\n}\n\n\nprint\n(\nusers\n)\n \n// Future\n[[PostgreSQLColumn: PostgreSQLData]]\n\n\n\n\n\n\nYou can also provide a callback, similar to simple queries, for handling each row individually.", 
            "title": "PostgreSQL Core"
        }, 
        {
            "location": "/postgresql/core/#postgresql-core", 
            "text": "PostgreSQL ( vapor/postgresql ) is a pure-Swift (no  libpq  dependency), event-driven, non-blocking driver for PostgreSQL. It's build on top of the  Swift NIO  networking library.   Seealso  The higher-level, Fluent PostgreSQL ORM guide is located at  PostgreSQL   Fluent   Using just the PostgreSQL package for your project may be a good idea if any of the following are true.   You have an existing DB with non-standard structure.  You rely heavily on custom or complex SQL queries.  You just plain don't like ORMs.   PostgreSQL core is built on top of DatabaseKit which provides some conveniences like connection pooling and integrations with Vapor's  Services  architecture.   Tip  Even if you do choose to use  Fluent PostgreSQL , all of the features of PostgreSQL core will be available to you.", 
            "title": "PostgreSQL Core"
        }, 
        {
            "location": "/postgresql/core/#getting-started", 
            "text": "Let's take a look at how you can get started using PostgreSQL core.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/postgresql/core/#package", 
            "text": "The first step to using PostgreSQL core is adding it as a dependency to your project in your SPM package manifest file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   MyApp , \n     dependencies :   [ \n         /// Any other dependencies ... \n\n         // \ud83d\udc18 Non-blocking, event-driven Swift client for PostgreSQL. \n         . package ( url :   https://github.com/vapor/postgresql.git ,   from :   1.0.0-rc ), \n     ], \n     targets :   [ \n         . target ( name :   App ,   dependencies :   [ PostgreSQL ,   ...]), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   Don't forget to add the module as a dependency in the  targets  array. Once you have added the dependency, regenerate your Xcode project with the following command:  vapor xcode", 
            "title": "Package"
        }, 
        {
            "location": "/postgresql/core/#config", 
            "text": "The next step is to configure the database in your  configure.swift  file.  import   PostgreSQL  /// ...  /// Register providers first  try   services . register ( PostgreSQLProvider ())   Registering the provider will add all of the services required for PostgreSQL to work properly. It also includes a default database config struct that uses typical development environment credentials.   You can of course override this config struct if you have non-standard credentials.  /// Register custom PostgreSQL Config  let   psqlConfig   =   PostgreSQLDatabaseConfig ( hostname :   localhost ,   port :   5432 ,   username :   vapor )  services . register ( psqlConfig )", 
            "title": "Config"
        }, 
        {
            "location": "/postgresql/core/#query", 
            "text": "Now that the database is configured, you can make your first query.  router . get ( psql-version )   {   req   -   Future String   in \n     return   req . withPooledConnection ( to :   . psql )   {   conn   in \n         return   try   conn . query ( select version() as v; ). map ( to :   String . self )   {   rows   in \n             return   try   rows [ 0 ]. firstValue ( forColumn :   v )?. decode ( String . self )   ??   n/a \n         } \n     }  }   Visiting this route should display your PostgreSQL version.", 
            "title": "Query"
        }, 
        {
            "location": "/postgresql/core/#connection", 
            "text": "A  PostgreSQLConnection  is normally created using the  Request  container and can perform two different types of queries.", 
            "title": "Connection"
        }, 
        {
            "location": "/postgresql/core/#create", 
            "text": "There are two methods for creating a  PostgreSQLConnection .  return   req . withPooledConnection ( to :   . psql )   {   conn   in \n     /// ...  }  return   req . withConnection ( to :   . psql )   {   conn   in \n     /// ...  }   As the names imply,   withPooledConnection(to:)  utilizes a connection pool.  withConnection(to:)  does not. Connection pooling is a great way to ensure your application does not exceed the limits of your database, even under peak load.", 
            "title": "Create"
        }, 
        {
            "location": "/postgresql/core/#simply-query", 
            "text": "Use  .simpleQuery(_:)  to perform a query on your PostgreSQL database that does not bind any parameters. Some queries you send to PostgreSQL may actually require that you use the  simpleQuery(_:)  method instead of the parameterized method.    Note  This method sends and receives data as text-encoded, meaning it is not optimal for transmitting things like integers.   let   rows   =   req . withPooledConnection ( to :   . psql )   {   conn   in \n     return   conn . simpleQuery ( SELECT * FROM users; )  }  print ( rows )   // Future [[PostgreSQLColumn: PostgreSQLData]]   You can also choose to receive each row in a callback, which is great for conserving memory for large queries.  let   done   =   req . withPooledConnection ( to :   . psql )   {   conn   in \n     return   conn . simpleQuery ( SELECT * FROM users; )   {   row   in \n         print ( row )   // [PostgreSQLColumn: PostgreSQLData] \n     }  }  print ( done )   // Future Void", 
            "title": "Simply Query"
        }, 
        {
            "location": "/postgresql/core/#parameterized-query", 
            "text": "PostgreSQL also supports sending parameterized queries (sometimes called prepared statements). This method allows you to insert data placeholders into the SQL string and send the values separately.  Data sent via parameterized queries is binary encoded, making it more efficient for sending some data types. In general, you should use parameterized queries where ever possible.  let   users   =   req . withPooledConnection ( to :   . psql )   {   conn   in \n     return   try   conn . query ( SELECT *  users WHERE name = $1; ,   [ Vapor ])  }  print ( users )   // Future [[PostgreSQLColumn: PostgreSQLData]]   You can also provide a callback, similar to simple queries, for handling each row individually.", 
            "title": "Parameterized Query"
        }, 
        {
            "location": "/leaf/getting-started/", 
            "text": "Leaf\n\n\nLeaf is a templating language that integrates with Futures, Reactive Streams and Codable. This section outlines how to import the Leaf package into a Vapor project.\n\n\nExample Folder Structure\n\n\nHello\n\u251c\u2500\u2500 Package.resolved\n\u251c\u2500\u2500 Package.swift\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Resources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Views\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 hello.leaf\n\u251c\u2500\u2500 Public\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 images (images resources)\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 styles (css resources)\n\u251c\u2500\u2500 Sources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 App\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 boot.swift\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 configure.swift\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 routes.swift\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Run\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 AppTests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 AppTests.swift\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 LinuxMain.swift\n\u2514\u2500\u2500 LICENSE\n\n\n\n\n\nAdding Leaf to your project\n\n\nThe easiest way to use Leaf with Vapor is to include the Leaf repository as a dependency in Package.swift:\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nproject1\n,\n\n    \ndependencies\n:\n \n[\n\n        \n// \ud83d\udca7 A server-side Swift web framework.\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/vapor.git\n,\n \n.\nbranch\n(\nbeta\n)),\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/leaf.git\n,\n \n.\nbranch\n(\nbeta\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\n\n            \nname\n:\n \nApp\n,\n\n            \ndependencies\n:\n \n[\nVapor\n,\n \nLeaf\n]\n\n        \n),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nThe Leaf package adds Leaf to your project, but to configure it for use you must modify configure.swift:\n\n\n\n\nAdd \nimport Leaf\n to the top of the file so that Leaf is available to use. You will also need to add this to any file that will render templates.\n\n\nAdd \ntry services.register(LeafProvider())\n to the \nconfigure()\n function so that routes may render Leaf templates as needed.\n\n\n\n\nSyntax Highlighting\n\n\nYou may also wish to install one these third-party packages that provide support for syntax highlighting in Leaf templates.\n\n\nAtom\n\n\nlanguage-leaf\n by ButkiewiczP\n\n\nXcode\n\n\nIt is not currently possible to implement Leaf Syntax Highlighting in Xcode, however, using Xcode's HTML Syntax Coloring can help a bit. Select one or more Leaf files and then choose Editor \n Syntax Coloring \n HTML.  Your selected Leaf files will now use Xcode's HTML Syntax Coloring.  Unfortunately the usefulness of this is limited because this association will be removed when \nvapor xcode\n is run.\n\n\nThere appears to be a way to \nmake Xcode file associations persist\n but that requires a bit more kung-fu.\n\n\nVS Code\n\n\nhtml-leaf\n by FranciscoAmado\n\n\nCLion \n AppCode\n\n\nSome preliminary work has been done to implement a Leaf Plugin for CLion \n AppCode but lack of skill and interest in Java has slowed progress! If you have IntelliJ SDK experience and want to help with this, message Tom Holland on \nVapor Slack", 
            "title": "Getting Started"
        }, 
        {
            "location": "/leaf/getting-started/#leaf", 
            "text": "Leaf is a templating language that integrates with Futures, Reactive Streams and Codable. This section outlines how to import the Leaf package into a Vapor project.", 
            "title": "Leaf"
        }, 
        {
            "location": "/leaf/getting-started/#example-folder-structure", 
            "text": "Hello\n\u251c\u2500\u2500 Package.resolved\n\u251c\u2500\u2500 Package.swift\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Resources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Views\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 hello.leaf\n\u251c\u2500\u2500 Public\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 images (images resources)\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 styles (css resources)\n\u251c\u2500\u2500 Sources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 App\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 boot.swift\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 configure.swift\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 routes.swift\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Run\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 AppTests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 AppTests.swift\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 LinuxMain.swift\n\u2514\u2500\u2500 LICENSE", 
            "title": "Example Folder Structure"
        }, 
        {
            "location": "/leaf/getting-started/#adding-leaf-to-your-project", 
            "text": "The easiest way to use Leaf with Vapor is to include the Leaf repository as a dependency in Package.swift:  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   project1 , \n     dependencies :   [ \n         // \ud83d\udca7 A server-side Swift web framework. \n         . package ( url :   https://github.com/vapor/vapor.git ,   . branch ( beta )), \n         . package ( url :   https://github.com/vapor/leaf.git ,   . branch ( beta )), \n     ], \n     targets :   [ \n         . target ( \n             name :   App , \n             dependencies :   [ Vapor ,   Leaf ] \n         ), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   The Leaf package adds Leaf to your project, but to configure it for use you must modify configure.swift:   Add  import Leaf  to the top of the file so that Leaf is available to use. You will also need to add this to any file that will render templates.  Add  try services.register(LeafProvider())  to the  configure()  function so that routes may render Leaf templates as needed.", 
            "title": "Adding Leaf to your project"
        }, 
        {
            "location": "/leaf/getting-started/#syntax-highlighting", 
            "text": "You may also wish to install one these third-party packages that provide support for syntax highlighting in Leaf templates.", 
            "title": "Syntax Highlighting"
        }, 
        {
            "location": "/leaf/getting-started/#atom", 
            "text": "language-leaf  by ButkiewiczP", 
            "title": "Atom"
        }, 
        {
            "location": "/leaf/getting-started/#xcode", 
            "text": "It is not currently possible to implement Leaf Syntax Highlighting in Xcode, however, using Xcode's HTML Syntax Coloring can help a bit. Select one or more Leaf files and then choose Editor   Syntax Coloring   HTML.  Your selected Leaf files will now use Xcode's HTML Syntax Coloring.  Unfortunately the usefulness of this is limited because this association will be removed when  vapor xcode  is run.  There appears to be a way to  make Xcode file associations persist  but that requires a bit more kung-fu.", 
            "title": "Xcode"
        }, 
        {
            "location": "/leaf/getting-started/#vs-code", 
            "text": "html-leaf  by FranciscoAmado", 
            "title": "VS Code"
        }, 
        {
            "location": "/leaf/getting-started/#clion-appcode", 
            "text": "Some preliminary work has been done to implement a Leaf Plugin for CLion   AppCode but lack of skill and interest in Java has slowed progress! If you have IntelliJ SDK experience and want to help with this, message Tom Holland on  Vapor Slack", 
            "title": "CLion &amp; AppCode"
        }, 
        {
            "location": "/leaf/basics/", 
            "text": "Basics\n\n\nWelcome to Leaf. Leaf's goal is to be a simple templating language that can make generating views easier. There are plenty of great templating languages, so use what's best for you \u2013 maybe that's Leaf! The goals of Leaf are:\n\n\n\n\nSmall set of strictly enforced rules\n\n\nConsistency\n\n\nParser first mentality\n\n\nExtensibility\n\n\nAsynchronous and reactive\n\n\n\n\nRendering a template\n\n\nOnce you have Leaf installed, you should create a directory called \u201cResources\u201d inside your project folder, and inside that create another directory called \u201cViews\u201d. This Resources/Views directory is the default location for Leaf templates, although you can change it if you want.\n\n\nFirstly, import Leaf to routes.swift\n\n\nimport\n \nLeaf\n\n\n\n\n\n\nThen, to render a basic Leaf template from a route, add this code:\n\n\nrouter\n.\nget\n \n{\n \nreq\n \n-\n \nFuture\nView\n \nin\n\n    \nlet\n \nleaf\n \n=\n \ntry\n \nreq\n.\nmake\n(\nLeafRenderer\n.\nself\n)\n\n    \nlet\n \ncontext\n \n=\n \n[\nString\n:\n \nString\n]()\n\n    \nreturn\n \ntry\n \nleaf\n.\nrender\n(\nhome\n,\n \ncontext\n)\n\n\n}\n\n\n\n\n\n\nThat will load home.leaf in the Resources/Views directory and render it. The \ncontext\n dictionary is there to let you provide custom data to render inside the template, but you might find it easier to use codable structs instead because they provide extra type safety. For example:\n\n\nstruct\n \nHomePage\n:\n \nCodable\n \n{\n\n    \nvar\n \ntitle\n:\n \nString\n\n    \nvar\n \ncontent\n:\n \nString\n\n\n}\n\n\n\n\n\n\nAsync\n\n\nLeaf's engine is completely \nreactive\n, supporting both \nstreams\n and \nfutures\n. One of the only ones of it's kind.\n\n\nWhen working with Future results, simply pass the \nFuture\n in your template context.\nStreams that carry an encodable type need to be encoded before they're usable within Leaf.\n\n\nstruct\n \nProfile\n:\n \nCodable\n \n{\n\n    \nvar\n \nfriends\n:\n \nEncodableStream\n\n    \nvar\n \ncurrentUser\n:\n \nFuture\nUser\n\n\n}\n\n\n\n\n\n\nIn the above context, the \ncurrentUser\n variable in Leaf will behave as being a \nUser\n type. Leaf will not read the user Future if it's not used during rendering.\n\n\nEncodableStream\n will behave as an array of LeafData, only with lower memory impact and better performance. It is recommended to use \nEncodableStream\n for (large) database queries.\n\n\nYour name is #(currentUser.name).\n\n#for(friend in friends) {\n    #(friend.name) is a friend of you.\n}\n\n\n\n\n\nTemplate syntax\n\n\nStructure\n\n\nLeaf tags are made up of four elements:\n\n\n\n\nToken: \n#\n is the token\n\n\nName: A \nstring\n that identifies the tag\n\n\nParameter List: \n()\n May accept 0 or more arguments\n\n\nBody (optional): \n{}\n Must be separated from the parameter list by a space\n\n\n\n\nThere can be many different usages of these four elements depending on the tag's implementation. Let's look at a few examples of how Leaf's built-in tags might be used:\n\n\n\n\n#()\n\n\n#(variable)\n\n\n#embed(\"template\")\n\n\n#set(\"title\") { Welcome to Vapor }\n\n\n#count(friends)\n\n\n#for(friend in friends) { \nli\n#(friend.name)\n/li\n }\n\n\n\n\nWorking with context\n\n\nIn our Swift example from earlier, we used an empty \n[String: String]\n dictionary for context, which passes no custom data to Leaf. To try rendering content, use this code instead:\n\n\nlet\n \ncontext\n \n=\n \n[\ntitle\n:\n \nWelcome\n,\n \nmessage\n:\n \nVapor and Leaf work hand in hand\n]\n\n\nreturn\n \ntry\n \nleaf\n.\nmake\n(\nhome\n,\n \ncontext\n)\n\n\n\n\n\n\nThat will expose \ntitle\n and \nmessage\n to our Leaf template, which can then be used inside tags. For example:\n\n\nh1\n#(title)\n/h1\n\n\np\n#(message)\n/p\n\n\n\n\n\n\nChecking conditions\n\n\nLeaf is able to evaluate a range of conditions using its \n#if\n tag. For example, if you provide a variable it will check that variable exists in its context:\n\n\n#if(title) {\n    The title is #(title)\n} else {\n    No title was provided.\n}\n\n\n\n\n\nYou can also write comparisons, for example:\n\n\n#if(title == \nWelcome\n) {\n    This is a friendly web page.\n} else {\n    No strangers allowed!\n}\n\n\n\n\n\nIf you want to use another tag as part of your condition, you should omit the \n#\n for the inner tag. For example:\n\n\n#if(lowercase(title) == \nwelcome\n) {\n    This is a friendly web page.\n} else {\n    No strangers allowed!\n}\n\n\n\n\n\nLoops\n\n\nIf you provide an array of items, Leaf can loop over them and let you manipulate each item individually using its \n#for\n tag. For example, we could update our Swift code to provide a list of names in a team:\n\n\nlet\n \ncontext\n \n=\n \n[\nteam\n:\n \n[\nMalcolm\n,\n \nKaylee\n,\n \nJayne\n]]\n\n\n\n\n\n\nWe could then loop over them in Leaf like this:\n\n\n#for(name in team) {\n    \np\n#(name) is in the team.\n/p\n\n}\n\n\n\n\n\nLeaf provides some extra variables inside a \n#for\n loop to give you more information about the loop's progress:\n\n\n\n\nThe \nloop.isFirst\n variable is true when the current iteration is the first one.\n\n\nThe \nloop.isLast\n variable is true when it's the last iteration.\n\n\nThe \nloop.index\n variable will be set to the number of the current iteration, counting from 0.\n\n\n\n\nEmbedding templates\n\n\nLeaf\u2019s \n#embed\n tag allows you to copy the contents of one template into another. When use this, you should always omit the template file's .leaf extension.\n\n\nEmbedding is useful for copying in a standard piece of content, for example a page footer or advert code:\n\n\n#embed(\nfooter\n)\n\n\n\n\n\nThis tag is also useful for building one template on top of another. For example, you might have a master.leaf file that includes all the code required to lay out your website \u2013\u00a0HTML structure, CSS and JavaScript \u2013\u00a0with some gaps in place that represent where page content varies.\n\n\nUsing this approach, you would construct a child template that fills in its unique content, then embeds the parent template that places the content appropriately.\n\n\nFor example, you might create a child.leaf template like this:\n\n\n#set(\nbody\n) {\n\np\nWelcome to Vapor!\n/p\n\n}\n\n#embed(\nmaster\n)\n\n\n\n\n\nThat configures one item of context, \nbody\n, but doesn\u2019t display it directly. Instead, it embeds master.leaf, which can render \nbody\n along with any other context variables passed in from Swift. For example, master.leaf might look like this:\n\n\nhtml\n\n\nhead\ntitle\n#(title)\n/title\n/head\n\n\nbody\n#get(body)\n/body\n\n\n/html\n\n\n\n\n\n\nWhen given the context \n[\"title\": \"Hi there!\"]\n, child.leaf will render as follows:\n\n\nhtml\n\n\nhead\ntitle\nHi there!\n/title\n/head\n\n\nbody\np\nWelcome to Vapor!\n/p\n/body\n\n\n/html\n\n\n\n\n\n\nOther tags\n\n\n#capitalize\n\n\nThe \n#capitalize\n tag uppercases the first letter of any string. For example, \u201ctaylor\u201d will become \u201cTaylor\u201d.\n\n\n#capitalize(name)\n\n\n\n\n\n#contains\n\n\nThe \n#contains\n tag accepts an array and a value as its two parameters, and returns true if the array in parameter one contains the value in parameter two. For example, given the array \nteam\n:\n\n\n#if(contains(team, \nJayne\n)) {\n    You\nre all set!\n} else {\n    You need someone to do PR.\n}\n\n\n\n\n\n#count\n\n\nThe \n#count\n tag returns the number of items in an array. For example:\n\n\nYour search matched #count(matches) pages.\n\n\n\n\n\n#lowercase\n\n\nThe \n#lowercase\n tag lowercases all letters in a string. For example, \u201cTaylor\u201d will become \u201ctaylor\u201d.\n\n\n#lowercase(name)\n\n\n\n\n\n#uppercase\n\n\nThe \n#uppercase\n tag uppercases all letters in a string. For example, \u201cTaylor\u201d will become \u201cTAYLOR\u201d.\n\n\n#uppercase(name)", 
            "title": "Basics"
        }, 
        {
            "location": "/leaf/basics/#basics", 
            "text": "Welcome to Leaf. Leaf's goal is to be a simple templating language that can make generating views easier. There are plenty of great templating languages, so use what's best for you \u2013 maybe that's Leaf! The goals of Leaf are:   Small set of strictly enforced rules  Consistency  Parser first mentality  Extensibility  Asynchronous and reactive", 
            "title": "Basics"
        }, 
        {
            "location": "/leaf/basics/#rendering-a-template", 
            "text": "Once you have Leaf installed, you should create a directory called \u201cResources\u201d inside your project folder, and inside that create another directory called \u201cViews\u201d. This Resources/Views directory is the default location for Leaf templates, although you can change it if you want.  Firstly, import Leaf to routes.swift  import   Leaf   Then, to render a basic Leaf template from a route, add this code:  router . get   {   req   -   Future View   in \n     let   leaf   =   try   req . make ( LeafRenderer . self ) \n     let   context   =   [ String :   String ]() \n     return   try   leaf . render ( home ,   context )  }   That will load home.leaf in the Resources/Views directory and render it. The  context  dictionary is there to let you provide custom data to render inside the template, but you might find it easier to use codable structs instead because they provide extra type safety. For example:  struct   HomePage :   Codable   { \n     var   title :   String \n     var   content :   String  }", 
            "title": "Rendering a template"
        }, 
        {
            "location": "/leaf/basics/#async", 
            "text": "Leaf's engine is completely  reactive , supporting both  streams  and  futures . One of the only ones of it's kind.  When working with Future results, simply pass the  Future  in your template context.\nStreams that carry an encodable type need to be encoded before they're usable within Leaf.  struct   Profile :   Codable   { \n     var   friends :   EncodableStream \n     var   currentUser :   Future User  }   In the above context, the  currentUser  variable in Leaf will behave as being a  User  type. Leaf will not read the user Future if it's not used during rendering.  EncodableStream  will behave as an array of LeafData, only with lower memory impact and better performance. It is recommended to use  EncodableStream  for (large) database queries.  Your name is #(currentUser.name).\n\n#for(friend in friends) {\n    #(friend.name) is a friend of you.\n}", 
            "title": "Async"
        }, 
        {
            "location": "/leaf/basics/#template-syntax", 
            "text": "", 
            "title": "Template syntax"
        }, 
        {
            "location": "/leaf/basics/#structure", 
            "text": "Leaf tags are made up of four elements:   Token:  #  is the token  Name: A  string  that identifies the tag  Parameter List:  ()  May accept 0 or more arguments  Body (optional):  {}  Must be separated from the parameter list by a space   There can be many different usages of these four elements depending on the tag's implementation. Let's look at a few examples of how Leaf's built-in tags might be used:   #()  #(variable)  #embed(\"template\")  #set(\"title\") { Welcome to Vapor }  #count(friends)  #for(friend in friends) {  li #(friend.name) /li  }", 
            "title": "Structure"
        }, 
        {
            "location": "/leaf/basics/#working-with-context", 
            "text": "In our Swift example from earlier, we used an empty  [String: String]  dictionary for context, which passes no custom data to Leaf. To try rendering content, use this code instead:  let   context   =   [ title :   Welcome ,   message :   Vapor and Leaf work hand in hand ]  return   try   leaf . make ( home ,   context )   That will expose  title  and  message  to our Leaf template, which can then be used inside tags. For example:  h1 #(title) /h1  p #(message) /p", 
            "title": "Working with context"
        }, 
        {
            "location": "/leaf/basics/#checking-conditions", 
            "text": "Leaf is able to evaluate a range of conditions using its  #if  tag. For example, if you provide a variable it will check that variable exists in its context:  #if(title) {\n    The title is #(title)\n} else {\n    No title was provided.\n}  You can also write comparisons, for example:  #if(title ==  Welcome ) {\n    This is a friendly web page.\n} else {\n    No strangers allowed!\n}  If you want to use another tag as part of your condition, you should omit the  #  for the inner tag. For example:  #if(lowercase(title) ==  welcome ) {\n    This is a friendly web page.\n} else {\n    No strangers allowed!\n}", 
            "title": "Checking conditions"
        }, 
        {
            "location": "/leaf/basics/#loops", 
            "text": "If you provide an array of items, Leaf can loop over them and let you manipulate each item individually using its  #for  tag. For example, we could update our Swift code to provide a list of names in a team:  let   context   =   [ team :   [ Malcolm ,   Kaylee ,   Jayne ]]   We could then loop over them in Leaf like this:  #for(name in team) {\n     p #(name) is in the team. /p \n}  Leaf provides some extra variables inside a  #for  loop to give you more information about the loop's progress:   The  loop.isFirst  variable is true when the current iteration is the first one.  The  loop.isLast  variable is true when it's the last iteration.  The  loop.index  variable will be set to the number of the current iteration, counting from 0.", 
            "title": "Loops"
        }, 
        {
            "location": "/leaf/basics/#embedding-templates", 
            "text": "Leaf\u2019s  #embed  tag allows you to copy the contents of one template into another. When use this, you should always omit the template file's .leaf extension.  Embedding is useful for copying in a standard piece of content, for example a page footer or advert code:  #embed( footer )  This tag is also useful for building one template on top of another. For example, you might have a master.leaf file that includes all the code required to lay out your website \u2013\u00a0HTML structure, CSS and JavaScript \u2013\u00a0with some gaps in place that represent where page content varies.  Using this approach, you would construct a child template that fills in its unique content, then embeds the parent template that places the content appropriately.  For example, you might create a child.leaf template like this:  #set( body ) { p Welcome to Vapor! /p \n}\n\n#embed( master )  That configures one item of context,  body , but doesn\u2019t display it directly. Instead, it embeds master.leaf, which can render  body  along with any other context variables passed in from Swift. For example, master.leaf might look like this:  html  head title #(title) /title /head  body #get(body) /body  /html   When given the context  [\"title\": \"Hi there!\"] , child.leaf will render as follows:  html  head title Hi there! /title /head  body p Welcome to Vapor! /p /body  /html", 
            "title": "Embedding templates"
        }, 
        {
            "location": "/leaf/basics/#other-tags", 
            "text": "", 
            "title": "Other tags"
        }, 
        {
            "location": "/leaf/basics/#capitalize", 
            "text": "The  #capitalize  tag uppercases the first letter of any string. For example, \u201ctaylor\u201d will become \u201cTaylor\u201d.  #capitalize(name)", 
            "title": "#capitalize"
        }, 
        {
            "location": "/leaf/basics/#contains", 
            "text": "The  #contains  tag accepts an array and a value as its two parameters, and returns true if the array in parameter one contains the value in parameter two. For example, given the array  team :  #if(contains(team,  Jayne )) {\n    You re all set!\n} else {\n    You need someone to do PR.\n}", 
            "title": "#contains"
        }, 
        {
            "location": "/leaf/basics/#count", 
            "text": "The  #count  tag returns the number of items in an array. For example:  Your search matched #count(matches) pages.", 
            "title": "#count"
        }, 
        {
            "location": "/leaf/basics/#lowercase", 
            "text": "The  #lowercase  tag lowercases all letters in a string. For example, \u201cTaylor\u201d will become \u201ctaylor\u201d.  #lowercase(name)", 
            "title": "#lowercase"
        }, 
        {
            "location": "/leaf/basics/#uppercase", 
            "text": "The  #uppercase  tag uppercases all letters in a string. For example, \u201cTaylor\u201d will become \u201cTAYLOR\u201d.  #uppercase(name)", 
            "title": "#uppercase"
        }, 
        {
            "location": "/leaf/custom-tags/", 
            "text": "Custom Tags\n\n\nYou can extend Leaf to provide your own tags that add custom functionality. To demonstrate this, let's look at a basic example by recreating \n#uppercase\n together. This tag will take one argument, which is the string to uppercase.\n\n\nWhen working with custom tags, there are four important things to know:\n\n\n\n\nYou should call \nrequireParameterCount()\n with the number of parameters you expect to receive. This will throw an error if your tag is used incorrectly.\n\n\nIf you do or do not require a body, you should use either \nrequireBody()\n or \nrequireNoBody()\n. Again, this will throw an error if your tag is used incorrectly.\n\n\nYou can read individual parameters using the \nparameters\n array. Each parameter will be of type \nLeafData\n, which you can convert to concrete data types using properties such as \n.string\n, \n.dictionary\n, and so on.\n\n\nYou must return a \nFuture\nLeafData?\n containing what should be rendered. In the example below we wrap the resulting uppercase string in a \nLeafData\n string, then send that back wrapped in a future.\n\n\n\n\nHere\u2019s example code for a \nCustomUppercase\n Leaf tag:\n\n\nimport\n \nAsync\n\n\nimport\n \nLeaf\n\n\n\npublic\n \nfinal\n \nclass\n \nCustomUppercase\n:\n \nLeaf\n.\nLeafTag\n \n{\n\n    \npublic\n \ninit\n()\n \n{}\n\n    \npublic\n \nfunc\n \nrender\n(\nparsed\n:\n \nParsedTag\n,\n \ncontext\n:\n \nLeafContext\n,\n \nrenderer\n:\n \nLeafRenderer\n)\n \nthrows\n \n-\n \nFuture\nLeafData\n?\n \n{\n\n        \n// ensure we receive precisely one parameter\n\n        \ntry\n \nparsed\n.\nrequireParameterCount\n(\n1\n)\n\n\n        \n// pull out our lone parameter as a string then uppercase it, or use an empty string\n\n        \nlet\n \nstring\n \n=\n \nparsed\n.\nparameters\n[\n0\n].\nstring\n?.\nuppercased\n()\n \n??\n \n\n\n        \n// send it back wrapped in a LeafData\n\n        \nreturn\n \nFuture\n(.\nstring\n(\nstring\n))\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe can now register this Tag in our \nconfigure.swift\n file with:\n\n\nservices\n.\nregister\n \n{\n \ncontainer\n \n-\n \nLeafConfig\n \nin\n\n    \n// take a copy of Leaf\ns default tags\n\n    \nvar\n \ntags\n \n=\n \ndefaultTags\n\n\n    \n// add our custom tag\n\n    \ntags\n[\ncustomuppercase\n]\n \n=\n \nCustomUppercase\n()\n\n\n    \n// find the location of our Resources/Views directory\n\n    \nlet\n \ndirectoryConfig\n \n=\n \ntry\n \ncontainer\n.\nmake\n(\nDirectoryConfig\n.\nself\n,\n \nfor\n:\n \nLeafRenderer\n.\nself\n)\n\n    \nlet\n \nviewsDirectory\n \n=\n \ndirectoryConfig\n.\nworkDir\n \n+\n \nResources/Views\n\n\n    \n// put all that into a new Leaf configuration and return it\n\n    \nreturn\n \nLeafConfig\n(\ntags\n:\n \ntags\n,\n \nviewsDir\n:\n \nviewsDirectory\n)\n\n\n}\n\n\n\n\n\n\nOnce that is complete, you can use \n#customuppercase(some_variable)\n to run your custom code.\n\n\n\n\nNote: Use of non-alphanumeric characters in tag names is \nstrongly discouraged\n and may be disallowed in future versions of Leaf.", 
            "title": "Custom tags"
        }, 
        {
            "location": "/leaf/custom-tags/#custom-tags", 
            "text": "You can extend Leaf to provide your own tags that add custom functionality. To demonstrate this, let's look at a basic example by recreating  #uppercase  together. This tag will take one argument, which is the string to uppercase.  When working with custom tags, there are four important things to know:   You should call  requireParameterCount()  with the number of parameters you expect to receive. This will throw an error if your tag is used incorrectly.  If you do or do not require a body, you should use either  requireBody()  or  requireNoBody() . Again, this will throw an error if your tag is used incorrectly.  You can read individual parameters using the  parameters  array. Each parameter will be of type  LeafData , which you can convert to concrete data types using properties such as  .string ,  .dictionary , and so on.  You must return a  Future LeafData?  containing what should be rendered. In the example below we wrap the resulting uppercase string in a  LeafData  string, then send that back wrapped in a future.   Here\u2019s example code for a  CustomUppercase  Leaf tag:  import   Async  import   Leaf  public   final   class   CustomUppercase :   Leaf . LeafTag   { \n     public   init ()   {} \n     public   func   render ( parsed :   ParsedTag ,   context :   LeafContext ,   renderer :   LeafRenderer )   throws   -   Future LeafData ?   { \n         // ensure we receive precisely one parameter \n         try   parsed . requireParameterCount ( 1 ) \n\n         // pull out our lone parameter as a string then uppercase it, or use an empty string \n         let   string   =   parsed . parameters [ 0 ]. string ?. uppercased ()   ??   \n\n         // send it back wrapped in a LeafData \n         return   Future (. string ( string )) \n     }  }   We can now register this Tag in our  configure.swift  file with:  services . register   {   container   -   LeafConfig   in \n     // take a copy of Leaf s default tags \n     var   tags   =   defaultTags \n\n     // add our custom tag \n     tags [ customuppercase ]   =   CustomUppercase () \n\n     // find the location of our Resources/Views directory \n     let   directoryConfig   =   try   container . make ( DirectoryConfig . self ,   for :   LeafRenderer . self ) \n     let   viewsDirectory   =   directoryConfig . workDir   +   Resources/Views \n\n     // put all that into a new Leaf configuration and return it \n     return   LeafConfig ( tags :   tags ,   viewsDir :   viewsDirectory )  }   Once that is complete, you can use  #customuppercase(some_variable)  to run your custom code.   Note: Use of non-alphanumeric characters in tag names is  strongly discouraged  and may be disallowed in future versions of Leaf.", 
            "title": "Custom Tags"
        }, 
        {
            "location": "/redis/getting-started/", 
            "text": "Redis\n\n\nRedis is a Redis client library that can communicate with a Redis database.\n\n\nWhat is Redis?\n\n\nRedis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).\n\n\nRedis works as a key-value store, but allows querying the keys, unlike most databases.\n\n\nWith and without Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/redis.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nRedis\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport Redis\n to access Redis' APIs.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/redis/getting-started/#redis", 
            "text": "Redis is a Redis client library that can communicate with a Redis database.", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/getting-started/#what-is-redis", 
            "text": "Redis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).  Redis works as a key-value store, but allows querying the keys, unlike most databases.", 
            "title": "What is Redis?"
        }, 
        {
            "location": "/redis/getting-started/#with-and-without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/redis.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Redis ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import Redis  to access Redis' APIs.", 
            "title": "With and without Vapor"
        }, 
        {
            "location": "/redis/basics/", 
            "text": "Redis basic usage\n\n\nTo interact with Redis, you first need to construct a Redis client.\nThe Redis library primarily supports \nTCP sockets\n.\n\n\nThis requires a hostname, port and \nWorker\n. The eventloop will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to \nlocalhost\n, and the port to Redis' default port \n6379\n.\n\n\nlet\n \nclient\n \n=\n \ntry\n \nRedisClient\n.\nconnect\n(\non\n:\n \nworker\n)\n \n// Future\nRedisClient\n\n\n\n\n\n\nThe \nconnect\n method will return a \nFuture\n containing the TCP based Redis Client.\n\n\nRedis Data Types\n\n\nRedis has 6 data types:\n\n\n\n\nnull\n\n\nInt\n\n\nError\n\n\nArray\n\n\nBasic String (used for command names and basic replies only)\n\n\nBulk String (used for Strings and binary data blobs)\n\n\n\n\nYou can instantiate one from the static functions and variables on \nRedisData\n.\n\n\nlet\n \nnull\n \n=\n \nRedisData\n.\nnull\n\n\n\nlet\n \nhelloWorld\n \n=\n \nRedisData\n.\nbulkString\n(\nHello World\n)\n\n\n\nlet\n \nthree\n \n=\n \nRedisData\n.\ninteger\n(\n3\n)\n\n\n\nlet\n \noneThroughTen\n \n=\n \nRedisData\n.\narray\n([\n\n  \n.\ninteger\n(\n1\n),\n\n  \n.\ninteger\n(\n2\n),\n\n  \n.\ninteger\n(\n3\n),\n\n  \n.\ninteger\n(\n4\n),\n\n  \n.\ninteger\n(\n5\n),\n\n  \n.\ninteger\n(\n6\n),\n\n  \n.\ninteger\n(\n7\n),\n\n  \n.\ninteger\n(\n8\n),\n\n  \n.\ninteger\n(\n9\n),\n\n  \n.\ninteger\n(\n10\n)\n\n\n])\n\n\n\n\n\n\nThe above is the explicit way of defining Redis Types. You can also use literals in most scenarios:\n\n\nlet\n \narray\n \n=\n \nRedisData\n.\narray\n([\n\n  \n[\n\n    \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n\n  \n],\n\n  \nHello World\n,\n\n  \nOne\n,\n\n  \nTwo\n,\n\n  \n.\nnull\n,\n\n  \n.\nnull\n,\n\n  \ntest\n\n\n])\n\n\n\n\n\n\nCRUD using Redis\n\n\nFrom here on it is assumed that your client has been successfully created and is available in the variable \nclient\n as a \nRedisClient\n.\n\n\nCreating a record\n\n\nCreating a record is done using a \nRedisData\n for a value and a key.\n\n\nclient\n.\nset\n(\nworld\n,\n \nforKey\n:\n \nhello\n)\n\n\n\n\n\n\nThis returns a future that'll indicate successful or unsuccessful insertion.\n\n\nReading a record\n\n\nReading a record is similar, only you'll get a warning if you don't use the returned future.\n\n\nThe \nFuture\nRedisData\n for the key \"hello\" will be \"world\" if you created the record as shown above.\n\n\nlet\n \nfutureRecord\n \n=\n \nclient\n.\ngetData\n(\nforKey\n:\n \nhello\n)\n \n// Future\nRedisData\n\n\n\n\n\n\nDeleting a record\n\n\nDeleting a record is similar but allows querying the keys, too.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\nhello\n])\n\n\n\n\n\n\nWhere the above command will remove the key \"hello\", the next command will delete \nall\n keys from the Redis database.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\n*\n])", 
            "title": "Basics"
        }, 
        {
            "location": "/redis/basics/#redis-basic-usage", 
            "text": "To interact with Redis, you first need to construct a Redis client.\nThe Redis library primarily supports  TCP sockets .  This requires a hostname, port and  Worker . The eventloop will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to  localhost , and the port to Redis' default port  6379 .  let   client   =   try   RedisClient . connect ( on :   worker )   // Future RedisClient   The  connect  method will return a  Future  containing the TCP based Redis Client.", 
            "title": "Redis basic usage"
        }, 
        {
            "location": "/redis/basics/#redis-data-types", 
            "text": "Redis has 6 data types:   null  Int  Error  Array  Basic String (used for command names and basic replies only)  Bulk String (used for Strings and binary data blobs)   You can instantiate one from the static functions and variables on  RedisData .  let   null   =   RedisData . null  let   helloWorld   =   RedisData . bulkString ( Hello World )  let   three   =   RedisData . integer ( 3 )  let   oneThroughTen   =   RedisData . array ([ \n   . integer ( 1 ), \n   . integer ( 2 ), \n   . integer ( 3 ), \n   . integer ( 4 ), \n   . integer ( 5 ), \n   . integer ( 6 ), \n   . integer ( 7 ), \n   . integer ( 8 ), \n   . integer ( 9 ), \n   . integer ( 10 )  ])   The above is the explicit way of defining Redis Types. You can also use literals in most scenarios:  let   array   =   RedisData . array ([ \n   [ \n     1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 \n   ], \n   Hello World , \n   One , \n   Two , \n   . null , \n   . null , \n   test  ])", 
            "title": "Redis Data Types"
        }, 
        {
            "location": "/redis/basics/#crud-using-redis", 
            "text": "From here on it is assumed that your client has been successfully created and is available in the variable  client  as a  RedisClient .", 
            "title": "CRUD using Redis"
        }, 
        {
            "location": "/redis/basics/#creating-a-record", 
            "text": "Creating a record is done using a  RedisData  for a value and a key.  client . set ( world ,   forKey :   hello )   This returns a future that'll indicate successful or unsuccessful insertion.", 
            "title": "Creating a record"
        }, 
        {
            "location": "/redis/basics/#reading-a-record", 
            "text": "Reading a record is similar, only you'll get a warning if you don't use the returned future.  The  Future RedisData  for the key \"hello\" will be \"world\" if you created the record as shown above.  let   futureRecord   =   client . getData ( forKey :   hello )   // Future RedisData", 
            "title": "Reading a record"
        }, 
        {
            "location": "/redis/basics/#deleting-a-record", 
            "text": "Deleting a record is similar but allows querying the keys, too.  client . delete ( keys :   [ hello ])   Where the above command will remove the key \"hello\", the next command will delete  all  keys from the Redis database.  client . delete ( keys :   [ * ])", 
            "title": "Deleting a record"
        }, 
        {
            "location": "/redis/custom-commands/", 
            "text": "Custom commands\n\n\nMany commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.\n\n\n(Almost) all functions listed here\n work out of the box using custom commands.\n\n\nUsage\n\n\nThe Redis client has a \nrun\n function that allows you to run these commands.\n\n\nThe following code demonstrates a \"custom\" implementation for \nGET\n.\n\n\nlet\n \nfuture\n \n=\n \nclient\n.\nrun\n(\ncommand\n:\n \nGET\n,\n \narguments\n:\n \n[\nmy-key\n])\n \n// Future\nRedisData\n\n\n\n\n\n\nThis future will contain the result as specified in the article on the redis command page or an error.\n\n\nThe future can be used as described in the \nAsync API\n.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#custom-commands", 
            "text": "Many commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.  (Almost) all functions listed here  work out of the box using custom commands.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#usage", 
            "text": "The Redis client has a  run  function that allows you to run these commands.  The following code demonstrates a \"custom\" implementation for  GET .  let   future   =   client . run ( command :   GET ,   arguments :   [ my-key ])   // Future RedisData   This future will contain the result as specified in the article on the redis command page or an error.  The future can be used as described in the  Async API .", 
            "title": "Usage"
        }, 
        {
            "location": "/redis/pub-sub/", 
            "text": "Publish \n Subscribe\n\n\nRedis' Publish and Subscribe model is really useful for notifications.\n\n\nUse cases\n\n\nPub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.\n\n\nA channel consists of a name and group of listeners. Think of it as being \n[String: [Listener]]\n.\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.\n\n\nChannels must be a string. For chat groups, for example, you could use the database identifier.\n\n\nPublishing\n\n\nYou cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:\n\n\n// Any redis data\n\n\nlet\n \nnotification\n:\n \nRedisData\n \n=\n \nMy-Notification\n\n\n\nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n\n\n\n\n\n\nIf you want access to the listener count:\n\n\nlet\n \nnotifiedCount\n \n=\n \nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n \n// Future\nInt\n\n\n\n\n\n\nSubscribing\n\n\nTo subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.\n\n\nA single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a \nSubscriptionStream\n.\n\n\nlet\n \nnotifications\n \n=\n \nclient\n.\nsubscribe\n(\nto\n:\n \n[\nsome-notification-channel\n,\n \nother-notification-channel\n])\n\n\n\n\n\n\nIf you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.\n\n\nThis stream will receive messages asynchronously from the point of \ndraining\n. This works like \nany other async stream\n\n\nNotifications consist of the channel and payload.\n\n\nnotifications\n.\ndrain\n \n{\n \nnotification\n \nin\n\n  \nprint\n(\nnotification\n.\nchannel\n)\n\n\n  \nlet\n \npayload\n \n=\n \nnotification\n.\npayload\n\n\n  \n// \nTODO:\n Process the payload\n\n\n}", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#publish-subscribe", 
            "text": "Redis' Publish and Subscribe model is really useful for notifications.", 
            "title": "Publish &amp; Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#use-cases", 
            "text": "Pub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.  A channel consists of a name and group of listeners. Think of it as being  [String: [Listener]] .\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.  Channels must be a string. For chat groups, for example, you could use the database identifier.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pub-sub/#publishing", 
            "text": "You cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:  // Any redis data  let   notification :   RedisData   =   My-Notification  client . publish ( notification ,   to :   my-channel )   If you want access to the listener count:  let   notifiedCount   =   client . publish ( notification ,   to :   my-channel )   // Future Int", 
            "title": "Publishing"
        }, 
        {
            "location": "/redis/pub-sub/#subscribing", 
            "text": "To subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.  A single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a  SubscriptionStream .  let   notifications   =   client . subscribe ( to :   [ some-notification-channel ,   other-notification-channel ])   If you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.  This stream will receive messages asynchronously from the point of  draining . This works like  any other async stream  Notifications consist of the channel and payload.  notifications . drain   {   notification   in \n   print ( notification . channel ) \n\n   let   payload   =   notification . payload \n\n   //  TODO:  Process the payload  }", 
            "title": "Subscribing"
        }, 
        {
            "location": "/redis/pipeline/", 
            "text": "Pipelining\n\n\nPipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle. \n\n\nUse cases\n\n\nSometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.\n\n\nEnqueuing Commands\n\n\n \nlet\n \npipeline\n \n=\n \nconnection\n.\nmakePipeline\n()\n\n \nlet\n \nresult\n \n=\n \ntry\n \npipeline\n\n         \n.\nenqueue\n(\ncommand\n:\n \nSET\n,\n \narguments\n:\n \n[\nKEY\n,\n \nVALUE\n])\n\n         \n.\nenqueue\n(\ncommand\n:\n \nINCR\n,\n \narguments\n:\n \n[\nCOUNT\n])\n\n         \n.\nexecute\n()\n \n// Future\n[RedisData]\n\n\n\n\n\n\nNote: Commands will not be executed until execute is called.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/redis/pipeline/#pipelining", 
            "text": "Pipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle.", 
            "title": "Pipelining"
        }, 
        {
            "location": "/redis/pipeline/#use-cases", 
            "text": "Sometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pipeline/#enqueuing-commands", 
            "text": "let   pipeline   =   connection . makePipeline () \n  let   result   =   try   pipeline \n          . enqueue ( command :   SET ,   arguments :   [ KEY ,   VALUE ]) \n          . enqueue ( command :   INCR ,   arguments :   [ COUNT ]) \n          . execute ()   // Future [RedisData]   Note: Commands will not be executed until execute is called.", 
            "title": "Enqueuing Commands"
        }, 
        {
            "location": "/websocket/websocket/", 
            "text": "WebSocket\n\n\nComing soon.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/websocket/websocket/#websocket", 
            "text": "Coming soon.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/crypto/getting-started/", 
            "text": "Using Crypto\n\n\nCrypto is a library containing all common APIs related to cryptography and security.\n\n\nThis project does \nnot\n support TLS. For that, please see \nthe TLS package\n.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nCrypto\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/crypto.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \nx.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nCrypto\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Crypto\n to access Crypto's APIs.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/crypto/getting-started/#using-crypto", 
            "text": "Crypto is a library containing all common APIs related to cryptography and security.  This project does  not  support TLS. For that, please see  the TLS package .", 
            "title": "Using Crypto"
        }, 
        {
            "location": "/crypto/getting-started/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Crypto", 
            "title": "With Vapor"
        }, 
        {
            "location": "/crypto/getting-started/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/crypto.git ,   . upToNextMajor ( from :   x.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Crypto ,   ...   ]) \n     ]  )   Use  import Crypto  to access Crypto's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/crypto/base64/", 
            "text": "Base64\n\n\nComing soon", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/base64/#base64", 
            "text": "Coming soon", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/hash/", 
            "text": "Hash\n\n\nHashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.\n\n\nAvailable hashes\n\n\nCrypto currently supports a few hashes.\n\n\n\n\nMD5\n\n\nSHA1\n\n\nSHA2 (all variants)\n\n\n\n\nMD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.\n\n\nEvery Hash type has a set of helpers that you can use.\n\n\nHashing blobs of data\n\n\nEvery \nHash\n has a static method called \nhash\n that can be used for hashing the entire contents of \nFoundation.Data\n, \nByteBuffer\n or \nString\n.\n\n\nThe result is \nData\n containing the resulting hash. The hash's length is according to spec and defined in the static variable \ndigestSize\n.\n\n\n// MD5 with `Data`\n\n\nlet\n \nfileData\n \n=\n \nData\n()\n\n\nlet\n \nfileMD5\n \n=\n \nMD5\n.\nhash\n(\nfileData\n)\n\n\n\n// SHA1 with `ByteBuffer`\n\n\nlet\n \nfileBuffer\n:\n \nByteBuffer\n \n=\n \n...\n\n\nlet\n \nfileSHA1\n \n=\n \nSHA1\n.\nhash\n(\nfileBuffer\n)\n\n\n\n// SHA2 variants with String\n\n\nlet\n \nstaticUnsafeToken\n:\n \nString\n \n=\n \nrsadd14ndmasidfm12i4j\n\n\n\nlet\n \ntokenHashSHA224\n \n=\n \nSHA224\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA256\n \n=\n \nSHA256\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA384\n \n=\n \nSHA384\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA512\n \n=\n \nSHA512\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\n\n\n\n\nIncremental hashes (manual)\n\n\nTo incrementally process hashes you can create an instance of the Hash. This will set up a context.\n\n\nAll hash context initializers are empty:\n\n\n// Create an MD5 context\n\n\nlet\n \nmd5Context\n \n=\n \nMD5\n()\n\n\n\n\n\n\nTo process a single chunk of data, you can call the \nupdate\n function on a context using any \nSequence\n of \nUInt8\n. That means \nArray\n, \nData\n and \nByteBuffer\n work alongside any other sequence of bytes.\n\n\nmd5Context\n.\nupdate\n(\ndata\n)\n\n\n\n\n\n\nThe data data need not be a specific length. Any length works.\n\n\nWhen you need the result, you can call \nmd5Context.finalize()\n. This will finish calculating the hash by appending the standard \n1\n bit, padding and message bitlength.\n\n\nYou can optionally provide a last set of data to \nfinalize()\n.\n\n\nAfter calling \nfinalize()\n, do not update the hash if you want correct results.\n\n\nFetching the results\n\n\nThe context can then be accessed to extract the resulting Hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nmd5Context\n.\nhash\n\n\n\n\n\n\nStreaming hashes (Async)\n\n\nSometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use \nByteStreamHasher\n.\n\n\nFirst, create a new generic \nByteStreamHasher\nHash\n where \nHash\n is the hash you want to use. In this case, SHA512.\n\n\nlet\n \nstreamHasher\n \n=\n \nByteStreamHasher\nSHA512\n()\n\n\n\n\n\n\nThis stream works like any \ninputStream\n by consuming the incoming data and passing the buffers to the hash context.\n\n\nFor example, draining a TCP socket.\n\n\nlet\n \nsocket\n:\n \nTCP\n.\nSocket\n \n=\n \n...\n\n\n\nsocket\n.\ndrain\n(\ninto\n:\n \nstreamHasher\n)\n\n\n\n\n\n\nThis will incrementally update the hash using the provided TCP socket's data.\n\n\nWhen the hash has been completely accumulated, you can \ncomplete\n the hash.\n\n\nlet\n \nhash\n \n=\n \nstreamHasher\n.\ncomplete\n()\n \n// Foundation `Data`\n\n\n\n\n\n\nThis will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Hashes"
        }, 
        {
            "location": "/crypto/hash/#hash", 
            "text": "Hashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.", 
            "title": "Hash"
        }, 
        {
            "location": "/crypto/hash/#available-hashes", 
            "text": "Crypto currently supports a few hashes.   MD5  SHA1  SHA2 (all variants)   MD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.  Every Hash type has a set of helpers that you can use.", 
            "title": "Available hashes"
        }, 
        {
            "location": "/crypto/hash/#hashing-blobs-of-data", 
            "text": "Every  Hash  has a static method called  hash  that can be used for hashing the entire contents of  Foundation.Data ,  ByteBuffer  or  String .  The result is  Data  containing the resulting hash. The hash's length is according to spec and defined in the static variable  digestSize .  // MD5 with `Data`  let   fileData   =   Data ()  let   fileMD5   =   MD5 . hash ( fileData )  // SHA1 with `ByteBuffer`  let   fileBuffer :   ByteBuffer   =   ...  let   fileSHA1   =   SHA1 . hash ( fileBuffer )  // SHA2 variants with String  let   staticUnsafeToken :   String   =   rsadd14ndmasidfm12i4j  let   tokenHashSHA224   =   SHA224 . hash ( staticUnsafeToken )  let   tokenHashSHA256   =   SHA256 . hash ( staticUnsafeToken )  let   tokenHashSHA384   =   SHA384 . hash ( staticUnsafeToken )  let   tokenHashSHA512   =   SHA512 . hash ( staticUnsafeToken )", 
            "title": "Hashing blobs of data"
        }, 
        {
            "location": "/crypto/hash/#incremental-hashes-manual", 
            "text": "To incrementally process hashes you can create an instance of the Hash. This will set up a context.  All hash context initializers are empty:  // Create an MD5 context  let   md5Context   =   MD5 ()   To process a single chunk of data, you can call the  update  function on a context using any  Sequence  of  UInt8 . That means  Array ,  Data  and  ByteBuffer  work alongside any other sequence of bytes.  md5Context . update ( data )   The data data need not be a specific length. Any length works.  When you need the result, you can call  md5Context.finalize() . This will finish calculating the hash by appending the standard  1  bit, padding and message bitlength.  You can optionally provide a last set of data to  finalize() .  After calling  finalize() , do not update the hash if you want correct results.", 
            "title": "Incremental hashes (manual)"
        }, 
        {
            "location": "/crypto/hash/#fetching-the-results", 
            "text": "The context can then be accessed to extract the resulting Hash.  let   hash :   Data   =   md5Context . hash", 
            "title": "Fetching the results"
        }, 
        {
            "location": "/crypto/hash/#streaming-hashes-async", 
            "text": "Sometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use  ByteStreamHasher .  First, create a new generic  ByteStreamHasher Hash  where  Hash  is the hash you want to use. In this case, SHA512.  let   streamHasher   =   ByteStreamHasher SHA512 ()   This stream works like any  inputStream  by consuming the incoming data and passing the buffers to the hash context.  For example, draining a TCP socket.  let   socket :   TCP . Socket   =   ...  socket . drain ( into :   streamHasher )   This will incrementally update the hash using the provided TCP socket's data.  When the hash has been completely accumulated, you can  complete  the hash.  let   hash   =   streamHasher . complete ()   // Foundation `Data`   This will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Streaming hashes (Async)"
        }, 
        {
            "location": "/crypto/mac/", 
            "text": "Message authentication\n\n\nMessage authentication is used for verifying message authenticity and validity.\n\n\nCommon use cases are JSON Web Tokens.\n\n\nFor message authentication, Vapor only supports HMAC.\n\n\nUsing HMAC\n\n\nTo use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.\n\n\nlet\n \nhash\n \n=\n \nHMAC\nSHA224\n.\nauthenticate\n(\nmessage\n,\n \nwithKey\n:\n \nauthenticationKey\n)", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#message-authentication", 
            "text": "Message authentication is used for verifying message authenticity and validity.  Common use cases are JSON Web Tokens.  For message authentication, Vapor only supports HMAC.", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#using-hmac", 
            "text": "To use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.  let   hash   =   HMAC SHA224 . authenticate ( message ,   withKey :   authenticationKey )", 
            "title": "Using HMAC"
        }, 
        {
            "location": "/crypto/passwords/", 
            "text": "Password hashing\n\n\nPassword management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.\n\n\nFor password hashing Vapor supports PBKDF2 and BCrypt.\n\n\nWe recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.\n\n\nBCrypt\n\n\nBCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.\n\n\nDeriving a key\n\n\nUnlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.\n\n\nThe output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.\n\n\nlet\n \nresult\n:\n \nData\n \n=\n \ntry\n \nBCrypt\n.\nmake\n(\nmessage\n:\n \nMyPassword\n)\n\n\n\nguard\n \ntry\n \nBCrypt\n.\nverify\n(\nmessage\n:\n \nMyPassword\n,\n \nmatches\n:\n \nresult\n)\n \nelse\n \n{\n\n    \nfatalError\n(\nThis never triggers, since the verification process will always be successful for the same password and conditions\n)\n\n\n}\n\n\n\n\n\n\nThe default cost factor is \n12\n, based on the official recommendations.\n\n\nStoring the derived key as a String\n\n\nBCrypt always outputs valid ASCII/UTF-8 for the resulting hash.\n\n\nThis means you can convert the output \nData\n to a \nString\n as such:\n\n\nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nresult\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n    \n// This must never trigger\n\n\n}\n\n\n\n\n\n\nPBKDF2\n\n\nPBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.\n\n\nPBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.\n\n\nFor PBKDF2 you also select the Hash using generics.\n\n\nDeriving a key\n\n\nIn the following example:\n\n\n\n\npassword\n is either a \nString\n or \nData\n\n\nThe \nsalt\n is \nData\n\n\nIterations is defaulted to \n10_000\n iterations\n\n\nThe keySize is equivalent to 1 hash's length.\n\n\n\n\n// Generate a random salt\n\n\nlet\n \nsalt\n:\n \nData\n \n=\n \nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n)\n\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n)\n\n\n\n\n\n\nYou can optionally configure PBKDF2 to use a different iteration count and output keysize.\n\n\n// Iterates 20\n000 times and outputs 100 bytes\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n,\n \niterating\n:\n \n20_000\n,\n \nderivedKeyLength\n:\n \n100\n)\n\n\n\n\n\n\nStoring the results\n\n\nWhen you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#password-hashing", 
            "text": "Password management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.  For password hashing Vapor supports PBKDF2 and BCrypt.  We recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#bcrypt", 
            "text": "BCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.", 
            "title": "BCrypt"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key", 
            "text": "Unlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.  The output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.  let   result :   Data   =   try   BCrypt . make ( message :   MyPassword )  guard   try   BCrypt . verify ( message :   MyPassword ,   matches :   result )   else   { \n     fatalError ( This never triggers, since the verification process will always be successful for the same password and conditions )  }   The default cost factor is  12 , based on the official recommendations.", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-derived-key-as-a-string", 
            "text": "BCrypt always outputs valid ASCII/UTF-8 for the resulting hash.  This means you can convert the output  Data  to a  String  as such:  guard   let   string   =   String ( bytes :   result ,   encoding :   . utf8 )   else   { \n     // This must never trigger  }", 
            "title": "Storing the derived key as a String"
        }, 
        {
            "location": "/crypto/passwords/#pbkdf2", 
            "text": "PBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.  PBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.  For PBKDF2 you also select the Hash using generics.", 
            "title": "PBKDF2"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key_1", 
            "text": "In the following example:   password  is either a  String  or  Data  The  salt  is  Data  Iterations is defaulted to  10_000  iterations  The keySize is equivalent to 1 hash's length.   // Generate a random salt  let   salt :   Data   =   OSRandom (). data ( count :   32 )  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt )   You can optionally configure PBKDF2 to use a different iteration count and output keysize.  // Iterates 20 000 times and outputs 100 bytes  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt ,   iterating :   20_000 ,   derivedKeyLength :   100 )", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-results", 
            "text": "When you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Storing the results"
        }, 
        {
            "location": "/crypto/random/", 
            "text": "Random\n\n\nCrypto has two primary random number generators.\n\n\nOSRandom generates random numbers by calling the operating system's random number generator.\n\n\nURandom generates random numbers by reading from \n/dev/urandom\n.\n\n\nAccessing random numbers\n\n\nFirst, create an instance of the preferred random number generator:\n\n\nlet\n \nrandom\n \n=\n \nOSRandom\n()\n\n\n\n\n\n\nor\n\n\nlet\n \nrandom\n \n=\n \ntry\n \nURandom\n()\n\n\n\n\n\n\nReading integers\n\n\nFor every Swift integer a random number function exists.\n\n\nlet\n \nint8\n:\n \nInt8\n \n=\n \ntry\n \nrandom\n.\nmakeInt8\n()\n\n\nlet\n \nuint8\n:\n \nUInt8\n \n=\n \ntry\n \nrandom\n.\nmakeUInt8\n()\n\n\nlet\n \nint16\n:\n \nInt16\n \n=\n \ntry\n \nrandom\n.\nmakeInt16\n()\n\n\nlet\n \nuint16\n:\n \nUInt16\n \n=\n \ntry\n \nrandom\n.\nmakeUInt16\n()\n\n\nlet\n \nint32\n:\n \nInt32\n \n=\n \ntry\n \nrandom\n.\nmakeInt32\n()\n\n\nlet\n \nuint32\n:\n \nUInt32\n \n=\n \ntry\n \nrandom\n.\nmakeUInt32\n()\n\n\nlet\n \nint64\n:\n \nInt64\n \n=\n \ntry\n \nrandom\n.\nmakeInt64\n()\n\n\nlet\n \nuint64\n:\n \nUInt64\n \n=\n \ntry\n \nrandom\n.\nmakeUInt64\n()\n\n\nlet\n \nint\n:\n \nInt\n \n=\n \ntry\n \nrandom\n.\nmakeInt\n()\n\n\nlet\n \nuint\n:\n \nUInt\n \n=\n \ntry\n \nrandom\n.\nmakeUInt\n()\n\n\n\n\n\n\nReading random data\n\n\nRandom buffers of data are useful when, for example, generating tokens or other unique strings/blobs.\n\n\nTo generate a buffer of random data:\n\n\n// generates 20 random bytes\n\n\nlet\n \ndata\n:\n \nData\n \n=\n \nrandom\n.\ndata\n(\ncount\n:\n \n20\n)", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#random", 
            "text": "Crypto has two primary random number generators.  OSRandom generates random numbers by calling the operating system's random number generator.  URandom generates random numbers by reading from  /dev/urandom .", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#accessing-random-numbers", 
            "text": "First, create an instance of the preferred random number generator:  let   random   =   OSRandom ()   or  let   random   =   try   URandom ()", 
            "title": "Accessing random numbers"
        }, 
        {
            "location": "/crypto/random/#reading-integers", 
            "text": "For every Swift integer a random number function exists.  let   int8 :   Int8   =   try   random . makeInt8 ()  let   uint8 :   UInt8   =   try   random . makeUInt8 ()  let   int16 :   Int16   =   try   random . makeInt16 ()  let   uint16 :   UInt16   =   try   random . makeUInt16 ()  let   int32 :   Int32   =   try   random . makeInt32 ()  let   uint32 :   UInt32   =   try   random . makeUInt32 ()  let   int64 :   Int64   =   try   random . makeInt64 ()  let   uint64 :   UInt64   =   try   random . makeUInt64 ()  let   int :   Int   =   try   random . makeInt ()  let   uint :   UInt   =   try   random . makeUInt ()", 
            "title": "Reading integers"
        }, 
        {
            "location": "/crypto/random/#reading-random-data", 
            "text": "Random buffers of data are useful when, for example, generating tokens or other unique strings/blobs.  To generate a buffer of random data:  // generates 20 random bytes  let   data :   Data   =   random . data ( count :   20 )", 
            "title": "Reading random data"
        }, 
        {
            "location": "/version/1_5/", 
            "text": "Redirecting...", 
            "title": "1.5"
        }, 
        {
            "location": "/version/1_5/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/2_0/", 
            "text": "Redirecting...", 
            "title": "2.0"
        }, 
        {
            "location": "/version/2_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/3_0/", 
            "text": "Redirecting...", 
            "title": "3.0-alpha"
        }, 
        {
            "location": "/version/3_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/support/", 
            "text": "Version Support\n\n\n\n\nVapor 3.0 is currently in beta.\n\n\nVapor 2.0 is currently active.\n\n\nVapor 1.5 is being maintained until November 2017.\n\n\n\n\nWarning\n\n\nDashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.\n\n\n\n\nCore\n\n\nAll packages in the \nVapor GitHub\n are maintained according to the following rules.\n\n\nActive\n\n\nWhile a version is active, reported security issues and bugs are fixed.\n\n\nAdditionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.\n\n\nMaintenance\n\n\nWhen a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.\n\n\n\n\nNote\n\n\nOnly the latest minor version will be maintained.\n\n\n\n\nUnstable\n\n\nThe master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.\n\n\nCommunity\n\n\nAll packages in the \nVapor Community GitHub\n are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Support"
        }, 
        {
            "location": "/version/support/#version-support", 
            "text": "Vapor 3.0 is currently in beta.  Vapor 2.0 is currently active.  Vapor 1.5 is being maintained until November 2017.   Warning  Dashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.", 
            "title": "Version Support"
        }, 
        {
            "location": "/version/support/#core", 
            "text": "All packages in the  Vapor GitHub  are maintained according to the following rules.", 
            "title": "Core"
        }, 
        {
            "location": "/version/support/#active", 
            "text": "While a version is active, reported security issues and bugs are fixed.  Additionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.", 
            "title": "Active"
        }, 
        {
            "location": "/version/support/#maintenance", 
            "text": "When a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.   Note  Only the latest minor version will be maintained.", 
            "title": "Maintenance"
        }, 
        {
            "location": "/version/support/#unstable", 
            "text": "The master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.", 
            "title": "Unstable"
        }, 
        {
            "location": "/version/support/#community", 
            "text": "All packages in the  Vapor Community GitHub  are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Community"
        }
    ]
}