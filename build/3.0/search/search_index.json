{
    "docs": [
        {
            "location": "/", 
            "text": "Vapor Documentation\n\n\nThis is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.\n\n\nVapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.\n\n\nGetting Started\n\n\nIf this is your first time using Vapor, head to the \nInstall \n macOS\n section to install Swift and Vapor.\n\n\nOnce you have Vapor installed, check out \nGetting Started \n Hello, world\n to create your first Vapor app!\n\n\nLike Vapor?\n\n\nOur small team works hard to make Vapor awesome (and free). Support the framework by \nstarring Vapor on GitHub\n \nor \ndonating $1 monthly\nit helps us a lot. Thanks!\n\n\nOther Sources\n\n\nHere are some other great places to find information about Vapor.\n\n\n\n\n\n\n\n\nname\n\n\ndescription\n\n\nlink\n\n\n\n\n\n\n\n\n\n\nVapor Slack\n\n\nChat with ~5,000 Vapor developers.\n\n\nvisit \n\n\n\n\n\n\nAPI docs\n\n\nAuto-generated documentation from code comments.\n\n\nvisit \n\n\n\n\n\n\nStack Overflow\n\n\nAsk and answer questions with the \nvapor\n tag.\n\n\nvisit \n\n\n\n\n\n\nSource Code\n\n\nLearn how Vapor works under the hood.\n\n\nvisit \n\n\n\n\n\n\nGitHub Issues\n\n\nReport bugs or request features on GitHub.\n\n\nvisit \n\n\n\n\n\n\n\n\nProviders\n\n\nVapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the \nvapor-provider\n tag on GitHub.\n\n\nAuthors\n\n\nTanner Nelson\n, \nLogan Wright\n, \nJoannis Orlandos\n, and the hundreds of members of Vapor.", 
            "title": "Overview"
        }, 
        {
            "location": "/#vapor-documentation", 
            "text": "This is the documentation for Vapor, a Web Framework for Swift that works on iOS, macOS, and Ubuntu; and all of the packages that Vapor offers.  Vapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API.", 
            "title": "Vapor Documentation"
        }, 
        {
            "location": "/#getting-started", 
            "text": "If this is your first time using Vapor, head to the  Install   macOS  section to install Swift and Vapor.  Once you have Vapor installed, check out  Getting Started   Hello, world  to create your first Vapor app!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#like-vapor", 
            "text": "Our small team works hard to make Vapor awesome (and free). Support the framework by  starring Vapor on GitHub  \nor  donating $1 monthly it helps us a lot. Thanks!", 
            "title": "Like Vapor?"
        }, 
        {
            "location": "/#other-sources", 
            "text": "Here are some other great places to find information about Vapor.     name  description  link      Vapor Slack  Chat with ~5,000 Vapor developers.  visit     API docs  Auto-generated documentation from code comments.  visit     Stack Overflow  Ask and answer questions with the  vapor  tag.  visit     Source Code  Learn how Vapor works under the hood.  visit     GitHub Issues  Report bugs or request features on GitHub.  visit", 
            "title": "Other Sources"
        }, 
        {
            "location": "/#providers", 
            "text": "Vapor providers are a convenient way to add functionality to your Vapor projects. \nFor a full list of providers, check out the  vapor-provider  tag on GitHub.", 
            "title": "Providers"
        }, 
        {
            "location": "/#authors", 
            "text": "Tanner Nelson ,  Logan Wright ,  Joannis Orlandos , and the hundreds of members of Vapor.", 
            "title": "Authors"
        }, 
        {
            "location": "/install/macos/", 
            "text": "Install on macOS\n\n\nTo use Vapor on macOS, you just need to have Xcode 9 or greater installed.\n\n\n\n\nTip\n\n\nYou need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.\n\n\n\n\nInstall Xcode\n\n\nInstall \nXcode 9 or greater\n from the Mac App Store.\n\n\n\n\n\n\nWarning\n\n\nAfter Xcode has been downloaded, you must open it to finish the installation. This may take a while.\n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nInstall Vapor\n\n\nNow that you have Swift 4, let's install the \nVapor Toolbox\n.\n\n\nThe toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.\n\n\nbrew install vapor/tap/vapor\n\n\n\n\n\n\n\nTip\n\n\nIf you don't already have Homebrew installed, install it at \nbrew.sh \n\n\n\n\nVerify Installation\n\n\nDouble check the installation was successful by opening Terminal and running:\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.", 
            "title": "macOS"
        }, 
        {
            "location": "/install/macos/#install-on-macos", 
            "text": "To use Vapor on macOS, you just need to have Xcode 9 or greater installed.   Tip  You need to install Xcode to install Swift, but after that you can use any text editor \nyou like to develop Vapor apps.", 
            "title": "Install on macOS"
        }, 
        {
            "location": "/install/macos/#install-xcode", 
            "text": "Install  Xcode 9 or greater  from the Mac App Store.    Warning  After Xcode has been downloaded, you must open it to finish the installation. This may take a while.", 
            "title": "Install Xcode"
        }, 
        {
            "location": "/install/macos/#verify-installation", 
            "text": "Double check the installation was successful by opening Terminal and running:  swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#install-vapor", 
            "text": "Now that you have Swift 4, let's install the  Vapor Toolbox .  The toolbox includes all of Vapor's dependencies as well as a handy CLI tool for creating new projects.  brew install vapor/tap/vapor   Tip  If you don't already have Homebrew installed, install it at  brew.sh", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/macos/#verify-installation_1", 
            "text": "Double check the installation was successful by opening Terminal and running:  vapor --help  You should see a long list of available commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/macos/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/", 
            "text": "Install on Ubuntu\n\n\nInstalling Vapor on Ubuntu only takes a couple of minutes.\n\n\nSupported\n\n\nVapor supports the same versions of Ubuntu that Swift supports.\n\n\n\n\n\n\n\n\nVersion\n\n\nCodename\n\n\n\n\n\n\n\n\n\n\n16.10\n\n\nYakkety Yak\n\n\n\n\n\n\n16.04\n\n\nXenial Xerus\n\n\n\n\n\n\n14.04\n\n\nTrusty Tahr\n\n\n\n\n\n\n\n\nAPT Repo\n\n\nAdd Vapor's APT repo to get access to all of Vapor's Ubuntu packages.\n\n\nQuick Script\n\n\nEasily add Vapor's APT repo with this handy script.\n\n\neval\n \n$(\ncurl -sL https://apt.vapor.sh\n)\n\n\n\n\n\n\n\n\nTip\n\n\nThis command requires \ncurl\n which can be installed using \nsudo apt-get install curl\n\n\n\n\nDockerfile\n\n\nWhen configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:\n\n\nRUN /bin/bash -c \n$(\nwget -qO- https://apt.vapor.sh\n)\n\n\n\n\n\n\nManual\n\n\nOr add the repo manually.\n\n\nwget -q https://repo.vapor.codes/apt/keyring.gpg -O- \n|\n sudo apt-key add -\n\necho\n \ndeb https://repo.vapor.codes/apt \n$(\nlsb_release -sc\n)\n main\n \n|\n sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update\n\n\n\n\n\nInstall Vapor\n\n\nNow that you have added Vapor's APT repo, you can install the required dependencies.\n\n\nsudo apt-get install swift vapor\n\n\n\n\n\nVerify Installation\n\n\nDouble check everything worked with the following commands.\n\n\nSwift\n\n\nswift --version\n\n\n\n\n\nYou should see output similar to:\n\n\nApple Swift version \n4\n.0.2 \n(\nswiftlang-900.0.69.2 clang-900.0.38\n)\n\nTarget: x86_64-apple-macosx10.9\n\n\n\n\n\nVapor requires Swift 4.\n\n\nVapor Toolbox\n\n\nvapor --help\n\n\n\n\n\nYou should see a long list of available commands.\n\n\nDone\n\n\nNow that you have installed Vapor, create your first app in \nGetting Started \n Hello, world\n.\n\n\nSwift.org\n\n\nCheck out \nSwift.org\n's guide to \nusing downloads\n if you need more detailed instructions for installing Swift 4.", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#install-on-ubuntu", 
            "text": "Installing Vapor on Ubuntu only takes a couple of minutes.", 
            "title": "Install on Ubuntu"
        }, 
        {
            "location": "/install/ubuntu/#supported", 
            "text": "Vapor supports the same versions of Ubuntu that Swift supports.     Version  Codename      16.10  Yakkety Yak    16.04  Xenial Xerus    14.04  Trusty Tahr", 
            "title": "Supported"
        }, 
        {
            "location": "/install/ubuntu/#apt-repo", 
            "text": "Add Vapor's APT repo to get access to all of Vapor's Ubuntu packages.", 
            "title": "APT Repo"
        }, 
        {
            "location": "/install/ubuntu/#quick-script", 
            "text": "Easily add Vapor's APT repo with this handy script.  eval   $( curl -sL https://apt.vapor.sh )    Tip  This command requires  curl  which can be installed using  sudo apt-get install curl", 
            "title": "Quick Script"
        }, 
        {
            "location": "/install/ubuntu/#dockerfile", 
            "text": "When configuring Ubuntu from a Dockerfile, adding the APT repo can be done via this command:  RUN /bin/bash -c  $( wget -qO- https://apt.vapor.sh )", 
            "title": "Dockerfile"
        }, 
        {
            "location": "/install/ubuntu/#manual", 
            "text": "Or add the repo manually.  wget -q https://repo.vapor.codes/apt/keyring.gpg -O-  |  sudo apt-key add - echo   deb https://repo.vapor.codes/apt  $( lsb_release -sc )  main   |  sudo tee /etc/apt/sources.list.d/vapor.list\nsudo apt-get update", 
            "title": "Manual"
        }, 
        {
            "location": "/install/ubuntu/#install-vapor", 
            "text": "Now that you have added Vapor's APT repo, you can install the required dependencies.  sudo apt-get install swift vapor", 
            "title": "Install Vapor"
        }, 
        {
            "location": "/install/ubuntu/#verify-installation", 
            "text": "Double check everything worked with the following commands.", 
            "title": "Verify Installation"
        }, 
        {
            "location": "/install/ubuntu/#swift", 
            "text": "swift --version  You should see output similar to:  Apple Swift version  4 .0.2  ( swiftlang-900.0.69.2 clang-900.0.38 ) \nTarget: x86_64-apple-macosx10.9  Vapor requires Swift 4.", 
            "title": "Swift"
        }, 
        {
            "location": "/install/ubuntu/#vapor-toolbox", 
            "text": "vapor --help  You should see a long list of available commands.", 
            "title": "Vapor Toolbox"
        }, 
        {
            "location": "/install/ubuntu/#done", 
            "text": "Now that you have installed Vapor, create your first app in  Getting Started   Hello, world .", 
            "title": "Done"
        }, 
        {
            "location": "/install/ubuntu/#swiftorg", 
            "text": "Check out  Swift.org 's guide to  using downloads  if you need more detailed instructions for installing Swift 4.", 
            "title": "Swift.org"
        }, 
        {
            "location": "/getting-started/hello-world/", 
            "text": "Hello, world\n\n\nNow that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.\n\n\nNew Project\n\n\nThe first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project \nHello\n.\n\n\nOpen up your terminal, and use \nVapor Toolbox's \nnew\n command.\n\n\nvapor new Hello\n\n\n\n\n\n\n\nWarning\n\n\nMake sure to add \n--branch=beta\n while using Vapor 3 pre-release.\n\n\n\n\nOnce that finishes, change into the newly created directory.\n\n\ncd\n Hello\n\n\n\n\n\nGenerate Xcode Project\n\n\nLet's now use the \nVapor Toolbox's \nxcode\n command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.\n\n\nvapor xcode\n\n\n\n\n\nThe toolbox will ask you if you'd like to open Xcode automatically, select \nyes\n.\n\n\nBuild \n Run\n\n\nYou should now have Xcode open and running. Select the \nrun scheme\n from the scheme menu,\nthen click the play button.\n\n\nYou should see the terminal pop up at the bottom of the screen.\n\n\nServer starting on localhost:8080\n\n\n\n\n\nVisit Localhost\n\n\nOpen your web browser, and visit \nlocalhost:8080/hello \n\n\nYou should see the following page.\n\n\nHello, world!\n\n\n\n\n\nCongratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#hello-world", 
            "text": "Now that you've installed Vapor, let's create your first Vapor app!\nThis guide will take you step by step through creating a new project, building, and running it.", 
            "title": "Hello, world"
        }, 
        {
            "location": "/getting-started/hello-world/#new-project", 
            "text": "The first step is to create a new Vapor project on your computer.\nFor this guide, we will call the project  Hello .  Open up your terminal, and use  Vapor Toolbox's  new  command.  vapor new Hello   Warning  Make sure to add  --branch=beta  while using Vapor 3 pre-release.   Once that finishes, change into the newly created directory.  cd  Hello", 
            "title": "New Project"
        }, 
        {
            "location": "/getting-started/hello-world/#generate-xcode-project", 
            "text": "Let's now use the  Vapor Toolbox's  xcode  command to generate an Xcode project.\nThis will allow us to build and run our app from inside of Xcode, just like an iOS app.  vapor xcode  The toolbox will ask you if you'd like to open Xcode automatically, select  yes .", 
            "title": "Generate Xcode Project"
        }, 
        {
            "location": "/getting-started/hello-world/#build-run", 
            "text": "You should now have Xcode open and running. Select the  run scheme  from the scheme menu,\nthen click the play button.  You should see the terminal pop up at the bottom of the screen.  Server starting on localhost:8080", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/hello-world/#visit-localhost", 
            "text": "Open your web browser, and visit  localhost:8080/hello   You should see the following page.  Hello, world!  Congratulations on creating, building, and running your first Vapor app! \ud83c\udf89", 
            "title": "Visit Localhost"
        }, 
        {
            "location": "/getting-started/toolbox/", 
            "text": "Install Toolbox\n\n\nVapor's command line interface provides shortcuts and assistance for common tasks.\n\n\n\n\nHelp prints useful information about available commands and flags.\n\n\nvapor --help\n\n\n\n\n\nYou can also run the \n--help\n option on any Toolbox command.\n\n\nvapor new --help\n\n\n\n\n\nThe \n--help\n flag should be your goto for learning about the toolbox as it is the most up-to-date.\n\n\nNew\n\n\nThe Toolbox's most important feature is helping you create a new project.\n\n\nvapor new \nname\n\n\n\n\n\n\nJust pass the name of your project as the first argument to the \nnew\n command.\n\n\n\n\nNote\n\n\nProject names should be \nPascalCase \n, like \nHelloWorld\n or \nMyProject\n.\n\n\n\n\nTemplates\n\n\nBy default, Vapor will create your new project from the API template. You can choose\na different template by passing the \n--template\n flag.\n\n\n\n\n\n\n\n\nName\n\n\nFlag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\n--template=api\n\n\nJSON API with Fluent database.\n\n\n\n\n\n\nWeb\n\n\n--template=web\n\n\nHTML website with Leaf templates.\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nThere are lots of unofficial Vapor templates on GitHub under the \nvapor\n + \ntemplate\n topcs \n.\nYou can use these by passing the full GitHub URL to the \n--template\n option.\n\n\n\n\nBuild \n Run\n\n\nYou can use the toolbox to build and run your Vapor app.\n\n\nvapor build\nvapor run\n\n\n\n\n\n\n\nTip\n\n\nWe recommend building and running through \nXcode\n if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use \nvapor xcode\n to generate an Xcode project.\n\n\n\n\nUpdating\n\n\nThe toolbox should be updated by the package manager it was installed with.\n\n\nHomebrew\n\n\nbrew upgrade vapor\n\n\n\n\n\nAPT\n\n\nsudo apt-get update\nsudo apt-get install vapor", 
            "title": "Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#install-toolbox", 
            "text": "Vapor's command line interface provides shortcuts and assistance for common tasks.   Help prints useful information about available commands and flags.  vapor --help  You can also run the  --help  option on any Toolbox command.  vapor new --help  The  --help  flag should be your goto for learning about the toolbox as it is the most up-to-date.", 
            "title": "Install Toolbox"
        }, 
        {
            "location": "/getting-started/toolbox/#new", 
            "text": "The Toolbox's most important feature is helping you create a new project.  vapor new  name   Just pass the name of your project as the first argument to the  new  command.   Note  Project names should be  PascalCase  , like  HelloWorld  or  MyProject .", 
            "title": "New"
        }, 
        {
            "location": "/getting-started/toolbox/#templates", 
            "text": "By default, Vapor will create your new project from the API template. You can choose\na different template by passing the  --template  flag.     Name  Flag  Description      API  --template=api  JSON API with Fluent database.    Web  --template=web  HTML website with Leaf templates.      Info  There are lots of unofficial Vapor templates on GitHub under the  vapor  +  template  topcs  .\nYou can use these by passing the full GitHub URL to the  --template  option.", 
            "title": "Templates"
        }, 
        {
            "location": "/getting-started/toolbox/#build-run", 
            "text": "You can use the toolbox to build and run your Vapor app.  vapor build\nvapor run   Tip  We recommend building and running through  Xcode  if you have a Mac. \nIt's a bit faster and you can set breakpoints! \nJust use  vapor xcode  to generate an Xcode project.", 
            "title": "Build &amp; Run"
        }, 
        {
            "location": "/getting-started/toolbox/#updating", 
            "text": "The toolbox should be updated by the package manager it was installed with.", 
            "title": "Updating"
        }, 
        {
            "location": "/getting-started/toolbox/#homebrew", 
            "text": "brew upgrade vapor", 
            "title": "Homebrew"
        }, 
        {
            "location": "/getting-started/toolbox/#apt", 
            "text": "sudo apt-get update\nsudo apt-get install vapor", 
            "title": "APT"
        }, 
        {
            "location": "/getting-started/spm/", 
            "text": "Managing your project\n\n\nThe Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the \nVapor Toolbox\n will \ninteract with SPM on your behalf. However, it's important to understand the basics.\n\n\n\n\nTip\n\n\nLearn more about SPM on \nSwift.org \n \n\n\n\n\nPackage Manifest\n\n\nThe first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named \nPackage.swift\n.\n\n\nDependencies\n\n\nDependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n\n        \n// \ud83d\udca7 A server-side Swift web framework. \n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/vapor.git\n,\n \nfrom\n:\n \n3.0.0\n),\n\n    \n],\n\n    \ntargets\n:\n \n[\n \n...\n \n]\n\n\n)\n\n\n\n\n\n\nIn the above example, you can see \nvapor/vapor \n version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which \ntargets\n depend on\nthe newly available modules.\n\n\n\n\nWarning\n\n\nAnytime you modify the package manifest, call \nvapor update\n to effect the changes.\n\n\n\n\nTargets\n\n\nTargets are all of the modules, executables, and tests that your package contains. \n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nVaporApp\n,\n\n    \ndependencies\n:\n \n[\n \n...\n \n],\n\n    \ntargets\n:\n \n[\n\n        \n.\ntarget\n(\nname\n:\n \nApp\n,\n \ndependencies\n:\n \n[\nVapor\n]),\n\n        \n.\ntarget\n(\nname\n:\n \nRun\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n        \n.\ntestTarget\n(\nname\n:\n \nAppTests\n,\n \ndependencies\n:\n \n[\nApp\n]),\n\n    \n]\n\n\n)\n\n\n\n\n\n\nMost Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to \nimport\n them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe \nmain dependencies\n array.\n\n\n\n\nTip\n\n\nExecutable targets (targets that contain a \nmain.swift\n file) cannot be imported by other modules.\nThis is why Vapor has both an \nApp\n and a \nRun\n target.\nAny code you include in \nApp\n can be tested in the \nAppTests\n.\n\n\n\n\nFolder Structure\n\n\nBelow is the typical folder structure for an SPM package.\n\n\n.\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nEach \n.target\n corresponds to a folder in the \nSources\n folder. \nEach \n.testTarget\n corresponds to a folder in the \nTests\n folder.\n\n\nTroubleshooting\n\n\nIf you are experiencing problems with SPM, sometimes cleaning your project can help.\n\n\nvapor clean", 
            "title": "SPM"
        }, 
        {
            "location": "/getting-started/spm/#managing-your-project", 
            "text": "The Swift Package Manager (SPM for short) is used for building your project's source code and dependencies. \nIt's a similar idea to Cocoapods, Ruby gems, and NPM. Most of the time the  Vapor Toolbox  will \ninteract with SPM on your behalf. However, it's important to understand the basics.   Tip  Learn more about SPM on  Swift.org", 
            "title": "Managing your project"
        }, 
        {
            "location": "/getting-started/spm/#package-manifest", 
            "text": "The first place SPM looks in your project is the package manfiest. This should always be located in the root\ndirectory of your project and named  Package.swift .", 
            "title": "Package Manifest"
        }, 
        {
            "location": "/getting-started/spm/#dependencies", 
            "text": "Dependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package,\nbut you can add as many other dependencies as you want.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [ \n         // \ud83d\udca7 A server-side Swift web framework.  \n         . package ( url :   https://github.com/vapor/vapor.git ,   from :   3.0.0 ), \n     ], \n     targets :   [   ...   ]  )   In the above example, you can see  vapor/vapor   version 3.0\nor later is a dependency of this package.\nWhen you add a dependency to your package, you must next signal which  targets  depend on\nthe newly available modules.   Warning  Anytime you modify the package manifest, call  vapor update  to effect the changes.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/getting-started/spm/#targets", 
            "text": "Targets are all of the modules, executables, and tests that your package contains.   // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   VaporApp , \n     dependencies :   [   ...   ], \n     targets :   [ \n         . target ( name :   App ,   dependencies :   [ Vapor ]), \n         . target ( name :   Run ,   dependencies :   [ App ]), \n         . testTarget ( name :   AppTests ,   dependencies :   [ App ]), \n     ]  )   Most Vapor apps will have three targets, although you can add as many as you like to organize your code.\nEach target declares which modules it depends on. You must add module names here in order to  import  them in your code.\nA target can depend on other targets in your project or any modules exposed by packages you've added to\nthe  main dependencies  array.   Tip  Executable targets (targets that contain a  main.swift  file) cannot be imported by other modules.\nThis is why Vapor has both an  App  and a  Run  target.\nAny code you include in  App  can be tested in the  AppTests .", 
            "title": "Targets"
        }, 
        {
            "location": "/getting-started/spm/#folder-structure", 
            "text": "Below is the typical folder structure for an SPM package.  .\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u2514\u2500\u2500 (Source code)\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Each  .target  corresponds to a folder in the  Sources  folder. \nEach  .testTarget  corresponds to a folder in the  Tests  folder.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/spm/#troubleshooting", 
            "text": "If you are experiencing problems with SPM, sometimes cleaning your project can help.  vapor clean", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/getting-started/xcode/", 
            "text": "Xcode\n\n\nIf you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.\n\n\n\n\nXcode is a great way to develop Vapor apps, but you can use any text editor you like.\n\n\nGenerate Project\n\n\nTo use Xcode, you just need to generate an Xcode project using \nVapor Toolbox\n.\n\n\nvapor xcode\n\n\n\n\n\n\n\nTip\n\n\nDon't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.\n\n\n\n\nRun\n\n\nTo build and run your Vapor app, first make sure you have the \nRun\n scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.\n\n\n\n\nOnce that's selected, just click the play button or press \nCommand + R\n on your keyboard.\n\n\nTest\n\n\nTo run your unit tests, select the scheme ending in \n-Package\n and press \nCommand + U\n.\n\n\n\n\nWarning\n\n\nThere may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#xcode", 
            "text": "If you're on a Mac, you can develop your Vapor project using Xcode. \nYou can build, run, and stop your server from within Xcode, as well as use breakpoints and instruments to debug your code.   Xcode is a great way to develop Vapor apps, but you can use any text editor you like.", 
            "title": "Xcode"
        }, 
        {
            "location": "/getting-started/xcode/#generate-project", 
            "text": "To use Xcode, you just need to generate an Xcode project using  Vapor Toolbox .  vapor xcode   Tip  Don't worry about comitting the generated Xcode Project to git, just generate a new\none whenever you need it.", 
            "title": "Generate Project"
        }, 
        {
            "location": "/getting-started/xcode/#run", 
            "text": "To build and run your Vapor app, first make sure you have the  Run  scheme selected from the schemes menu.\nAlso make sure to select \"My Mac\" as the device.   Once that's selected, just click the play button or press  Command + R  on your keyboard.", 
            "title": "Run"
        }, 
        {
            "location": "/getting-started/xcode/#test", 
            "text": "To run your unit tests, select the scheme ending in  -Package  and press  Command + U .   Warning  There may be a few extraneous schemes in the dropdown menu. Ignore them!", 
            "title": "Test"
        }, 
        {
            "location": "/getting-started/structure/", 
            "text": "Structure\n\n\nThis section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.\n\n\nFolder Structure\n\n\nVapor's folder structure builds on top of \nSPM's folder structure\n.\n\n\n.\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift\n\n\n\n\n\nLet's take a look at what each of these folders and files does.\n\n\nPublic\n\n\nThis folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.\n\n\nWhenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.\n\n\nFor example, a request to \nlocalhost:8080/favicon.ico\n will check to see\nif \nPublic/favicon.ico\n exists. If it does, Vapor will return it.\n\n\nSources\n\n\nThis folder contains all of the Swift source files for your project. \nThe top level folders (\nApp\n and \nRun\n) reflect your package's modules, \nas declared in the \npackage manifest\n.\n\n\nApp\n\n\nThis is the most important folder in your application, it's where all of\nthe application logic goes!\n\n\nControllers\n\n\nControllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.\n\n\n\n\nTip\n\n\nVapor supports, but does not enforce the MVC pattern\n\n\n\n\nModels\n\n\nThe \nModels\n folder is a great place to store your \nContent\n structs or\nFluent \nModel\ns.\n\n\nboot.swift\n\n\nThis file contains a function that will be called \nafter\n your application has booted,\nbut \nbefore\n it has started running. This is a great place do things that should happen \nevery time your application starts.\n\n\nYou have access to the \nApplication\n here which you can use to create\nany \nservices\n you might need.\n\n\nconfigure.swift\n\n\nThis file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register \n\nservices\n to your application.\n\n\nroutes.swift\n\n\nThis file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.\n\n\nYou'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.\n\n\nYou can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection. \n\n\nTests\n\n\nEach non-executable module in your \nSources\n folder should have a corresponding \n...Tests\n folder.\n\n\nAppTests\n\n\nThis folder contains the unit tests for code in your \nApp\n module. \nLearn more about testing in \nTesting \n Getting Started\n.\n\n\nPackage.swift\n\n\nFinally is SPM's \npackage manifest\n.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#structure", 
            "text": "This section explains the structure of a typical Vapor application to help get\nyou familiar with where things go.", 
            "title": "Structure"
        }, 
        {
            "location": "/getting-started/structure/#folder-structure", 
            "text": "Vapor's folder structure builds on top of  SPM's folder structure .  .\n\u251c\u2500\u2500 Public\n\u251c\u2500\u2500 Sources\n\u2502   \u251c\u2500\u2500 App\n\u2502   \u2502   \u251c\u2500\u2500 Controllers\n\u2502   \u2502   \u251c\u2500\u2500 Models\n\u2502   \u2502   \u251c\u2500\u2500 boot.swift\n\u2502   \u2502   \u251c\u2500\u2500 configure.swift\n\u2502   \u2502   \u2514\u2500\u2500 routes.swift\n\u2502   \u2514\u2500\u2500 Run\n\u2502       \u2514\u2500\u2500 main.swift\n\u251c\u2500\u2500 Tests\n\u2502   \u2514\u2500\u2500 AppTests\n\u2514\u2500\u2500 Package.swift  Let's take a look at what each of these folders and files does.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/getting-started/structure/#public", 
            "text": "This folder contains any public files that will be served by your app.\nThis is usually images, style sheets, and browser scripts.  Whenever Vapor responds to a request, it will first check if the requested\nitem is in this folder. If it is, it skips your application logic and returns\nthe file immediately.  For example, a request to  localhost:8080/favicon.ico  will check to see\nif  Public/favicon.ico  exists. If it does, Vapor will return it.", 
            "title": "Public"
        }, 
        {
            "location": "/getting-started/structure/#sources", 
            "text": "This folder contains all of the Swift source files for your project. \nThe top level folders ( App  and  Run ) reflect your package's modules, \nas declared in the  package manifest .", 
            "title": "Sources"
        }, 
        {
            "location": "/getting-started/structure/#app", 
            "text": "This is the most important folder in your application, it's where all of\nthe application logic goes!", 
            "title": "App"
        }, 
        {
            "location": "/getting-started/structure/#controllers", 
            "text": "Controllers are great way of grouping together application logic. Most controllers\nhave many functions that accept a request and return some sort of response.   Tip  Vapor supports, but does not enforce the MVC pattern", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/structure/#models", 
            "text": "The  Models  folder is a great place to store your  Content  structs or\nFluent  Model s.", 
            "title": "Models"
        }, 
        {
            "location": "/getting-started/structure/#bootswift", 
            "text": "This file contains a function that will be called  after  your application has booted,\nbut  before  it has started running. This is a great place do things that should happen \nevery time your application starts.  You have access to the  Application  here which you can use to create\nany  services  you might need.", 
            "title": "boot.swift"
        }, 
        {
            "location": "/getting-started/structure/#configureswift", 
            "text": "This file contains a function that receives the config, environment, and services for your\napplication as input. This is a great place to make changes to your config or register  services  to your application.", 
            "title": "configure.swift"
        }, 
        {
            "location": "/getting-started/structure/#routesswift", 
            "text": "This file contains the main route collection for your app. This is where you should assign routes\nfor your controller methods.  You'll notice there's one example route in there that returns the \"hello, world\" response we saw earlier.  You can create as many route collections as you want to further organize your code. Just make sure\nto register them in this main route collection.", 
            "title": "routes.swift"
        }, 
        {
            "location": "/getting-started/structure/#tests", 
            "text": "Each non-executable module in your  Sources  folder should have a corresponding  ...Tests  folder.", 
            "title": "Tests"
        }, 
        {
            "location": "/getting-started/structure/#apptests", 
            "text": "This folder contains the unit tests for code in your  App  module. \nLearn more about testing in  Testing   Getting Started .", 
            "title": "AppTests"
        }, 
        {
            "location": "/getting-started/structure/#packageswift", 
            "text": "Finally is SPM's  package manifest .", 
            "title": "Package.swift"
        }, 
        {
            "location": "/getting-started/application/", 
            "text": "Application\n\n\nEvery Vapor project has an \nApplication\n. You use the application to create any services\nyou might need while developing.\n\n\nThe best place to access the application is in your project's \nboot.swift\n file.\n\n\nimport\n \nVapor\n\n\n\npublic\n \nfunc\n \nboot\n(\n_\n \napp\n:\n \nApplication\n)\n \nthrows\n \n{\n\n    \n// your code here\n\n\n}\n\n\n\n\n\n\nYou can also access the application from your \nroutes.swift\n file. It's stored\nas a property there.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nUnlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.\n\n\n\n\nInfo\n\n\nAvoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.\n\n\n\n\nServices\n\n\nThe application's main function is to make services. For example, you might need a \nBCryptHasher\n to hash\nsome passwords before storing them in a database. You can use the application to create one.\n\n\nimport\n \nBCrypt\n\n\n\nlet\n \nbcryptHasher\n \n=\n \ntry\n \napp\n.\nmake\n(\nBCryptHasher\n.\nself\n)\n\n\n\n\n\n\nOr you might use the application to create an HTTP client.\n\n\nlet\n \nclient\n \n=\n \ntry\n \napp\n.\nmake\n(\nClient\n.\nself\n)\n\n\nlet\n \nres\n \n=\n \nclient\n.\nget\n(\nhttp://vapor.codes\n)\n\n\n\n\n\n\nLearn more about services in \nServices \n Getting Started\n.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#application", 
            "text": "Every Vapor project has an  Application . You use the application to create any services\nyou might need while developing.  The best place to access the application is in your project's  boot.swift  file.  import   Vapor  public   func   boot ( _   app :   Application )   throws   { \n     // your code here  }   You can also access the application from your  routes.swift  file. It's stored\nas a property there.  import   Vapor  final   class   Routes :   RouteCollection   { \n     ...  }   Unlike some other web frameworks, Vapor doesn't support statically accessing the application.\nIf you need to access it from another class or struct, you should pass through a method or initializer.   Info  Avoiding static access to variables helps make Vapor performant by preventing\nthe need for thread-safe locks or semaphores.", 
            "title": "Application"
        }, 
        {
            "location": "/getting-started/application/#services", 
            "text": "The application's main function is to make services. For example, you might need a  BCryptHasher  to hash\nsome passwords before storing them in a database. You can use the application to create one.  import   BCrypt  let   bcryptHasher   =   try   app . make ( BCryptHasher . self )   Or you might use the application to create an HTTP client.  let   client   =   try   app . make ( Client . self )  let   res   =   client . get ( http://vapor.codes )   Learn more about services in  Services   Getting Started .", 
            "title": "Services"
        }, 
        {
            "location": "/getting-started/controllers/", 
            "text": "Controllers\n\n\nControllers are a great way to organize your code. They are collections of methods that accept\na request and return a response.\n\n\nA good place to put your controllers is in the \nControllers\n folder.\n\n\nMethods\n\n\nLet's take a look at an example controller.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nfunc\n \ngreet\n(\n_\n \nreq\n:\n \nRequest\n)\n \nthrows\n \n-\n \nString\n \n{\n\n        \nreturn\n \nHello!\n\n    \n}\n\n\n}\n\n\n\n\n\n\nController methods should always accept a \nRequest\n and return something \nResponseRepresentable\n.\nThis also includes \nfutures\n whose expectations are \nResponseRepresentable\n (i.e, \nFuture\nString\n).\n\n\nTo use this controller, we can simply initialize it, then pass the method to a router.\n\n\nlet\n \nhelloController\n \n=\n \nHelloController\n()\n\n\nrouter\n.\nget\n(\ngreet\n,\n \nuse\n:\n \nhelloController\n.\ngreet\n)\n\n\n\n\n\n\nUse Services\n\n\nYou will probably want to access your \napplication's services\n from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.\n\n\nfinal\n \nclass\n \nHelloController\n \n{\n\n    \nlet\n \nhasher\n:\n \nBCryptHasher\n\n\n    \ninit\n(\nhasher\n:\n \nBCryptHasher\n)\n \n{\n\n        \nself\n.\nhasher\n \n=\n \nhasher\n\n    \n}\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nNext, use the \napplication\n to create these services when you initialize your controller.\n\n\nlet\n \nhelloController\n \n=\n \ntry\n \nHelloController\n(\n\n    \nhasher\n:\n \napp\n.\nmake\n()\n\n\n)", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#controllers", 
            "text": "Controllers are a great way to organize your code. They are collections of methods that accept\na request and return a response.  A good place to put your controllers is in the  Controllers  folder.", 
            "title": "Controllers"
        }, 
        {
            "location": "/getting-started/controllers/#methods", 
            "text": "Let's take a look at an example controller.  import   Vapor  final   class   HelloController   { \n     func   greet ( _   req :   Request )   throws   -   String   { \n         return   Hello! \n     }  }   Controller methods should always accept a  Request  and return something  ResponseRepresentable .\nThis also includes  futures  whose expectations are  ResponseRepresentable  (i.e,  Future String ).  To use this controller, we can simply initialize it, then pass the method to a router.  let   helloController   =   HelloController ()  router . get ( greet ,   use :   helloController . greet )", 
            "title": "Methods"
        }, 
        {
            "location": "/getting-started/controllers/#use-services", 
            "text": "You will probably want to access your  application's services  from within your controllers.\nLuckily this is easy to do. First, declare what services your controller needs in its init method. Then store them\nas properties on the controller.  final   class   HelloController   { \n     let   hasher :   BCryptHasher \n\n     init ( hasher :   BCryptHasher )   { \n         self . hasher   =   hasher \n     } \n\n     ...  }   Next, use the  application  to create these services when you initialize your controller.  let   helloController   =   try   HelloController ( \n     hasher :   app . make ()  )", 
            "title": "Use Services"
        }, 
        {
            "location": "/getting-started/routing/", 
            "text": "Routing\n\n\nRouting is the process of finding the appropriate response to an incoming request.\n\n\nMaking a Router\n\n\nIn Vapor the default Router is the \nEngineRouter\n. You can implement custom routers by implementing one conformant to the \nRouter\n protocol.\n\n\nlet\n \nrouter\n \n=\n \ntry\n \nEngineRouter\n.\ndefault\n()\n\n\n\n\n\n\nThere are two APIs available, one is supplied by the \nRouting\n library and a set of helpers is available in Vapor itself.\n\n\nWe recommend using the helpers and will continue to describe those here.\n\n\nRegistering a route\n\n\nImagine you want to return a list of users when someone visits \nGET /users\n.\nLeaving authorization on the side, that would look something like this.\n\n\nrouter\n.\nget\n(\nusers\n)\n \n{\n \nreq\n \nin\n\n    \nreturn\n \n// fetch the users\n\n\n}\n\n\n\n\n\n\nIn Vapor, routing is usually done using the \n.get\n, \n.put\n, \n.post\n, \n.patch\n and \n.delete\n shorthands.\nYou can supply the path as \n/\n or comma-separated strings. We recommend comma separated, as it's more readable.\n\n\nrouter\n.\nget\n(\npath\n,\n \nto\n,\n \nsomething\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nRoutes\n\n\nThe best place to add routes is in the \nroutes.swift\n file.\nYou will find a router there that is ready to use.\n\n\nimport\n \nVapor\n\n\n\nfinal\n \nclass\n \nRoutes\n:\n \nRouteCollection\n \n{\n\n    \n...\n\n\n    \nfunc\n \nboot\n(\nrouter\n:\n \nRouter\n)\n \nthrows\n \n{\n\n        \nrouter\n.\nget\n(\nhello\n)\n \n{\n \nreq\n \nin\n\n            \nreturn\n \nFuture\n(\nHello, world!\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou \nmust\n return a Future containing a \nRespondeEncodable\n here.\nThe most common \nResponseEncodable\n types are \nContent\n, \nResponse\n amd \nView\n.\n\n\nParameters\n\n\nSometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e., \nGET /users/:id\n\n\nrouter\n.\nget\n(\nusers\n,\n \nInt\n.\nself\n)\n \n{\n \nreq\n \nin\n\n    \nlet\n \nid\n \n=\n \ntry\n \nreq\n.\nparameters\n.\nnext\n(\nInt\n.\nself\n)\n\n    \nreturn\n \n// fetch the user with id\n\n\n}\n\n\n\n\n\n\nInstead of passing a string, pass the \ntype\n of parameter you expect. In this case, our \nUser\n has an \nInt\n ID.\n\n\n\n\nTip\n\n\nYou can define your own \ncustom parameter types\n as well.\n\n\n\n\nAfter registering your routes\n\n\nAfter registering your routes you must register the Router as a \nService", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#routing", 
            "text": "Routing is the process of finding the appropriate response to an incoming request.", 
            "title": "Routing"
        }, 
        {
            "location": "/getting-started/routing/#making-a-router", 
            "text": "In Vapor the default Router is the  EngineRouter . You can implement custom routers by implementing one conformant to the  Router  protocol.  let   router   =   try   EngineRouter . default ()   There are two APIs available, one is supplied by the  Routing  library and a set of helpers is available in Vapor itself.  We recommend using the helpers and will continue to describe those here.", 
            "title": "Making a Router"
        }, 
        {
            "location": "/getting-started/routing/#registering-a-route", 
            "text": "Imagine you want to return a list of users when someone visits  GET /users .\nLeaving authorization on the side, that would look something like this.  router . get ( users )   {   req   in \n     return   // fetch the users  }   In Vapor, routing is usually done using the  .get ,  .put ,  .post ,  .patch  and  .delete  shorthands.\nYou can supply the path as  /  or comma-separated strings. We recommend comma separated, as it's more readable.  router . get ( path ,   to ,   something )   {   ...   }", 
            "title": "Registering a route"
        }, 
        {
            "location": "/getting-started/routing/#routes", 
            "text": "The best place to add routes is in the  routes.swift  file.\nYou will find a router there that is ready to use.  import   Vapor  final   class   Routes :   RouteCollection   { \n     ... \n\n     func   boot ( router :   Router )   throws   { \n         router . get ( hello )   {   req   in \n             return   Future ( Hello, world! ) \n         } \n     }  }   You  must  return a Future containing a  RespondeEncodable  here.\nThe most common  ResponseEncodable  types are  Content ,  Response  amd  View .", 
            "title": "Routes"
        }, 
        {
            "location": "/getting-started/routing/#parameters", 
            "text": "Sometimes you may want one of the components of your route path to be dynamic. This is often used when\nyou want to get an item with a supplied identifier, i.e.,  GET /users/:id  router . get ( users ,   Int . self )   {   req   in \n     let   id   =   try   req . parameters . next ( Int . self ) \n     return   // fetch the user with id  }   Instead of passing a string, pass the  type  of parameter you expect. In this case, our  User  has an  Int  ID.   Tip  You can define your own  custom parameter types  as well.", 
            "title": "Parameters"
        }, 
        {
            "location": "/getting-started/routing/#after-registering-your-routes", 
            "text": "After registering your routes you must register the Router as a  Service", 
            "title": "After registering your routes"
        }, 
        {
            "location": "/getting-started/content/", 
            "text": "Content\n\n\nIn Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a \nCodable\n class or struct.\n\n\nFor this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.\n\n\nRequest\n\n\nLet's take a look at how you would parse the following HTTP request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nemail\n:\n \nuser@vapor.codes\n,\n\n    \npassword\n:\n \ndon\nt look!\n\n\n}\n\n\n\n\n\n\nDecode Request\n\n\nFirst, create a struct or class that represents the data you expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nLoginRequest\n:\n \nContent\n \n{\n\n    \nvar\n \nemail\n:\n \nString\n\n    \nvar\n \npassword\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen simply conform this struct or class to \nContent\n.\nNow we are ready to decode that HTTP request.\n\n\nrouter\n.\npost\n(\nlogin\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nloginRequest\n \n=\n \ntry\n \nreq\n.\ncontent\n.\ndecode\n(\nLoginRequest\n.\nself\n)\n\n\n    \nprint\n(\nloginRequest\n.\nemail\n)\n \n// user@vapor.codes\n\n    \nprint\n(\nloginRequest\n.\npassword\n)\n \n// don\nt look!\n\n\n    \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n\n}\n\n\n\n\n\n\nIt's that simple!\n\n\nOther Request Types\n\n\nSince the request in the previous example declared JSON as it's content type,\nVapor knows to use a JSON decoder automatically.\nThis same method would work just as well for the following request.\n\n\nPOST\n \n/login\n \nHTTP\n/\n1.1\n\n\nContent-Type\n:\n \napplication/x-www-form-urlencoded\n\n\nemail=user@vapor.codes\ndon\nt+look!\n\n\n\n\n\n\n\nTip\n\n\nYou can configure which encoders/decoders Vapor uses. Read on to learn more.\n\n\n\n\nResponse\n\n\nLet's take a look at how you would create the following HTTP response.\n\n\nHTTP\n/\n1.1\n \n200\n \nOK\n\n\nContent-Type\n:\n \napplication/json\n\n\n\n{\n\n    \nname\n:\n \nVapor User\n,\n\n    \nemail\n:\n \nuser@vapor.codes\n\n\n}\n\n\n\n\n\n\nEncode Response\n\n\nJust like decoding, first create a struct or class that represents the data your expect.\n\n\nimport\n \nFoundation\n\n\nimport\n \nVapor\n\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \nvar\n \nname\n:\n \nString\n\n    \nvar\n \nemail\n:\n \nString\n\n\n}\n\n\n\n\n\n\nThen just conform this struct or class to \nContent\n.\nNow we are ready to encode that HTTP response.\n\n\nrouter\n.\nget\n(\nuser\n)\n \n{\n \nreq\n \n-\n \nResponse\n \nin\n\n    \nlet\n \nuser\n \n=\n \nUser\n(\n\n        \nname\n:\n \nVapor User\n,\n\n        \nemail\n:\n \nuser@vapor.codes\n\n    \n)\n\n\n    \nlet\n \nres\n \n=\n \nResponse\n(\nstatus\n:\n \n.\nok\n)\n\n    \ntry\n \nres\n.\ncontent\n.\nencode\n(\nuser\n,\n \nas\n:\n \n.\njson\n)\n\n    \nreturn\n \nres\n\n\n}\n\n\n\n\n\n\nOther Response Types\n\n\nContent will automatically encode as JSON by default. You can always override which content type is used\nusing the \nas:\n parameter.\n\n\ntry\n \nres\n.\ncontent\n.\nencode\n(\nuser\n,\n \nas\n:\n \n.\nformURLEncoded\n)\n\n\n\n\n\n\nYou can also change the default media type for any class or struct.\n\n\nstruct\n \nUser\n:\n \nContent\n \n{\n\n    \n/// See Content.defaultMediaType\n\n    \nstatic\n \nlet\n \ndefaultMediaType\n:\n \nMediaType\n \n=\n \n.\nformURLEncoded\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\nConfiguring Content\n\n\nComing soon.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#content", 
            "text": "In Vapor 3, all content types (JSON, protobuf, FormURLEncoded, Multipart, etc) are treated the same.\nAll you need to parse and serialize content is a  Codable  class or struct.  For this introduction, we will use JSON as an example. But keep in mind the API is the same for any supported content type.", 
            "title": "Content"
        }, 
        {
            "location": "/getting-started/content/#request", 
            "text": "Let's take a look at how you would parse the following HTTP request.  POST   /login   HTTP / 1.1  Content-Type :   application/json  { \n     email :   user@vapor.codes , \n     password :   don t look!  }", 
            "title": "Request"
        }, 
        {
            "location": "/getting-started/content/#decode-request", 
            "text": "First, create a struct or class that represents the data you expect.  import   Foundation  import   Vapor  struct   LoginRequest :   Content   { \n     var   email :   String \n     var   password :   String  }   Then simply conform this struct or class to  Content .\nNow we are ready to decode that HTTP request.  router . post ( login )   {   req   -   Response   in \n     let   loginRequest   =   try   req . content . decode ( LoginRequest . self ) \n\n     print ( loginRequest . email )   // user@vapor.codes \n     print ( loginRequest . password )   // don t look! \n\n     return   Response ( status :   . ok )  }   It's that simple!", 
            "title": "Decode Request"
        }, 
        {
            "location": "/getting-started/content/#other-request-types", 
            "text": "Since the request in the previous example declared JSON as it's content type,\nVapor knows to use a JSON decoder automatically.\nThis same method would work just as well for the following request.  POST   /login   HTTP / 1.1  Content-Type :   application/x-www-form-urlencoded \n\nemail=user@vapor.codes don t+look!   Tip  You can configure which encoders/decoders Vapor uses. Read on to learn more.", 
            "title": "Other Request Types"
        }, 
        {
            "location": "/getting-started/content/#response", 
            "text": "Let's take a look at how you would create the following HTTP response.  HTTP / 1.1   200   OK  Content-Type :   application/json  { \n     name :   Vapor User , \n     email :   user@vapor.codes  }", 
            "title": "Response"
        }, 
        {
            "location": "/getting-started/content/#encode-response", 
            "text": "Just like decoding, first create a struct or class that represents the data your expect.  import   Foundation  import   Vapor  struct   User :   Content   { \n     var   name :   String \n     var   email :   String  }   Then just conform this struct or class to  Content .\nNow we are ready to encode that HTTP response.  router . get ( user )   {   req   -   Response   in \n     let   user   =   User ( \n         name :   Vapor User , \n         email :   user@vapor.codes \n     ) \n\n     let   res   =   Response ( status :   . ok ) \n     try   res . content . encode ( user ,   as :   . json ) \n     return   res  }", 
            "title": "Encode Response"
        }, 
        {
            "location": "/getting-started/content/#other-response-types", 
            "text": "Content will automatically encode as JSON by default. You can always override which content type is used\nusing the  as:  parameter.  try   res . content . encode ( user ,   as :   . formURLEncoded )   You can also change the default media type for any class or struct.  struct   User :   Content   { \n     /// See Content.defaultMediaType \n     static   let   defaultMediaType :   MediaType   =   . formURLEncoded \n\n     ...  }", 
            "title": "Other Response Types"
        }, 
        {
            "location": "/getting-started/content/#configuring-content", 
            "text": "Coming soon.", 
            "title": "Configuring Content"
        }, 
        {
            "location": "/getting-started/futures/", 
            "text": "Futures\n\n\nYou may have noticed some APIs in Vapor expect or return a \nFuture\nT\n type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.\n\n\nPromises and Futures are two strongly related types. Every promise has a future.\nA promise is a write-only entity that has the ability to complete (or fail) it's Future counterpart.\n\n\nFutures are a read-only entity that can have a successful or error case. Successful cases are called the \"Expectation\".\n\n\nFutures can be used to register callbacks to, which will always executed in the order of registration. Promises can only be completed once. If a promise is completed more than once the input will be \nignored\n.\n\n\nBasics\n\n\nCreating a promise is when the result is returned in the future at an unknown time.\nFor the sake of demonstration, however, the promise will be completed at a predefined point in time and execution.\n\n\nWithin the \n.do\n block you may not throw an error or return a result.\n\n\nlet\n \npromise\n \n=\n \nPromise\nString\n()\n\n\nlet\n \nfuture\n \n=\n \npromise\n.\nfuture\n \n// Future\nString\n\n\n\nfuture\n.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\nHello\n)\n\n\n\n\n\n\nThe above code prints \"Hello\" in the console.\n\n\nErrors\n\n\nWhen running the above code, you may have noticed a warning pop up. This is because the \n.do\n block only handles successful completions. If we were to replace the completion with the following code the \n.do\n block would never get run:\n\n\nstruct\n \nMyError\n:\n \nError\n \n{}\n\n\n\npromise\n.\nfail\n(\nMyError\n())\n\n\n\n\n\n\nInstead, a \n.catch\n block will be triggered.\n\n\nfuture\n.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\n\n\n\nIn this scenario the test \"Error 'MyError' occurred\" will appear.\n\n\nWithin the \n.catch\n block you may not throw an error or return a result.\n\n\nBasic Transformations\n\n\nTransformations are one of the more critical parts of Vapor 3's future system. They assist in reducing the complexity of futures and keep code isolated and readable. You can use the \n.map\n function to transform the future expectation to another future of the same or a different type. You need to explicitly state which type will be returned in the mapping closure.\n\n\nThe mapping closure(s) will \nonly\n be executed if an expectation has been received in the previous step. If at any point a transformation function throws an error, execution stops there and the \n.catch\n block will be executed.\n\n\nIf the promise that was mapped failed to begin with, the \n.catch\n block will also be executed \nwithout\n triggering \nany\n mapping closures.\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nfuture\n.\ndo\n \n{\n \nint\n \nin\n\n    \nprint\n(\nint\n)\n\n\n}.\nmap\n(\nto\n:\n \nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nint\n \n+\n \n4\n\n\n}.\nmap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nint\n.\ndescription\n\n\n}.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nThe above code will print the inputted integer. Then map the input to \n(integer + 4) == 7\n.\nThen the textual representation of the integer is returned as a \nString\n which will be printed.\n\n\nThis results in the following console output:\n\n\n3\n\n\n7\n\n\n\n\n\n\nRecursive futures\n\n\nIn the above \nmap\n function we returned a new result synchronously. In some situations, however, you'll need to dispatch another asynchronous call based on the result of a previous call.\n\n\nFirst, let's see how this would work out using \nmap\n by exaggerating synchronous code as if it were an asynchronous call.\n\n\n\n\nWarning\n\n\nDo not use this implementation, use the next one instead. This is an unnecessarily complicated way of nesting futures.\n\n\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nmap\n(\nto\n:\n \nFuture\nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\n(\nint\n \n+\n \n4\n)\n\n\n}.\nmap\n(\nto\n:\n \nFuture\nFuture\nString\n.\nself\n)\n \n{\n \nfutureInt\n \nin\n\n    \nreturn\n \nfutureInt\n.\nmap\n(\nto\n:\n \nFuture\nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n        \nreturn\n \nFuture\n(\nint\n.\ndescription\n)\n\n    \n}\n\n\n}.\ndo\n \n{\n \ndoubleFutureString\n \nin\n \n// Future\nFuture\nString\n\n    \ndoubleFutureString\n.\ndo\n \n{\n \nfutureString\n \nin\n \n// Future\nString\n\n      \nfutureString\n.\ndo\n \n{\n \nstring\n \nin\n\n          \nprint\n(\nstring\n)\n\n      \n}.\ncatch\n \n{\n \nerror\n \nin\n\n          \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n      \n}\n\n    \n}.\ncatch\n \n{\n \nerror\n \nin\n\n        \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n    \n}\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nTo flatten this asynchronous recursion, instead, we recommend using \nflatMap\n.\nThe type supplied in the \nto:\n argument is implied to be wrapped in a \nFuture\n.\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\n\npromise\n.\nflatMap\n(\nto\n:\n \nInt\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\nInt\n(\nint\n \n+\n \n4\n)\n\n\n}.\nflatMap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nint\n \nin\n\n    \nreturn\n \nFuture\n(\nint\n.\ndescription\n)\n\n\n}.\ndo\n \n{\n \nstring\n \nin\n\n    \nprint\n(\nstring\n)\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError \n\\(\nerror\n)\n occurred\n)\n\n\n}\n\n\n\npromise\n.\ncomplete\n(\n3\n)\n\n\n\n\n\n\nAlways\n\n\nSometimes you want to always execute a function as part of the cleanup phase.\nYou can use the \n.always\n block to execute a block of code after the future has been successfully executes (and mapped if applicable) or when an error occurred. Please do consider that finally also will be executed in the order in which it has been registered, like all other closures.\n\n\nvar\n \ni\n \n=\n \n0\n\n\n\nlet\n \npromise\n \n=\n \nPromise\nInt\n()\n\n\nlet\n \nfuture\n \n=\n \npromise\n.\nfuture\n \n// Future\nInt\n\n\n\nfuture\n.\ndo\n \n{\n \nint\n \nin\n\n    \ni\n \n+=\n \nint\n \n*\n \n3\n\n\n}.\ndo\n \n{\n \nint\n \nin\n\n    \ni\n \n+=\n \n(\nint\n \n-\n \n1\n)\n\n\n}.\ncatch\n \n{\n\n    \ni\n \n=\n \n-\n1\n\n\n}.\nfinally\n \n{\n\n    \nprint\n(\ni\n)\n\n    \ni\n \n=\n \n0\n\n\n}\n\n\n\n\n\n\nAt the end of the above function, \ni\n will \nalways\n be 0. If the promise is completed with the successful result \ni\n, the number \"11\" will be printed. On error, \"-1\" will be printed.\n\n\nSignals\n\n\nSignals, or \nFuture\nVoid\n is a Future that can contain either an Error or Void (the Expectation). \nFuture\nVoid\n is often used to indicate the successful or unsuccessful completion of a task.", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#futures", 
            "text": "You may have noticed some APIs in Vapor expect or return a  Future T  type.\nIf this is your first time hearing about futures, they might seem a little confusing at first.\nBut don't worry, Vapor makes them easy to use.  Promises and Futures are two strongly related types. Every promise has a future.\nA promise is a write-only entity that has the ability to complete (or fail) it's Future counterpart.  Futures are a read-only entity that can have a successful or error case. Successful cases are called the \"Expectation\".  Futures can be used to register callbacks to, which will always executed in the order of registration. Promises can only be completed once. If a promise is completed more than once the input will be  ignored .", 
            "title": "Futures"
        }, 
        {
            "location": "/getting-started/futures/#basics", 
            "text": "Creating a promise is when the result is returned in the future at an unknown time.\nFor the sake of demonstration, however, the promise will be completed at a predefined point in time and execution.  Within the  .do  block you may not throw an error or return a result.  let   promise   =   Promise String ()  let   future   =   promise . future   // Future String  future . do   {   string   in \n     print ( string )  }  promise . complete ( Hello )   The above code prints \"Hello\" in the console.", 
            "title": "Basics"
        }, 
        {
            "location": "/getting-started/futures/#errors", 
            "text": "When running the above code, you may have noticed a warning pop up. This is because the  .do  block only handles successful completions. If we were to replace the completion with the following code the  .do  block would never get run:  struct   MyError :   Error   {}  promise . fail ( MyError ())   Instead, a  .catch  block will be triggered.  future . do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }   In this scenario the test \"Error 'MyError' occurred\" will appear.  Within the  .catch  block you may not throw an error or return a result.", 
            "title": "Errors"
        }, 
        {
            "location": "/getting-started/futures/#basic-transformations", 
            "text": "Transformations are one of the more critical parts of Vapor 3's future system. They assist in reducing the complexity of futures and keep code isolated and readable. You can use the  .map  function to transform the future expectation to another future of the same or a different type. You need to explicitly state which type will be returned in the mapping closure.  The mapping closure(s) will  only  be executed if an expectation has been received in the previous step. If at any point a transformation function throws an error, execution stops there and the  .catch  block will be executed.  If the promise that was mapped failed to begin with, the  .catch  block will also be executed  without  triggering  any  mapping closures.  let   promise   =   Promise Int ()  promise . future . do   {   int   in \n     print ( int )  }. map ( to :   Int . self )   {   int   in \n     return   int   +   4  }. map ( to :   String . self )   {   int   in \n     return   int . description  }. do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )   The above code will print the inputted integer. Then map the input to  (integer + 4) == 7 .\nThen the textual representation of the integer is returned as a  String  which will be printed.  This results in the following console output:  3  7", 
            "title": "Basic Transformations"
        }, 
        {
            "location": "/getting-started/futures/#recursive-futures", 
            "text": "In the above  map  function we returned a new result synchronously. In some situations, however, you'll need to dispatch another asynchronous call based on the result of a previous call.  First, let's see how this would work out using  map  by exaggerating synchronous code as if it were an asynchronous call.   Warning  Do not use this implementation, use the next one instead. This is an unnecessarily complicated way of nesting futures.   let   promise   =   Promise Int ()  promise . map ( to :   Future Int . self )   {   int   in \n     return   Future ( int   +   4 )  }. map ( to :   Future Future String . self )   {   futureInt   in \n     return   futureInt . map ( to :   Future String . self )   {   int   in \n         return   Future ( int . description ) \n     }  }. do   {   doubleFutureString   in   // Future Future String \n     doubleFutureString . do   {   futureString   in   // Future String \n       futureString . do   {   string   in \n           print ( string ) \n       }. catch   {   error   in \n           print ( Error  \\( error )  occurred ) \n       } \n     }. catch   {   error   in \n         print ( Error  \\( error )  occurred ) \n     }  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )   To flatten this asynchronous recursion, instead, we recommend using  flatMap .\nThe type supplied in the  to:  argument is implied to be wrapped in a  Future .  let   promise   =   Promise Int ()  promise . flatMap ( to :   Int . self )   {   int   in \n     return   Future Int ( int   +   4 )  }. flatMap ( to :   String . self )   {   int   in \n     return   Future ( int . description )  }. do   {   string   in \n     print ( string )  }. catch   {   error   in \n     print ( Error  \\( error )  occurred )  }  promise . complete ( 3 )", 
            "title": "Recursive futures"
        }, 
        {
            "location": "/getting-started/futures/#always", 
            "text": "Sometimes you want to always execute a function as part of the cleanup phase.\nYou can use the  .always  block to execute a block of code after the future has been successfully executes (and mapped if applicable) or when an error occurred. Please do consider that finally also will be executed in the order in which it has been registered, like all other closures.  var   i   =   0  let   promise   =   Promise Int ()  let   future   =   promise . future   // Future Int  future . do   {   int   in \n     i   +=   int   *   3  }. do   {   int   in \n     i   +=   ( int   -   1 )  }. catch   { \n     i   =   - 1  }. finally   { \n     print ( i ) \n     i   =   0  }   At the end of the above function,  i  will  always  be 0. If the promise is completed with the successful result  i , the number \"11\" will be printed. On error, \"-1\" will be printed.", 
            "title": "Always"
        }, 
        {
            "location": "/getting-started/futures/#signals", 
            "text": "Signals, or  Future Void  is a Future that can contain either an Error or Void (the Expectation).  Future Void  is often used to indicate the successful or unsuccessful completion of a task.", 
            "title": "Signals"
        }, 
        {
            "location": "/getting-started/cloud/", 
            "text": "Deployment\n\n\nDeploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.\n\n\nVapor Cloud\n\n\nThe best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.\n\n\nDeploying your project to Vapor Cloud is simple, it's built right into the \nVapor Toolbox\n.\nJust run this command from within the root directory of your project.\n\n\nvapor cloud deploy\n\n\n\n\n\nFor a detailed guide, visit \nVapor Cloud \n Quick Start\n.\n\n\nOther Options\n\n\nVapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout \nDeploy \n Getting Started", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#deployment", 
            "text": "Deploying code is the process of making your Vapor project publically available. \nIt can be one of the most difficult aspects of web development. Fortunately, there\nare services to help.", 
            "title": "Deployment"
        }, 
        {
            "location": "/getting-started/cloud/#vapor-cloud", 
            "text": "The best way to deploy your application is through Vapor Cloud. It's a cloud platform built\nspecifically for the Vapor web framework. This means it's incredibly easy to deploy your\nproject quickly and be confident that it will be fast and stable.  Deploying your project to Vapor Cloud is simple, it's built right into the  Vapor Toolbox .\nJust run this command from within the root directory of your project.  vapor cloud deploy  For a detailed guide, visit  Vapor Cloud   Quick Start .", 
            "title": "Vapor Cloud"
        }, 
        {
            "location": "/getting-started/cloud/#other-options", 
            "text": "Vapor can be deployed anywhere that supports Ubuntu (basically everywhere). To learn more about\ndeploying your code, checkout  Deploy   Getting Started", 
            "title": "Other Options"
        }, 
        {
            "location": "/concepts/vapor/", 
            "text": "What is Vapor?\n\n\nVapor 3 is an \nasynchronous\n, codable and protocol oriented framework. This document will outline the major lines how vapor is designed and why.\n\n\nAsync\n\n\nVapor 3 async is a framework consisting of two basic principles. Futures and Streams. Both have their ideal use cases and strengths.\n\n\nPerformance\n\n\nVapor's high performance is achieved by a combination of an \nasynchronous architecture\n, Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.\n\n\nType safety\n\n\nVapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.\n\n\nWe believe type-safety is critical to both security and developer productivity.\n\n\nEasy to use\n\n\nCreating a new Vapor project takes only a few minutes.\n\n\nWe've got you covered with our thorough documentation and have \na helpful community\n to back it up!", 
            "title": "Vapor"
        }, 
        {
            "location": "/concepts/vapor/#what-is-vapor", 
            "text": "Vapor 3 is an  asynchronous , codable and protocol oriented framework. This document will outline the major lines how vapor is designed and why.", 
            "title": "What is Vapor?"
        }, 
        {
            "location": "/concepts/vapor/#async", 
            "text": "Vapor 3 async is a framework consisting of two basic principles. Futures and Streams. Both have their ideal use cases and strengths.", 
            "title": "Async"
        }, 
        {
            "location": "/concepts/vapor/#performance", 
            "text": "Vapor's high performance is achieved by a combination of an  asynchronous architecture , Copy on Write mechanics and highly optimized lazy parsers. These three techniques combined with Swift's compiler ensure that our performance is comparable to Go.", 
            "title": "Performance"
        }, 
        {
            "location": "/concepts/vapor/#type-safety", 
            "text": "Vapor is designed around type-safety and compile-time checks, ensuring that code doesn't behave in unexpected ways and shows you most problems at compile time. Vapor achieves this by leveraging Swift and it's Codable protocol.  We believe type-safety is critical to both security and developer productivity.", 
            "title": "Type safety"
        }, 
        {
            "location": "/concepts/vapor/#easy-to-use", 
            "text": "Creating a new Vapor project takes only a few minutes.  We've got you covered with our thorough documentation and have  a helpful community  to back it up!", 
            "title": "Easy to use"
        }, 
        {
            "location": "/concepts/content/", 
            "text": "", 
            "title": "Content"
        }, 
        {
            "location": "/concepts/services/", 
            "text": "Services\n\n\nServices is a framework for creating things you need in your application in a type-safe fashion with protocol and environment support.\n\n\nThe Services framework is designed to be thread unsafe. The framework aims to guarantee that a service exists on the same \nEventLoop\n it was created from and will be used on.\n\n\nGlossary\n\n\nContainer\n\n\nContainers are \nEventLoops\n that can create and cache services.\n\n\nRequest\n is the most common \nContainer\n type, which can be accessed in every \nRoute\n.\n\n\nEphemeralContainer\n\n\nEphemeralContainers are containers that are short-lived. Their cache does not stretch beyond a short lifecycle. The most common EphemeralContainer is an \nHTTP Request\n which lives for the duration of the route handler.\n\n\nService\n\n\nServices are a type that can be requested from a Container. They are registered as part of the application setup.\n\n\nServices are registered to a matching type or protocol it can represent, including it's own concrete type.\n\n\nServices are registered to a blueprint before the \nApplication\n is initialized. Together they make up the blueprint that Containers use to create an individual Service.\n\n\nEnvironment\n\n\nEnvironments indicate the type of deployment/situation in which an application is ran. Environments can be used to change database credentials or API tokens per environment automatically.\n\n\nRegistering\n\n\nServices are registered as a concrete (singleton) type or factories. Singleton types should be a struct, but can be a class.\n\n\nTo create an empty list of Services you can call the initializer without parameters\n\n\nvar\n \nservices\n \n=\n \nServices\n()\n\n\n\n\n\n\nThe Vapor framework has a default setup with the most common (and officially supported) Services already registered.\n\n\nvar\n \nservices\n \n=\n \nServices\n.\ndefault\n()\n\n\n\n\n\n\nConcrete implementations\n\n\nA common use case for registering a struct is for registering configurations.\nVapor 3 configurations are \nalways\n a concrete struct type. Registering a concrete type is simple:\n\n\nstruct\n \nEmptyService\n \n{}\n\n\n\nservices\n.\ninstance\n(\nEmptyService\n())\n\n\n\n\n\n\nSingletons\n\n\nSingleton classes \nmust\n be thread-safe to prevent crashes. If you want your class to be a singleton type (across all threads):\n\n\nfinal\n \nclass\n \nSingletonService\n \n{\n\n  \ninit\n()\n \n{}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\nisSingleton\n:\n \ntrue\n,\n \nSingletonService\n())\n\n\n\n\n\n\nAssuming the above service, you can now make this service from a container. The global container in Vapor is \nApplication\n which \nmust not\n be used within routes.\n\n\nlet\n \napp\n \n=\n \ntry\n \nApplication\n(\nservices\n:\n \nservices\n)\n\n\nlet\n \nemptyService\n \n=\n \napp\n.\nmake\n(\nEmptyService\n.\nself\n)\n\n\n\n\n\n\nProtocol conforming services\n\n\nOften times when registering a service is conforms to one or more protocols for which it can be used. This is one of the more widely used use cases for Services.\n\n\nenum\n \nLevel\n \n{\n\n  \ncase\n \nverbose\n,\n \nerror\n\n\n}\n\n\n\nprotocol\n \nLogger\n \n{\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n\n\n}\n\n\n\nstruct\n \nPrintLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nPrintLogger\n())\n\n\n\n\n\n\nThe above can be combined with \nisSingleton: true\n\n\nRegistering multiple conformances\n\n\nA single type can conform to multiple protocols, and you might want to register a single service for all those conforming situations.\n\n\nprotocol\n \nConsole\n \n{\n\n  \nfunc\n \nwrite\n(\n_\n \nmessage\n:\n \nString\n,\n \ncolor\n:\n \nAnsiColor\n)\n\n\n}\n\n\n\nstruct\n \nPrintConsole\n:\n \nConsole\n,\n \nLogger\n \n{\n\n  \nfunc\n \nwrite\n(\n_\n \nmessage\n:\n \nString\n,\n \ncolor\n:\n \nAnsiColor\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n  \ninit\n()\n \n{}\n\n\n}\n\n\n\nservices\n.\ninstance\n(\n\n  \nsupports\n:\n \n[\nLogger\n.\nself\n,\n \nConsole\n.\nself\n],\n\n  \nErrorLogger\n()\n\n\n)\n\n\n\n\n\n\nRegistering for a specific requester\n\n\nSometimes, the implementation should change depending on the user. A database connector might need to run over a VPN tunnel, redis might use an optimized local loopback whilst the default implementation is a normal TCP socket.\n\n\nOther times, you simply want to change the log destination depending on the type that's logging (such as logging HTTP errors differently from database errors).\n\n\nThis comes in useful when changing configurations per situation, too.\n\n\nstruct\n \nVerboseLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nprint\n(\nmessage\n)\n\n  \n}\n\n\n}\n\n\n\nstruct\n \nErrorLogger\n:\n \nLogger\n \n{\n\n  \ninit\n()\n \n{}\n\n\n  \nfunc\n \nlog\n(\n_\n \nmessage\n:\n \nString\n,\n \nlevel\n:\n \nLevel\n)\n \n{\n\n    \nif\n \nlevel\n \n==\n \n.\nerror\n \n{\n\n      \nprint\n(\nmessage\n)\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n// Only log errors\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nErrorLogger\n())\n\n\n\n// Except the router, do log not found errors verbosely\n\n\nservices\n.\ninstance\n(\nLogger\n.\nself\n,\n \nPrintLogger\n(),\n \nfor\n:\n \nRouter\n.\nself\n)\n\n\n\n\n\n\nFactorized services\n\n\nSome services have dependencies. An extremly useful use case is TLS, where the implementation is separated from the protocol. This allows users to create a TLS socket to connect to another host with without relying on a specific implementation. Vapor uses this to better integrate with the operating system by changing the default TLS implementation from OpenSSL on Linux to the Transport Security Framework on macOS and iOS.\n\n\nFactorized services get access to the event loop to factorize dependencies.\n\n\nservices\n.\nregister\n \n{\n \ncontainer\n \n-\n \nGithubClient\n \nin\n\n  \n// Create an HTTP client for our GithubClient\n\n  \nlet\n \nclient\n \n=\n \ntry\n \ncontainer\n.\nmake\n(\nClient\n.\nself\n,\n \nfor\n:\n \nGithubClient\n.\nself\n)\n\n  \ntry\n \nclient\n.\nconnect\n(\nhostname\n:\n \ngithub.com\n,\n \nssl\n:\n \ntrue\n)\n\n\n  \nreturn\n \nGithubClient\n(\nusing\n:\n \nclient\n)\n\n\n}\n\n\n\n\n\n\nPlease do note that we explicitly stated that the \nGithubClient\n requests an (HTTP) Client. We recommend doing this at all times, so that you leave configuration options open.\n\n\nEnvironments\n\n\nVapor 3 supports (custom) environments. By default we recommend (and support) the \n.production\n, \n.development\n and \n.testing\n environments.\n\n\nYou can create a custom environment type as \n.custom(\nmy-environment-name\n)\n.\n\n\nlet\n \nenvironment\n \n=\n \nEnvironment\n.\ncustom\n(\nstaging\n)\n\n\n\n\n\n\nContainers give access to the current environment, so libraries may change behaviour depending on the environment.\n\n\nChanging configurations per environment\n\n\nFor easy of development, some parameters may and should change for easy of debugging.\nPassword hashes can be made intentionally weaker in development scenarios to compensate for debug compilation performance, or API tokens may change to the correct one for your environment.\n\n\nservices\n.\nregister\n \n{\n \ncontainer\n \n-\n \nBCryptConfig\n \nin\n\n  \nlet\n \ncost\n:\n \nInt\n\n\n  \nswitch\n \ncontainer\n.\nenvironment\n \n{\n\n  \ncase\n \n.\nproduction\n:\n\n      \ncost\n \n=\n \n12\n\n  \ndefault\n:\n\n      \ncost\n \n=\n \n4\n\n  \n}\n\n\n  \nreturn\n \nBCryptConfig\n(\ncost\n:\n \ncost\n)\n\n\n}\n\n\n\n\n\n\nGetting a Service\n\n\nTo get a service you need an existing container matching the current EventLoop.\nIf you're processing a \nRequest\n, you should almost always use the Request as a Container type.\n\n\n// ErrorLogger\n\n\nlet\n \nerrorLogger\n \n=\n \nmyContainerType\n.\nmake\n(\nLogger\n.\nself\n,\n \nfor\n:\n \nRequest\n.\nself\n)\n\n\n\n// PrintLogger\n\n\nlet\n \nprintLogger\n \n=\n \nmyContainerType\n.\nmake\n(\nLogger\n.\nself\n,\n \nfor\n:\n \nRouter\n.\nself\n)", 
            "title": "Services"
        }, 
        {
            "location": "/concepts/services/#services", 
            "text": "Services is a framework for creating things you need in your application in a type-safe fashion with protocol and environment support.  The Services framework is designed to be thread unsafe. The framework aims to guarantee that a service exists on the same  EventLoop  it was created from and will be used on.", 
            "title": "Services"
        }, 
        {
            "location": "/concepts/services/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/concepts/services/#container", 
            "text": "Containers are  EventLoops  that can create and cache services.  Request  is the most common  Container  type, which can be accessed in every  Route .", 
            "title": "Container"
        }, 
        {
            "location": "/concepts/services/#ephemeralcontainer", 
            "text": "EphemeralContainers are containers that are short-lived. Their cache does not stretch beyond a short lifecycle. The most common EphemeralContainer is an  HTTP Request  which lives for the duration of the route handler.", 
            "title": "EphemeralContainer"
        }, 
        {
            "location": "/concepts/services/#service", 
            "text": "Services are a type that can be requested from a Container. They are registered as part of the application setup.  Services are registered to a matching type or protocol it can represent, including it's own concrete type.  Services are registered to a blueprint before the  Application  is initialized. Together they make up the blueprint that Containers use to create an individual Service.", 
            "title": "Service"
        }, 
        {
            "location": "/concepts/services/#environment", 
            "text": "Environments indicate the type of deployment/situation in which an application is ran. Environments can be used to change database credentials or API tokens per environment automatically.", 
            "title": "Environment"
        }, 
        {
            "location": "/concepts/services/#registering", 
            "text": "Services are registered as a concrete (singleton) type or factories. Singleton types should be a struct, but can be a class.  To create an empty list of Services you can call the initializer without parameters  var   services   =   Services ()   The Vapor framework has a default setup with the most common (and officially supported) Services already registered.  var   services   =   Services . default ()", 
            "title": "Registering"
        }, 
        {
            "location": "/concepts/services/#concrete-implementations", 
            "text": "A common use case for registering a struct is for registering configurations.\nVapor 3 configurations are  always  a concrete struct type. Registering a concrete type is simple:  struct   EmptyService   {}  services . instance ( EmptyService ())", 
            "title": "Concrete implementations"
        }, 
        {
            "location": "/concepts/services/#singletons", 
            "text": "Singleton classes  must  be thread-safe to prevent crashes. If you want your class to be a singleton type (across all threads):  final   class   SingletonService   { \n   init ()   {}  }  services . instance ( isSingleton :   true ,   SingletonService ())   Assuming the above service, you can now make this service from a container. The global container in Vapor is  Application  which  must not  be used within routes.  let   app   =   try   Application ( services :   services )  let   emptyService   =   app . make ( EmptyService . self )", 
            "title": "Singletons"
        }, 
        {
            "location": "/concepts/services/#protocol-conforming-services", 
            "text": "Often times when registering a service is conforms to one or more protocols for which it can be used. This is one of the more widely used use cases for Services.  enum   Level   { \n   case   verbose ,   error  }  protocol   Logger   { \n   func   log ( _   message :   String ,   level :   Level )  }  struct   PrintLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   }  }  services . instance ( Logger . self ,   PrintLogger ())   The above can be combined with  isSingleton: true", 
            "title": "Protocol conforming services"
        }, 
        {
            "location": "/concepts/services/#registering-multiple-conformances", 
            "text": "A single type can conform to multiple protocols, and you might want to register a single service for all those conforming situations.  protocol   Console   { \n   func   write ( _   message :   String ,   color :   AnsiColor )  }  struct   PrintConsole :   Console ,   Logger   { \n   func   write ( _   message :   String ,   color :   AnsiColor )   { \n     print ( message ) \n   } \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   } \n\n   init ()   {}  }  services . instance ( \n   supports :   [ Logger . self ,   Console . self ], \n   ErrorLogger ()  )", 
            "title": "Registering multiple conformances"
        }, 
        {
            "location": "/concepts/services/#registering-for-a-specific-requester", 
            "text": "Sometimes, the implementation should change depending on the user. A database connector might need to run over a VPN tunnel, redis might use an optimized local loopback whilst the default implementation is a normal TCP socket.  Other times, you simply want to change the log destination depending on the type that's logging (such as logging HTTP errors differently from database errors).  This comes in useful when changing configurations per situation, too.  struct   VerboseLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     print ( message ) \n   }  }  struct   ErrorLogger :   Logger   { \n   init ()   {} \n\n   func   log ( _   message :   String ,   level :   Level )   { \n     if   level   ==   . error   { \n       print ( message ) \n     } \n   }  }  // Only log errors  services . instance ( Logger . self ,   ErrorLogger ())  // Except the router, do log not found errors verbosely  services . instance ( Logger . self ,   PrintLogger (),   for :   Router . self )", 
            "title": "Registering for a specific requester"
        }, 
        {
            "location": "/concepts/services/#factorized-services", 
            "text": "Some services have dependencies. An extremly useful use case is TLS, where the implementation is separated from the protocol. This allows users to create a TLS socket to connect to another host with without relying on a specific implementation. Vapor uses this to better integrate with the operating system by changing the default TLS implementation from OpenSSL on Linux to the Transport Security Framework on macOS and iOS.  Factorized services get access to the event loop to factorize dependencies.  services . register   {   container   -   GithubClient   in \n   // Create an HTTP client for our GithubClient \n   let   client   =   try   container . make ( Client . self ,   for :   GithubClient . self ) \n   try   client . connect ( hostname :   github.com ,   ssl :   true ) \n\n   return   GithubClient ( using :   client )  }   Please do note that we explicitly stated that the  GithubClient  requests an (HTTP) Client. We recommend doing this at all times, so that you leave configuration options open.", 
            "title": "Factorized services"
        }, 
        {
            "location": "/concepts/services/#environments", 
            "text": "Vapor 3 supports (custom) environments. By default we recommend (and support) the  .production ,  .development  and  .testing  environments.  You can create a custom environment type as  .custom( my-environment-name ) .  let   environment   =   Environment . custom ( staging )   Containers give access to the current environment, so libraries may change behaviour depending on the environment.", 
            "title": "Environments"
        }, 
        {
            "location": "/concepts/services/#changing-configurations-per-environment", 
            "text": "For easy of development, some parameters may and should change for easy of debugging.\nPassword hashes can be made intentionally weaker in development scenarios to compensate for debug compilation performance, or API tokens may change to the correct one for your environment.  services . register   {   container   -   BCryptConfig   in \n   let   cost :   Int \n\n   switch   container . environment   { \n   case   . production : \n       cost   =   12 \n   default : \n       cost   =   4 \n   } \n\n   return   BCryptConfig ( cost :   cost )  }", 
            "title": "Changing configurations per environment"
        }, 
        {
            "location": "/concepts/services/#getting-a-service", 
            "text": "To get a service you need an existing container matching the current EventLoop.\nIf you're processing a  Request , you should almost always use the Request as a Container type.  // ErrorLogger  let   errorLogger   =   myContainerType . make ( Logger . self ,   for :   Request . self )  // PrintLogger  let   printLogger   =   myContainerType . make ( Logger . self ,   for :   Router . self )", 
            "title": "Getting a Service"
        }, 
        {
            "location": "/concepts/http/", 
            "text": "HTTP\n\n\nAt the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.\n\n\nHTTP comes in two major versions. \nHTTP/1\n and \nHTTP/2\n. Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.\n\n\nWhat is the difference?\n\n\nHTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.\n\n\nHTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.\n\n\nHow it works\n\n\nAt the heart of HTTP lie the \nRequest\n and \nResponse\n types. Both of them are \"HTTP Messages\". Both HTTP messages consists of \nHeaders\n and a \nbody\n.\n\n\nHTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.\n\n\nBodies contain the concrete information being transferred. Think of the web-page, images, videos, JSON and \nforms\n.\n\n\nHeaders contain metadata, meaning they carry information describing the HTTP message, it's context and it's content.\n\n\nCookies\n are context metadata about the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are \nsession tokens\n.\n\n\nAnother type of metadata that is often used to define the type of content transferred in the body is the \nContent-Type\n header\n\n\nRequest\n\n\nRequests have two additional properties in addition to all properties of a Message. The \nMethod\n and \npath\n.\n\n\nThe path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of \ncomponents\n. The components are separated by a forward slash (\n/\n). All components must be encoded with percent encoding, affecting special characters only.\n\n\nThe \nmethod\n indicated the operation to this resource. \nGET\n is used for reading a resource where \nDELETE\n will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.\n\n\nResponse\n\n\nResponses have one additional property in addition to the message's properties. This is \nthe status code\n. The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively. \nMore about status codes here.\n\n\nHandling requests\n\n\nRequests in Vapor will be handled by a \nrouter\n. This allows registering a path to a method. For example, registering \n.get(\"users\")\n will register the path \n/users/\n to the method \nGET\n. The responder/closure associated with this route can then handle requests sent to \n/users/\n with the \nGET\n method.\n\n\nTypes of endpoints\n\n\nIn the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.\n\n\niOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.\n\n\nWebsites\n\n\nWebsites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.\n\n\nServer rendered pages make use of a templating system such as \nleaf\n whereas client rendered pages communicate with an API.\n\n\nAPI\n\n\nAPIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with \nJSON\n. Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.\n\n\nAPIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model \nwhich we explain here.\n\n\nDesigning an API in Vapor is really simple. \nWe dive into this from here.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#http", 
            "text": "At the heart of the web lies HTTP. HTTP (or HyperText Transfer Protocol) is used for communicating multiple types of media between a client and a server.  HTTP comes in two major versions.  HTTP/1  and  HTTP/2 . Vapor comes with HTTP/1 support by default but has an official package for HTTP/2, too.", 
            "title": "HTTP"
        }, 
        {
            "location": "/concepts/http/#what-is-the-difference", 
            "text": "HTTP/1 is a protocol designed in the '90s for the then new and rapidly evolving internet. The protocol is designed around simplicity above security and functionality.  HTTP/2 is a protocol with security and performance in mind. Designed with experience of the past 20 years of internet in addition to modern standards such as a high bandwidth and many resources per page.", 
            "title": "What is the difference?"
        }, 
        {
            "location": "/concepts/http/#how-it-works", 
            "text": "At the heart of HTTP lie the  Request  and  Response  types. Both of them are \"HTTP Messages\". Both HTTP messages consists of  Headers  and a  body .  HTTP clients connect to an HTTP server. The clients can send a request to which the server will send a response.  Bodies contain the concrete information being transferred. Think of the web-page, images, videos, JSON and  forms .  Headers contain metadata, meaning they carry information describing the HTTP message, it's context and it's content.  Cookies  are context metadata about the client that, for example, can be used for identifying users after they've (successfully) logged in. One of these methods are  session tokens .  Another type of metadata that is often used to define the type of content transferred in the body is the  Content-Type  header", 
            "title": "How it works"
        }, 
        {
            "location": "/concepts/http/#request", 
            "text": "Requests have two additional properties in addition to all properties of a Message. The  Method  and  path .  The path is used to specify the resource being accessed. Although there are conventions, there are no rules/limitations to how you structure your paths except their format. Paths consist of  components . The components are separated by a forward slash ( / ). All components must be encoded with percent encoding, affecting special characters only.  The  method  indicated the operation to this resource.  GET  is used for reading a resource where  DELETE  will (attempt to) remove the resource. This does not mean you need to blindly comply. If a user doesn't have the permissions for said operation, you can emit a response indicating this.", 
            "title": "Request"
        }, 
        {
            "location": "/concepts/http/#response", 
            "text": "Responses have one additional property in addition to the message's properties. This is  the status code . The status code is used to indicate to the client what the status/result is of a Request. If a client was not authenticated, for example, you would return a status 401 or 403 for \"Unauthorized\" or \"Forbidden\" respectively.  More about status codes here.", 
            "title": "Response"
        }, 
        {
            "location": "/concepts/http/#handling-requests", 
            "text": "Requests in Vapor will be handled by a  router . This allows registering a path to a method. For example, registering  .get(\"users\")  will register the path  /users/  to the method  GET . The responder/closure associated with this route can then handle requests sent to  /users/  with the  GET  method.", 
            "title": "Handling requests"
        }, 
        {
            "location": "/concepts/http/#types-of-endpoints", 
            "text": "In the web we usually define two types of endpoints. Either a website or an API. Websites are HTML pages, usually with associated styling, code and images. APIs are endpoints that communicate with raw information rather than types and user friendly information. APIs are aimed to developers and their applications.  iOS and Android apps usually communicate with an API, where a web browser such as Safari, Firefox, Chrome or Edge will usually communicate with a website.", 
            "title": "Types of endpoints"
        }, 
        {
            "location": "/concepts/http/#websites", 
            "text": "Websites come in two major flavours. Server and client rendered pages. \"Rendering\" in this context doesn't mean the graphical rendering on your monitor, but instead the way information is injected into the HTML DOM to display the information to the users.  Server rendered pages make use of a templating system such as  leaf  whereas client rendered pages communicate with an API.", 
            "title": "Websites"
        }, 
        {
            "location": "/concepts/http/#api", 
            "text": "APIs are endpoints that sometimes receive but always reply with raw data. The raw data can be in any format. Most commonly, APIs communicate with  JSON . Sometimes, they communicate with XML or other data types. Vapor can flexibly switch between supported formats, both by official or by community made libraries.  APIs in Vapor are (almost) always creating using a \"MVC\" or \"Model View Controller\" model  which we explain here.  Designing an API in Vapor is really simple.  We dive into this from here.", 
            "title": "API"
        }, 
        {
            "location": "/concepts/code-contributions/", 
            "text": "API Design\n\n\nFor contributing code we have guidelines that we strive for, and requirements.\nAccepted code \nmust\n comply to all requirements and \nshould\n follow all guidelines.\n\n\nRequirements\n\n\nThe requirements stated here \nmust\n be followed for all Vapor 3 code starting with the beta.\nWe designed all of Vapor 3's APIs (including the Async library) to require little to no breaking changes over the coming years.\n\n\nEnums\n\n\nenum\ns should only be used where adding a new case should result in a breaking change. Specifically since exhaustively switching on an \nenum\n will no longer compile when a new case is added. For things like errors, this is obviously undesirable as supporting a new error type results in code no longer compiling. However, for something like a supported data type, \nenum\ns makes sense because the errors help you track down all of places that need support for that new type added. Most use cases for \nenum\ns are when the enum is internal to the current module.\n\n\nClasses\n\n\nAlways mark classes as \nfinal\n. If you plan on using a \npublic\n class, look into a protocol or generics oriented approach.\n\n\nLow-level APIs\n\n\nLow level APIs such as sockets, SSL, cryptography and HTTP should be oriented towards simplicity, maintainability and correctness.\nIf you feel an API becomes more complex for end-users, you can add high level APIs that rely on the low-level ones.\n\n\nTests\n\n\nThe unit tests must have a minimum of 80% code coverage.\n\n\nUniformity\n\n\nStick to the familiar API patterns. If connecting a socket has the following signature:\n\n\ntry\n \nsocket\n.\nconnect\n(\nto\n:\n \nexample.com\n,\n \nport\n:\n \n80\n)\n\n\n\n\n\n\nCopy the signature, rather than adding an extra case.\nIf you need more metadata for connecting, consider setting them in the initializer or as a variable on the type.\n\n\nBinary data\n\n\nBinary data should be passed around in 3 formats;\n\n\n\n\nByteBuffer\n\n\nData\n\n\n[UInt8]\n\n\n\n\nYou should use \nByteBuffer\n when working with Streams to limit copies and improve the stream chaining applicability.\n\nData\n for larger sets of data (\n1000 bytes) and \n[UInt8]\n for smaller data sets (\n=1000 bytes).\n\n\nDictionaries and Arrays\n\n\nWhere you'd normally use a dictionary (such as HTTP headers) you \nshould\n create a separate struct instead.\nThis improves the freedom for future optimizations and keeps the implementation separate from the end user API.\nThis results in better future-proofing and helps building better (more specialized) APIs.\n\n\nGuidelines\n\n\nPerformance\n\n\nPerformance regression is acceptable to some degree but should be limited.\nHere are some tips on achieving high performance code or ensuring more performance can be added in the future.\n\n\nAccess modifiers\n\n\nTry to use the \npublic\n keyword as little as possible. More APIs adds more complexity than freedom.\nSpecialized use cases are always free to build their own modules, and a \npublic\n keyword can be added but not undone.\n\n\nComments\n\n\nGreen is the future, and we believe in that, too! I'm not talking about green energy, but the often green coloured code comments.\nCode comments important for the users of an API. Do not add meaningless comments, though.\n\n\nDocumentation\n\n\nEvery \npublic\n function, type and variable \nshould\n have a link to the documentation describing it's use case(s) with examples.\n\n\nArgument labels\n\n\nAlong with uniformity described above, you should try to keep argument labels short and descriptive.\n\n\nArgument count\n\n\nWe strive for functions with a maximum of 3 parameters, although certain use cases permit for more arguments.\nOften called functions should strive for less arguments.\n\n\nInitializer complexity\n\n\nInitializers are complex enough, it is recommended to \nnot\n put optional arguments in an initializer since they can be modified on the entity itself.\nTry to limit the initializer to what really matters, and put the rest in \nfunc\ntions.", 
            "title": "Code Contributions"
        }, 
        {
            "location": "/concepts/code-contributions/#api-design", 
            "text": "For contributing code we have guidelines that we strive for, and requirements.\nAccepted code  must  comply to all requirements and  should  follow all guidelines.", 
            "title": "API Design"
        }, 
        {
            "location": "/concepts/code-contributions/#requirements", 
            "text": "The requirements stated here  must  be followed for all Vapor 3 code starting with the beta.\nWe designed all of Vapor 3's APIs (including the Async library) to require little to no breaking changes over the coming years.", 
            "title": "Requirements"
        }, 
        {
            "location": "/concepts/code-contributions/#enums", 
            "text": "enum s should only be used where adding a new case should result in a breaking change. Specifically since exhaustively switching on an  enum  will no longer compile when a new case is added. For things like errors, this is obviously undesirable as supporting a new error type results in code no longer compiling. However, for something like a supported data type,  enum s makes sense because the errors help you track down all of places that need support for that new type added. Most use cases for  enum s are when the enum is internal to the current module.", 
            "title": "Enums"
        }, 
        {
            "location": "/concepts/code-contributions/#classes", 
            "text": "Always mark classes as  final . If you plan on using a  public  class, look into a protocol or generics oriented approach.", 
            "title": "Classes"
        }, 
        {
            "location": "/concepts/code-contributions/#low-level-apis", 
            "text": "Low level APIs such as sockets, SSL, cryptography and HTTP should be oriented towards simplicity, maintainability and correctness.\nIf you feel an API becomes more complex for end-users, you can add high level APIs that rely on the low-level ones.", 
            "title": "Low-level APIs"
        }, 
        {
            "location": "/concepts/code-contributions/#tests", 
            "text": "The unit tests must have a minimum of 80% code coverage.", 
            "title": "Tests"
        }, 
        {
            "location": "/concepts/code-contributions/#uniformity", 
            "text": "Stick to the familiar API patterns. If connecting a socket has the following signature:  try   socket . connect ( to :   example.com ,   port :   80 )   Copy the signature, rather than adding an extra case.\nIf you need more metadata for connecting, consider setting them in the initializer or as a variable on the type.", 
            "title": "Uniformity"
        }, 
        {
            "location": "/concepts/code-contributions/#binary-data", 
            "text": "Binary data should be passed around in 3 formats;   ByteBuffer  Data  [UInt8]   You should use  ByteBuffer  when working with Streams to limit copies and improve the stream chaining applicability. Data  for larger sets of data ( 1000 bytes) and  [UInt8]  for smaller data sets ( =1000 bytes).", 
            "title": "Binary data"
        }, 
        {
            "location": "/concepts/code-contributions/#dictionaries-and-arrays", 
            "text": "Where you'd normally use a dictionary (such as HTTP headers) you  should  create a separate struct instead.\nThis improves the freedom for future optimizations and keeps the implementation separate from the end user API.\nThis results in better future-proofing and helps building better (more specialized) APIs.", 
            "title": "Dictionaries and Arrays"
        }, 
        {
            "location": "/concepts/code-contributions/#guidelines", 
            "text": "", 
            "title": "Guidelines"
        }, 
        {
            "location": "/concepts/code-contributions/#performance", 
            "text": "Performance regression is acceptable to some degree but should be limited.\nHere are some tips on achieving high performance code or ensuring more performance can be added in the future.", 
            "title": "Performance"
        }, 
        {
            "location": "/concepts/code-contributions/#access-modifiers", 
            "text": "Try to use the  public  keyword as little as possible. More APIs adds more complexity than freedom.\nSpecialized use cases are always free to build their own modules, and a  public  keyword can be added but not undone.", 
            "title": "Access modifiers"
        }, 
        {
            "location": "/concepts/code-contributions/#comments", 
            "text": "Green is the future, and we believe in that, too! I'm not talking about green energy, but the often green coloured code comments.\nCode comments important for the users of an API. Do not add meaningless comments, though.", 
            "title": "Comments"
        }, 
        {
            "location": "/concepts/code-contributions/#documentation", 
            "text": "Every  public  function, type and variable  should  have a link to the documentation describing it's use case(s) with examples.", 
            "title": "Documentation"
        }, 
        {
            "location": "/concepts/code-contributions/#argument-labels", 
            "text": "Along with uniformity described above, you should try to keep argument labels short and descriptive.", 
            "title": "Argument labels"
        }, 
        {
            "location": "/concepts/code-contributions/#argument-count", 
            "text": "We strive for functions with a maximum of 3 parameters, although certain use cases permit for more arguments.\nOften called functions should strive for less arguments.", 
            "title": "Argument count"
        }, 
        {
            "location": "/concepts/code-contributions/#initializer-complexity", 
            "text": "Initializers are complex enough, it is recommended to  not  put optional arguments in an initializer since they can be modified on the entity itself.\nTry to limit the initializer to what really matters, and put the rest in  func tions.", 
            "title": "Initializer complexity"
        }, 
        {
            "location": "/async/getting-started/", 
            "text": "Using Async\n\n\nAsync is a library revolving around two main concepts:\n\n\n\n\nPromises and Futures\n\n\n(Reactive) Streams\n\n\nEventLoops\n\n\n\n\nTogether they form the foundation of Vapor 3's data flow.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nAsync\n\n\n\n\n\n\nWithout Vapor\n\n\nAsync is a powerful library for any Swift project. To include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/async.git\n,\n \n.\nrevision\n(\nbeta\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nAsync\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Async\n to access Async's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/async/getting-started/#using-async", 
            "text": "Async is a library revolving around two main concepts:   Promises and Futures  (Reactive) Streams  EventLoops   Together they form the foundation of Vapor 3's data flow.", 
            "title": "Using Async"
        }, 
        {
            "location": "/async/getting-started/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Async", 
            "title": "With Vapor"
        }, 
        {
            "location": "/async/getting-started/#without-vapor", 
            "text": "Async is a powerful library for any Swift project. To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/async.git ,   . revision ( beta )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Async ,   ...   ]) \n     ]  )   Use  import Async  to access Async's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/async/futures/", 
            "text": "Futures\n\n\nFutures are used throughout Vapor 3.\n\n\nThey aim to provide a more simplified but high performance interface to process\ndata actions and transformations.\n\n\nWe explain the future basics and use cases \nhere\n.", 
            "title": "Futures"
        }, 
        {
            "location": "/async/futures/#futures", 
            "text": "Futures are used throughout Vapor 3.  They aim to provide a more simplified but high performance interface to process\ndata actions and transformations.  We explain the future basics and use cases  here .", 
            "title": "Futures"
        }, 
        {
            "location": "/async/streams/", 
            "text": "Streams\n\n\nStreams are a mechanism that process any information efficiently, \nreactively\n and asynchronously without bloat. They make asynchronous data flows easier to deal with.\n\n\nStreams are designed to limit memory usage and copies. They are used in all domains of Vapor 3, be it sockets, be it (larger) database operations.\n\n\nDraining streams\n\n\nIn this example we print the string representation of the TCP connnection's incoming data.\n\n\nSince this socket is reactive we need to first request data before we can expect a result.\nAfter requesting data we need to set up the output\n\n\nimport\n \nAsync\n\n\nimport\n \nFoundation\n\n\n\n...\n\n\n\ntcpSocket\n.\ndrain\n \n{\n \nupstream\n \nin\n\n    \nupstream\n.\nrequest\n()\n\n\n}.\noutput\n \n{\n \nbuffer\n \nin\n\n    \nprint\n(\nString\n(\nbytes\n:\n \nbuffer\n,\n \nencoding\n:\n \n.\nutf8\n))\n\n    \ntcpSocket\n.\nrequest\n()\n\n\n}.\ncatch\n \n{\n \nerror\n \nin\n\n    \nprint\n(\nError occurred \n\\(\nerror\n)\n)\n\n\n}.\nfinally\n \n{\n\n    \nprint\n(\nTCP socket closed\n)\n\n\n}\n\n\n\n\n\n\nIn the above implementation we explicitly request more information from the socket after receiving output.\n\n\nEmitting output\n\n\nEmitter streams are useful if you don't want to create your own reactive stream implementation.\n\n\nThey allow emitting output easily which can then be used like any other stream.\n\n\nlet\n \nemitter\n \n=\n \nEmitterStream\nInt\n()\n\n\n\nemitter\n.\ndrain\n \n{\n \nupstream\n \nin\n\n  \nupstream\n.\nrequest\n()\n\n\n}.\noutput\n \n{\n \nnumber\n \nin\n\n  \nprint\n(\nnumber\n)\n\n  \nemitter\n.\nrequest\n()\n\n\n}\n\n\n\nemitter\n.\nemit\n(\n3\n)\n\n\nemitter\n.\nemit\n(\n4\n)\n\n\nemitter\n.\nemit\n(\n3\n)\n\n\nemitter\n.\nemit\n(\n5\n)\n\n\n\n\n\n\nMapping Streams\n\n\nTo transform a string to another type you can map it similarly to futures.\nThe following assumes \nstream\n contains a stream of \nInt\n as defined in the above emitter.\n\n\nlet\n \nstringStream\n \n=\n \nemitter\n.\nmap\n(\nto\n:\n \nString\n.\nself\n)\n \n{\n \nnumber\n \nin\n\n  \nreturn\n \nnumber\n.\ndescription\n\n\n}\n\n\n\n\n\n\nImplementing custom streams\n\n\nComing soon", 
            "title": "Streams"
        }, 
        {
            "location": "/async/streams/#streams", 
            "text": "Streams are a mechanism that process any information efficiently,  reactively  and asynchronously without bloat. They make asynchronous data flows easier to deal with.  Streams are designed to limit memory usage and copies. They are used in all domains of Vapor 3, be it sockets, be it (larger) database operations.", 
            "title": "Streams"
        }, 
        {
            "location": "/async/streams/#draining-streams", 
            "text": "In this example we print the string representation of the TCP connnection's incoming data.  Since this socket is reactive we need to first request data before we can expect a result.\nAfter requesting data we need to set up the output  import   Async  import   Foundation  ...  tcpSocket . drain   {   upstream   in \n     upstream . request ()  }. output   {   buffer   in \n     print ( String ( bytes :   buffer ,   encoding :   . utf8 )) \n     tcpSocket . request ()  }. catch   {   error   in \n     print ( Error occurred  \\( error ) )  }. finally   { \n     print ( TCP socket closed )  }   In the above implementation we explicitly request more information from the socket after receiving output.", 
            "title": "Draining streams"
        }, 
        {
            "location": "/async/streams/#emitting-output", 
            "text": "Emitter streams are useful if you don't want to create your own reactive stream implementation.  They allow emitting output easily which can then be used like any other stream.  let   emitter   =   EmitterStream Int ()  emitter . drain   {   upstream   in \n   upstream . request ()  }. output   {   number   in \n   print ( number ) \n   emitter . request ()  }  emitter . emit ( 3 )  emitter . emit ( 4 )  emitter . emit ( 3 )  emitter . emit ( 5 )", 
            "title": "Emitting output"
        }, 
        {
            "location": "/async/streams/#mapping-streams", 
            "text": "To transform a string to another type you can map it similarly to futures.\nThe following assumes  stream  contains a stream of  Int  as defined in the above emitter.  let   stringStream   =   emitter . map ( to :   String . self )   {   number   in \n   return   number . description  }", 
            "title": "Mapping Streams"
        }, 
        {
            "location": "/async/streams/#implementing-custom-streams", 
            "text": "Coming soon", 
            "title": "Implementing custom streams"
        }, 
        {
            "location": "/async/eventloop/", 
            "text": "EventLoop\n\n\nEvent loops are at the heart of Vapor's non-blocking concurrency model. There is usually one event loop per logical core in your computer's CPU. The event loop's main purpose is to detect when data is ready to be read from or written to a socket. By detecting socket events before actually attempting to read or write data, Vapor can avoid making function calls that may block. Avoiding blocking calls is critical for performance as it allows Vapor to aggressively re-use threads, making your app very fast and efficient.\n\n\nIn addition to the above, they're also able to run single tasks inbetween listening for events.\n\n\nThere are three main forms of eventloops.\n\n\nDispatchEventLoop\n is based on Dispatch, \nKQueueEventLoop\n is a macOS-only eventloop that is more performant than Dispatch.\n\n\nThe third one (currently work in progress) is the \nEPollEventLoop\n, a Linux only eventloop that is also more performant than Dispatch.\n\n\nWorkers\n\n\nTo carry around context, the \nWorker\n protocol exists to indicate the current eventloop context.\n\n\nprint\n(\nworker\n.\neventLoop\n)\n \n// EventLoop\n\n\n\n\n\n\nWhen looking for a worker, the most common ones you'll come across are the \nRequest\n and \nResponse\n.\n\n\nFuture changes during beta\n\n\nIt is likely that we'll start inferring the current EventLoop using the Thread Local Storage, removing the need for Workers and passing EventLoop as an argument.\n\n\nSources\n\n\nTo add/remove listeners from EventLoops you can ask for a readable or writable source or \nEventSource\n. EventSources are a handle which can be resumed, suspended and cancelled.\nWhen requesting said handle on an EventLoop you must provide a closure which calls back with the notification.\n\n\nThis notification indicates that data is available for work in the provided descriptor. This includes the descriptor being closed.\n\n\nlet\n \nsourceHandle\n \n=\n \neventLoop\n.\nonReadable\n(\ndescriptor\n:\n \nsocket\n.\ndescriptor\n)\n \n{\n \ncancelled\n \nin\n\n  \nif\n \ncancelled\n \n{\n\n    \nprint\n(\ndescriptor closed\n)\n\n  \n}\n \nelse\n \n{\n\n    \nprint\n(\nData is readable\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWrite sources are the opposite of a Source in that they notify the ability to write data. They should be suspended after the first write so that they do not call back every loop.\n\n\nWhilst Sources indicate the availability of data, Drains\n\n\nSockets\n\n\nAs part of the EventLoops in Vapor 3, we also centralized the asynchronous part of Sockets, simplifying the APIs for I/O and improving it's asynchronous usability. It is recommended for (raw) TCP, (raw) UDP and SSL implementations to conform to the \nSocket\n protocol.\n\n\nSocketSink and SocketSource\n\n\nSocketSink\n is a helper that assists with writing data to sockets reactively.\n\nSocketSource\n is a helper that functions as the Sink's counterpart with reading data from sockets reactively.\n\n\nlet\n \nsink\n \n=\n \nsocket\n.\nsink\n(\non\n:\n \neventLoop\n)", 
            "title": "EventLoop"
        }, 
        {
            "location": "/async/eventloop/#eventloop", 
            "text": "Event loops are at the heart of Vapor's non-blocking concurrency model. There is usually one event loop per logical core in your computer's CPU. The event loop's main purpose is to detect when data is ready to be read from or written to a socket. By detecting socket events before actually attempting to read or write data, Vapor can avoid making function calls that may block. Avoiding blocking calls is critical for performance as it allows Vapor to aggressively re-use threads, making your app very fast and efficient.  In addition to the above, they're also able to run single tasks inbetween listening for events.  There are three main forms of eventloops.  DispatchEventLoop  is based on Dispatch,  KQueueEventLoop  is a macOS-only eventloop that is more performant than Dispatch.  The third one (currently work in progress) is the  EPollEventLoop , a Linux only eventloop that is also more performant than Dispatch.", 
            "title": "EventLoop"
        }, 
        {
            "location": "/async/eventloop/#workers", 
            "text": "To carry around context, the  Worker  protocol exists to indicate the current eventloop context.  print ( worker . eventLoop )   // EventLoop   When looking for a worker, the most common ones you'll come across are the  Request  and  Response .", 
            "title": "Workers"
        }, 
        {
            "location": "/async/eventloop/#future-changes-during-beta", 
            "text": "It is likely that we'll start inferring the current EventLoop using the Thread Local Storage, removing the need for Workers and passing EventLoop as an argument.", 
            "title": "Future changes during beta"
        }, 
        {
            "location": "/async/eventloop/#sources", 
            "text": "To add/remove listeners from EventLoops you can ask for a readable or writable source or  EventSource . EventSources are a handle which can be resumed, suspended and cancelled.\nWhen requesting said handle on an EventLoop you must provide a closure which calls back with the notification.  This notification indicates that data is available for work in the provided descriptor. This includes the descriptor being closed.  let   sourceHandle   =   eventLoop . onReadable ( descriptor :   socket . descriptor )   {   cancelled   in \n   if   cancelled   { \n     print ( descriptor closed ) \n   }   else   { \n     print ( Data is readable ) \n   }  }   Write sources are the opposite of a Source in that they notify the ability to write data. They should be suspended after the first write so that they do not call back every loop.  Whilst Sources indicate the availability of data, Drains", 
            "title": "Sources"
        }, 
        {
            "location": "/async/eventloop/#sockets", 
            "text": "As part of the EventLoops in Vapor 3, we also centralized the asynchronous part of Sockets, simplifying the APIs for I/O and improving it's asynchronous usability. It is recommended for (raw) TCP, (raw) UDP and SSL implementations to conform to the  Socket  protocol.", 
            "title": "Sockets"
        }, 
        {
            "location": "/async/eventloop/#socketsink-and-socketsource", 
            "text": "SocketSink  is a helper that assists with writing data to sockets reactively. SocketSource  is a helper that functions as the Sink's counterpart with reading data from sockets reactively.  let   sink   =   socket . sink ( on :   eventLoop )", 
            "title": "SocketSink and SocketSource"
        }, 
        {
            "location": "/async/reactive/", 
            "text": "Reactive Programming\n\n\nAs part of the Vapor 3 ecosystem we embrace reactiveness.\n\n\nReactiveness means your Vapor applications will be more resilient to the producer-consumer problem that has long plagued web applications. Vapor achieves this by moving from \"push\" streams (aka, fire hose streams) to \"pull\" streams. At a high level, this means better performance and less memory usage during peak demand.\n\n\nLearn more at \nreactive-streams.org\n.\n\n\nAs part of our API design we strive to minimize the impact on code.\n\n\nReducing code impact\n\n\nMost of our code impact is reduced using protocols.\nBy conforming Futures and Streams to the \nCodable\n protocol we can use reactiveness throughout all components of Vapor 3.\n\n\nThis allows for reactive templating with less code than before reactiveness was introduced.\n\n\nRules\n\n\nThe following rules are critical to reactive programming with Vapor 3:\n\n\nInformation flow\n\n\nStream data must be asynchronously available. This means that when input is received, the information stays intact until new data is requested or the sending stream is cancelled/closed.\n\n\nOutput to another stream must stay intact (in the case of \nByteBuffer\n, must not be deallocated or reused) until a new request for data has been made.\n\n\nUpstream\n\n\nRequesting data from upstream must only be done if you do not have enough information to complete a request from downstream.\n\n\nDownstream\n\n\nYou \nmust not\n feed more data to downstream than was requested.\n\n\nBlocking\n\n\nYou \nmust not\n block within a stream using \nsleep\n or blocking sockets.", 
            "title": "Reactive Programming"
        }, 
        {
            "location": "/async/reactive/#reactive-programming", 
            "text": "As part of the Vapor 3 ecosystem we embrace reactiveness.  Reactiveness means your Vapor applications will be more resilient to the producer-consumer problem that has long plagued web applications. Vapor achieves this by moving from \"push\" streams (aka, fire hose streams) to \"pull\" streams. At a high level, this means better performance and less memory usage during peak demand.  Learn more at  reactive-streams.org .  As part of our API design we strive to minimize the impact on code.", 
            "title": "Reactive Programming"
        }, 
        {
            "location": "/async/reactive/#reducing-code-impact", 
            "text": "Most of our code impact is reduced using protocols.\nBy conforming Futures and Streams to the  Codable  protocol we can use reactiveness throughout all components of Vapor 3.  This allows for reactive templating with less code than before reactiveness was introduced.", 
            "title": "Reducing code impact"
        }, 
        {
            "location": "/async/reactive/#rules", 
            "text": "The following rules are critical to reactive programming with Vapor 3:", 
            "title": "Rules"
        }, 
        {
            "location": "/async/reactive/#information-flow", 
            "text": "Stream data must be asynchronously available. This means that when input is received, the information stays intact until new data is requested or the sending stream is cancelled/closed.  Output to another stream must stay intact (in the case of  ByteBuffer , must not be deallocated or reused) until a new request for data has been made.", 
            "title": "Information flow"
        }, 
        {
            "location": "/async/reactive/#upstream", 
            "text": "Requesting data from upstream must only be done if you do not have enough information to complete a request from downstream.", 
            "title": "Upstream"
        }, 
        {
            "location": "/async/reactive/#downstream", 
            "text": "You  must not  feed more data to downstream than was requested.", 
            "title": "Downstream"
        }, 
        {
            "location": "/async/reactive/#blocking", 
            "text": "You  must not  block within a stream using  sleep  or blocking sockets.", 
            "title": "Blocking"
        }, 
        {
            "location": "/http/getting-started/", 
            "text": "Using HTTP\n\n\nHTTP is a module as part of the \nEngine\n library containing all HTTP related APIs.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nHTTP\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/engine.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nHTTP\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport HTTP\n to access HTTP's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/http/getting-started/#using-http", 
            "text": "HTTP is a module as part of the  Engine  library containing all HTTP related APIs.", 
            "title": "Using HTTP"
        }, 
        {
            "location": "/http/getting-started/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   HTTP", 
            "title": "With Vapor"
        }, 
        {
            "location": "/http/getting-started/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/engine.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ HTTP ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import HTTP  to access HTTP's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/http/body/", 
            "text": "HTTPBody\n\n\nHTTPBody is a type that contains the raw representation of a \nRequest\n or \nResponse\n. It's contents are related to the \nContent-Type\n header.\n\n\nBody can contain, but is not limited to \nData\n, \nString\n, \nDispatchData\n or binary streams.\nBinary streams will be chunk-encoded in HTTP/1.\n\n\nCreating a Body\n\n\nEmpty bodies can be created using the empty initializer \nBody()\n.\nAlternatively you can provide \nData\n or \nDispatchData\n as the content of the body.\n\n\nHTTPBodyRepresentable\n\n\nIf you want to serialize your data to a body using a predefined format such as JSON or XML, look into \nContent\n first.\n\n\nWhen adding a new struct/class that can be serialized to a raw Body as part of a Request or Response you can consider implementing the \nHTTPBodyRepresentable\n protocol.\n\n\nBelow is how String is implemented.\n\n\n/// String can be represented as an HTTP body.\n\n\nextension\n \nString\n:\n \nHTTPBodyRepresentable\n \n{\n\n    \n/// See BodyRepresentable.makeBody()\n\n    \npublic\n \nfunc\n \nmakeBody\n()\n \nthrows\n \n-\n \nHTTPBody\n \n{\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAlthough often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "Body"
        }, 
        {
            "location": "/http/body/#httpbody", 
            "text": "HTTPBody is a type that contains the raw representation of a  Request  or  Response . It's contents are related to the  Content-Type  header.  Body can contain, but is not limited to  Data ,  String ,  DispatchData  or binary streams.\nBinary streams will be chunk-encoded in HTTP/1.", 
            "title": "HTTPBody"
        }, 
        {
            "location": "/http/body/#creating-a-body", 
            "text": "Empty bodies can be created using the empty initializer  Body() .\nAlternatively you can provide  Data  or  DispatchData  as the content of the body.", 
            "title": "Creating a Body"
        }, 
        {
            "location": "/http/body/#httpbodyrepresentable", 
            "text": "If you want to serialize your data to a body using a predefined format such as JSON or XML, look into  Content  first.  When adding a new struct/class that can be serialized to a raw Body as part of a Request or Response you can consider implementing the  HTTPBodyRepresentable  protocol.  Below is how String is implemented.  /// String can be represented as an HTTP body.  extension   String :   HTTPBodyRepresentable   { \n     /// See BodyRepresentable.makeBody() \n     public   func   makeBody ()   throws   -   HTTPBody   { \n\n     }  }   Although often unnecessary it is possible to throw an error here if the creation of the body failed.", 
            "title": "HTTPBodyRepresentable"
        }, 
        {
            "location": "/http/client/", 
            "text": "HTTP Client\n\n\nHTTP Clients are often used to communicate with external APIs such as PayPal, Stripe or Mailgun.\n\n\nConnecting\n\n\nConnecting only requires a hostname and a boolean indicating if you want to use SSL. For almost every use case it is recommended to use SSL. If you're processing any sensitive data such as payments, emails and other personal data you will need to use SSL by setting it to \ntrue\n.\n\n\nHTTP clients require an eventloop to run on. The \nEventLoop\n is described in \nthe async concepts introduction\n.\n\n\n// Future\nHTTPClient\n\n \nlet\n \nclient\n \n=\n \ntry\n \nHTTPClient\n.\nconnect\n(\n\n    \nto\n:\n \nexample.com\n,\n\n    \nssl\n:\n \ntrue\n,\n\n    \non\n:\n \neventLoop\n\n \n)\n\n\n\n\n\n\nYou can override the port by specifying a custom port using the following parameters:\n\n\n// Future\nHTTPClient\n\n \nlet\n \nclient\n \n=\n \ntry\n \nHTTPClient\n.\nconnect\n(\n\n    \nto\n:\n \nlocalhost\n,\n\n    \nport\n:\n \n8080\n,\n\n    \nssl\n:\n \nfalse\n,\n\n    \non\n:\n \neventLoop\n\n \n)\n\n\n\n\n\n\nSending Requests\n\n\nFrom here, you can send \nRequests\n. You can only send one request at a time. Sending a request before a \nResponse\n has been received has unpredictable consequences.\n\n\n// Future\nResponse\n\n\nlet\n \nresponse\n \n=\n \nclient\n.\nflatMap\n \n{\n \nconnectedClient\n \nin\n\n  \nlet\n \nrequest\n \n=\n \nRequest\n(\n\n    \nmethod\n:\n \n.\nget\n,\n\n    \nuri\n:\n \nhttps://example.com/\n\n  \n)\n\n\n  \nreturn\n \nconnectedClient\n.\nsend\n(\nrequest\n:\n \nrequest\n)\n\n\n}", 
            "title": "Client"
        }, 
        {
            "location": "/http/client/#http-client", 
            "text": "HTTP Clients are often used to communicate with external APIs such as PayPal, Stripe or Mailgun.", 
            "title": "HTTP Client"
        }, 
        {
            "location": "/http/client/#connecting", 
            "text": "Connecting only requires a hostname and a boolean indicating if you want to use SSL. For almost every use case it is recommended to use SSL. If you're processing any sensitive data such as payments, emails and other personal data you will need to use SSL by setting it to  true .  HTTP clients require an eventloop to run on. The  EventLoop  is described in  the async concepts introduction .  // Future HTTPClient \n  let   client   =   try   HTTPClient . connect ( \n     to :   example.com , \n     ssl :   true , \n     on :   eventLoop \n  )   You can override the port by specifying a custom port using the following parameters:  // Future HTTPClient \n  let   client   =   try   HTTPClient . connect ( \n     to :   localhost , \n     port :   8080 , \n     ssl :   false , \n     on :   eventLoop \n  )", 
            "title": "Connecting"
        }, 
        {
            "location": "/http/client/#sending-requests", 
            "text": "From here, you can send  Requests . You can only send one request at a time. Sending a request before a  Response  has been received has unpredictable consequences.  // Future Response  let   response   =   client . flatMap   {   connectedClient   in \n   let   request   =   Request ( \n     method :   . get , \n     uri :   https://example.com/ \n   ) \n\n   return   connectedClient . send ( request :   request )  }", 
            "title": "Sending Requests"
        }, 
        {
            "location": "/http/cookies/", 
            "text": "Cookies\n\n\nCookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.\n\n\nCreating cookies\n\n\nVapor has three related objects for Cookies.\n\n\nThe \nCookies\n object is an array of multiple Cookie objects.\n\n\nThe \nCookie\n object is a single key-value pair. Where the key is the Cookie name.\n\n\nThe \nValue\n object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.\n\n\nValues\n\n\nValues can be initialized with a String Literal.\n\n\nvar\n \nvalue\n:\n \nCookie\n.\nValue\n \n=\n \nString Literal\n\n\n\n\n\n\nThey can be manipulated to add other properties.\n\n\n// Expires in one day\n\n\nvalue\n.\nexpires\n \n=\n \nDate\n().\naddingTimeInterval\n(\n24\n \n*\n \n3600\n)\n\n\n\n\n\n\nA single Cookie\n\n\nCreating a \nCookie\n requires a name and a Value.\n\n\nlet\n \ncookie\n \n=\n \nCookie\n(\nnamed\n:\n \nsession\n,\n \nvalue\n:\n \nvalue\n)\n\n\n\n\n\n\nMultiple cookies\n\n\nCookies\n can be initialized with a dictionary literal.\n\n\nlet\n \ncookies\n:\n \nCookies\n \n=\n \n[\n\n  \nsession\n:\n \nString Literal\n\n\n]\n\n\n\n\n\n\nThe above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#cookies", 
            "text": "Cookies are used to store data on the client-side between multiple requests. They're often used for keeping track of a user for various reasons. One of the more important purposes is to store a session cookie containing identification of an account.", 
            "title": "Cookies"
        }, 
        {
            "location": "/http/cookies/#creating-cookies", 
            "text": "Vapor has three related objects for Cookies.  The  Cookies  object is an array of multiple Cookie objects.  The  Cookie  object is a single key-value pair. Where the key is the Cookie name.  The  Value  object contains a String representing the Cookie's Value and optional attributes with metadata such as the expiration date of the Cookie.", 
            "title": "Creating cookies"
        }, 
        {
            "location": "/http/cookies/#values", 
            "text": "Values can be initialized with a String Literal.  var   value :   Cookie . Value   =   String Literal   They can be manipulated to add other properties.  // Expires in one day  value . expires   =   Date (). addingTimeInterval ( 24   *   3600 )", 
            "title": "Values"
        }, 
        {
            "location": "/http/cookies/#a-single-cookie", 
            "text": "Creating a  Cookie  requires a name and a Value.  let   cookie   =   Cookie ( named :   session ,   value :   value )", 
            "title": "A single Cookie"
        }, 
        {
            "location": "/http/cookies/#multiple-cookies", 
            "text": "Cookies  can be initialized with a dictionary literal.  let   cookies :   Cookies   =   [ \n   session :   String Literal  ]   The above will create a single cookie named \"session\" with a value of \"String Literal\".", 
            "title": "Multiple cookies"
        }, 
        {
            "location": "/http/headers/", 
            "text": "Headers\n\n\nHTTP Headers are the metadata of a request/response. They can provide a wide variety of information.\n\n\nHeaders\n are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.\n\n\nCreating a Headers object\n\n\nThe most common syntax for creating Headers is a dictionary literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nThe left hand side (key) is a \nHeader.Name\n.\n\n\nA name can also be initialized with a String literal.\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \nContent-Type\n:\n \ntext/html\n\n\n]\n\n\n\n\n\n\nAccessing headers\n\n\nThere are two ways to access Headers. Either by accessing a single (the first) value, or all values.\n\n\nA single value example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\ncontentType\n:\n \ntext/html\n\n\n]\n\n\n\nprint\n(\nheaders\n[.\ncontentType\n])\n \n// prints \ntext/html\n\n\n\n\n\n\nAccessing all values example:\n\n\nlet\n \nheaders\n:\n \nHeaders\n \n=\n \n[\n\n  \n.\nsetCookie\n:\n \nsession=afasfwrw3qr241j4qwmdsijfo13k43\n,\n\n  \n.\nsetCookie\n:\n \nawesome=true\n\n\n]\n\n\n\n// prints [\nsession=afasfwrw3qr241j4qwmdsijfo13k43\n, \nawesome=true\n]\n\n\nprint\n(\nheaders\n[\nvaluesFor\n:\n \n.\ncontentType\n])", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#headers", 
            "text": "HTTP Headers are the metadata of a request/response. They can provide a wide variety of information.  Headers  are an array of key-value pairs. As such it's possible, but not common for multiple pairs to have the same key.", 
            "title": "Headers"
        }, 
        {
            "location": "/http/headers/#creating-a-headers-object", 
            "text": "The most common syntax for creating Headers is a dictionary literal.  let   headers :   Headers   =   [ \n   . contentType :   text/html  ]   The left hand side (key) is a  Header.Name .  A name can also be initialized with a String literal.  let   headers :   Headers   =   [ \n   Content-Type :   text/html  ]", 
            "title": "Creating a Headers object"
        }, 
        {
            "location": "/http/headers/#accessing-headers", 
            "text": "There are two ways to access Headers. Either by accessing a single (the first) value, or all values.", 
            "title": "Accessing headers"
        }, 
        {
            "location": "/http/headers/#a-single-value-example", 
            "text": "let   headers :   Headers   =   [ \n   . contentType :   text/html  ]  print ( headers [. contentType ])   // prints  text/html", 
            "title": "A single value example:"
        }, 
        {
            "location": "/http/headers/#accessing-all-values-example", 
            "text": "let   headers :   Headers   =   [ \n   . setCookie :   session=afasfwrw3qr241j4qwmdsijfo13k43 , \n   . setCookie :   awesome=true  ]  // prints [ session=afasfwrw3qr241j4qwmdsijfo13k43 ,  awesome=true ]  print ( headers [ valuesFor :   . contentType ])", 
            "title": "Accessing all values example:"
        }, 
        {
            "location": "/http/method/", 
            "text": "Method\n\n\nMethods are used to indicate the type of operation requested for a route. They're part exclusively in \nHTTP Requests\n and are required.\n\n\n\n\n\n\n\n\nMethod\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\n.get\n\n\nUsed for retrieving content\n\n\n\n\n\n\n.head\n\n\nUsed for retrieving content metadata\n\n\n\n\n\n\n.put\n\n\nUsed for replacing content\n\n\n\n\n\n\n.post\n\n\nUsed for creating content\n\n\n\n\n\n\n.delete\n\n\nUsed for deleting content\n\n\n\n\n\n\n\n\nA \npath\n is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Methods"
        }, 
        {
            "location": "/http/method/#method", 
            "text": "Methods are used to indicate the type of operation requested for a route. They're part exclusively in  HTTP Requests  and are required.     Method  Purpose      .get  Used for retrieving content    .head  Used for retrieving content metadata    .put  Used for replacing content    .post  Used for creating content    .delete  Used for deleting content     A  path  is used for specifying a specific resource/content. The method influences the type of interaction with this resource/content.", 
            "title": "Method"
        }, 
        {
            "location": "/http/middleware/", 
            "text": "Middleware\n\n\nMiddleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.\n\n\nThey can be employed for authorization checks, logging and a wide range of other functionalities.\n\n\nImplementing a Middleware\n\n\nThe following example is a middleware that will prevent all \nrequests\n from going to their respective \nresponder\n unless the origin has a special header set. In the case of a missing header, \nstatus code\n 404 (not found) will be returned.\n\n\nDon't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.\n\n\npublic\n \nfinal\n \nclass\n \nSpecialHeaderCheckMiddleware\n:\n \nMiddleware\n \n{\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nguard\n \nrequest\n.\nheaders\n[\nSecret-Header\n]\n \n==\n \nMagicK3y\n \nelse\n \n{\n\n      \nreturn\n \nResponse\n(\nstatus\n:\n \n.\nnotFound\n)\n\n    \n}\n\n\n    \nreturn\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIntercepting/transforming Responses\n\n\nThe following example demonstrates a middleware that creates a session token for new users.\n\n\n// For the random number\n\n\nimport\n \nCrypto\n\n\n\nstruct\n \nInvalidString\n \n:\n \nSwift\n.\nError\n \n{}\n\n\n\npublic\n \nfinal\n \nclass\n \nSessionTokenMiddleware\n:\n \nMiddleware\n \n{\n\n  \nfunc\n \ngenerateSessionToken\n()\n \nthrows\n \n-\n \nString\n \n{\n\n    \n// Generate token here ...\n\n    \nlet\n \nbase64\n \n=\n \nBase64Encoder\n.\nencode\n(\nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n))\n\n\n    \n// Convert to a String\n\n    \nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nbase64\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n      \n// This can never happen, but throw an error anyways\n\n      \nthrow\n \nInvalidString\n()\n\n    \n}\n\n\n    \nreturn\n \nstring\n\n  \n}\n\n\n  \npublic\n \nfunc\n \nrespond\n(\nto\n \nrequest\n:\n \nRequest\n,\n \nchainingTo\n \nnext\n:\n \nResponder\n)\n \nthrows\n \n-\n \nFuture\nResponse\n \n{\n\n    \nlet\n \nresponse\n \n=\n \ntry\n \nnext\n.\nrespond\n(\nto\n:\n \nrequest\n)\n\n\n    \n// If the session cookie is not set\n\n    \nguard\n \nrequest\n.\ncookies\n[\nsession\n]\n \n!=\n \nnil\n \nelse\n \n{\n\n      \n// Set a new session token\n\n      \nresponse\n.\ncookies\n[\nsession\n]\n \n=\n \ntry\n \ngenerateSessionToken\n()\n\n\n      \nreturn\n \nresponse\n\n    \n}\n\n\n    \nreturn\n \nresponse\n\n  \n}\n\n\n}", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#middleware", 
            "text": "Middleware are a step in Vapor's responder chain. They're capable of modifying Requests/Responses, preventing the chain from continuing and transforming the data flow.  They can be employed for authorization checks, logging and a wide range of other functionalities.", 
            "title": "Middleware"
        }, 
        {
            "location": "/http/middleware/#implementing-a-middleware", 
            "text": "The following example is a middleware that will prevent all  requests  from going to their respective  responder  unless the origin has a special header set. In the case of a missing header,  status code  404 (not found) will be returned.  Don't secure your APIs using this example code, it's very unsafe and exclusively to be used as a test.  public   final   class   SpecialHeaderCheckMiddleware :   Middleware   { \n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     guard   request . headers [ Secret-Header ]   ==   MagicK3y   else   { \n       return   Response ( status :   . notFound ) \n     } \n\n     return   try   next . respond ( to :   request ) \n   }  }", 
            "title": "Implementing a Middleware"
        }, 
        {
            "location": "/http/middleware/#interceptingtransforming-responses", 
            "text": "The following example demonstrates a middleware that creates a session token for new users.  // For the random number  import   Crypto  struct   InvalidString   :   Swift . Error   {}  public   final   class   SessionTokenMiddleware :   Middleware   { \n   func   generateSessionToken ()   throws   -   String   { \n     // Generate token here ... \n     let   base64   =   Base64Encoder . encode ( OSRandom (). data ( count :   32 )) \n\n     // Convert to a String \n     guard   let   string   =   String ( bytes :   base64 ,   encoding :   . utf8 )   else   { \n       // This can never happen, but throw an error anyways \n       throw   InvalidString () \n     } \n\n     return   string \n   } \n\n   public   func   respond ( to   request :   Request ,   chainingTo   next :   Responder )   throws   -   Future Response   { \n     let   response   =   try   next . respond ( to :   request ) \n\n     // If the session cookie is not set \n     guard   request . cookies [ session ]   !=   nil   else   { \n       // Set a new session token \n       response . cookies [ session ]   =   try   generateSessionToken () \n\n       return   response \n     } \n\n     return   response \n   }  }", 
            "title": "Intercepting/transforming Responses"
        }, 
        {
            "location": "/http/multipart/", 
            "text": "Multipart Forms\n\n\nMultipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.\n\n\nExtracting from a request\n\n\nMultipartForm\n is a type of \nContent\n and can be extracted like any type of Content.\n\n\nlet\n \nform\n \n=\n \ntry\n \nMultipartForm\n.\ndecode\n(\nfrom\n:\n \nrequest\n)\n \n// Future\nMultipartForm\n\n\n\n\n\n\nA future is returned because of streaming/reactive body parsing.\n\n\nParsing a multipart form\n\n\nMultipart forms can be parsed using \nMultipartParser\n provided a body and boundary to read.\n\n\nlet\n \nform\n \n=\n \ntry\n \nMultipartParser\n(\nbody\n:\n \nhttpBody\n,\n \nboundary\n:\n \nboundaryBytes\n).\nparse\n()\n\n\n\n\n\n\nReading forms\n\n\nThe parsed form is an array of \nPart\n instances.\nEach of them contains data and headers.\n\n\nYou can read a part using either manually or using the \nMultipartForm\n's helpers.\n\n\nlet\n \npictureData\n \n=\n \ntry\n \nform\n.\ngetFile\n(\nnamed\n:\n \nprofile-picture\n)\n\n\n\n\n\n\nlet\n \nnewPassword\n \n=\n \ntry\n \nform\n.\ngetString\n(\nnamed\n:\n \npassword\n)", 
            "title": "Multipart"
        }, 
        {
            "location": "/http/multipart/#multipart-forms", 
            "text": "Multipart is a module that is primarily used with Forms. Multipart is used for complex forms containing one or more files, input fields and other HTML form data.", 
            "title": "Multipart Forms"
        }, 
        {
            "location": "/http/multipart/#extracting-from-a-request", 
            "text": "MultipartForm  is a type of  Content  and can be extracted like any type of Content.  let   form   =   try   MultipartForm . decode ( from :   request )   // Future MultipartForm   A future is returned because of streaming/reactive body parsing.", 
            "title": "Extracting from a request"
        }, 
        {
            "location": "/http/multipart/#parsing-a-multipart-form", 
            "text": "Multipart forms can be parsed using  MultipartParser  provided a body and boundary to read.  let   form   =   try   MultipartParser ( body :   httpBody ,   boundary :   boundaryBytes ). parse ()", 
            "title": "Parsing a multipart form"
        }, 
        {
            "location": "/http/multipart/#reading-forms", 
            "text": "The parsed form is an array of  Part  instances.\nEach of them contains data and headers.  You can read a part using either manually or using the  MultipartForm 's helpers.  let   pictureData   =   try   form . getFile ( named :   profile-picture )   let   newPassword   =   try   form . getString ( named :   password )", 
            "title": "Reading forms"
        }, 
        {
            "location": "/http/status/", 
            "text": "Status codes\n\n\nStatus codes are exclusively part of the \nHTTP Response\n and are required.\n\n\nStatus codes are a 3 digit number.\n\n\nThe first of the 3 numbers indicated the type of response.\n\n\n\n\n\n\n\n\n_xx\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n1xx\n\n\nInformational response\n\n\n\n\n\n\n2xx\n\n\nSuccess\n\n\n\n\n\n\n3xx\n\n\nRedirection\n\n\n\n\n\n\n4xx\n\n\nClient error\n\n\n\n\n\n\n5xx\n\n\nServer error\n\n\n\n\n\n\n\n\nThe other 2 numbers in a status code are used to define a specific code.\n\n\nSelecting a status code\n\n\nThe enum \nStatus\n has all supported status codes. It can be accessed using a \n.\n or created using an integer literal.\n\n\nlet\n \nok\n \n=\n \nStatus\n.\nok\n\n\nlet\n \nnotFound\n \n=\n \nStatus\n.\nnotFound\n\n\n\n\n\n\nlet\n \nok\n:\n \nStatus\n \n=\n \n200\n\n\nlet\n \nnotFound\n:\n \nStatus\n \n=\n \n404\n\n\n\n\n\n\nInformational responses\n\n\nInformational responses indicate a \nRequest\n was received and understood.\n\n\n101 - switching protocols\n\n\nSwitching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by \nWebSocket\n or HTTP/2.\n\n\nSuccess responses\n\n\nSuccess responses indicate that the request was received, understood, accepted and processed.\n\n\n200 - OK\n\n\n200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.\n\n\nRedirection responses\n\n\nRedirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.\n\n\nClient error responses\n\n\nClient errors indicate an error was caused by the client.\n\n\n400 - Bad Request\n\n\nThe error was caused by the client sending an invalid request.\n\n\nFor example an invalid message, malformed request syntax or too large request size.\n\n\n403 - Forbidden\n\n\nThe client does not have the permissions to execute this operation on the specified resource.\n\n\n404 - Not found\n\n\nThe requested resource does not exist.\n\n\nServer error responses\n\n\nServer errors occur when the an error occurred on the server side.\n\n\n500 - Internal Server Error\n\n\nInternal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#status-codes", 
            "text": "Status codes are exclusively part of the  HTTP Response  and are required.  Status codes are a 3 digit number.  The first of the 3 numbers indicated the type of response.     _xx  Meaning      1xx  Informational response    2xx  Success    3xx  Redirection    4xx  Client error    5xx  Server error     The other 2 numbers in a status code are used to define a specific code.", 
            "title": "Status codes"
        }, 
        {
            "location": "/http/status/#selecting-a-status-code", 
            "text": "The enum  Status  has all supported status codes. It can be accessed using a  .  or created using an integer literal.  let   ok   =   Status . ok  let   notFound   =   Status . notFound   let   ok :   Status   =   200  let   notFound :   Status   =   404", 
            "title": "Selecting a status code"
        }, 
        {
            "location": "/http/status/#informational-responses", 
            "text": "Informational responses indicate a  Request  was received and understood.", 
            "title": "Informational responses"
        }, 
        {
            "location": "/http/status/#101-switching-protocols", 
            "text": "Switching Protocols is a status code used to upgrade the connection to a different protocol. Commonly used by  WebSocket  or HTTP/2.", 
            "title": "101 - switching protocols"
        }, 
        {
            "location": "/http/status/#success-responses", 
            "text": "Success responses indicate that the request was received, understood, accepted and processed.", 
            "title": "Success responses"
        }, 
        {
            "location": "/http/status/#200-ok", 
            "text": "200, or \"OK\" is the most common status code. It's used to indicate successful processing of the Request.", 
            "title": "200 - OK"
        }, 
        {
            "location": "/http/status/#redirection-responses", 
            "text": "Redirection responses indicate the client must take additional action to complete the request. Many of these status codes are used in URL redirection.", 
            "title": "Redirection responses"
        }, 
        {
            "location": "/http/status/#client-error-responses", 
            "text": "Client errors indicate an error was caused by the client.", 
            "title": "Client error responses"
        }, 
        {
            "location": "/http/status/#400-bad-request", 
            "text": "The error was caused by the client sending an invalid request.  For example an invalid message, malformed request syntax or too large request size.", 
            "title": "400 - Bad Request"
        }, 
        {
            "location": "/http/status/#403-forbidden", 
            "text": "The client does not have the permissions to execute this operation on the specified resource.", 
            "title": "403 - Forbidden"
        }, 
        {
            "location": "/http/status/#404-not-found", 
            "text": "The requested resource does not exist.", 
            "title": "404 - Not found"
        }, 
        {
            "location": "/http/status/#server-error-responses", 
            "text": "Server errors occur when the an error occurred on the server side.", 
            "title": "Server error responses"
        }, 
        {
            "location": "/http/status/#500-internal-server-error", 
            "text": "Internal server errors are almost exclusively used when an error occurred on the server.", 
            "title": "500 - Internal Server Error"
        }, 
        {
            "location": "/http/uri/", 
            "text": "URI\n\n\nURIs or \"Uniform Resource Identifiers\" are used for defining a resource.\n\n\nThey consist of the following components:\n\n\n\n\nscheme\n\n\nauthority\n\n\npath\n\n\nquery\n\n\nfragment\n\n\n\n\nCreating an URI\n\n\nURIs can be created from it's initializer or from a String literal.\n\n\nlet\n \nstringLiteralURI\n:\n \nURI\n \n=\n \nhttp://localhost:8080/path\n\n\nlet\n \nmanualURI\n:\n \nURI\n \n=\n \nURI\n(\n\n    \nscheme\n:\n \nhttp\n,\n\n    \nhostname\n:\n \nlocalhost\n,\n\n    \nport\n:\n \n8080\n,\n\n    \npath\n:\n \n/path\n\n\n)", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#uri", 
            "text": "URIs or \"Uniform Resource Identifiers\" are used for defining a resource.  They consist of the following components:   scheme  authority  path  query  fragment", 
            "title": "URI"
        }, 
        {
            "location": "/http/uri/#creating-an-uri", 
            "text": "URIs can be created from it's initializer or from a String literal.  let   stringLiteralURI :   URI   =   http://localhost:8080/path  let   manualURI :   URI   =   URI ( \n     scheme :   http , \n     hostname :   localhost , \n     port :   8080 , \n     path :   /path  )", 
            "title": "Creating an URI"
        }, 
        {
            "location": "/redis/getting-started/", 
            "text": "Redis\n\n\nRedis is a Redis client library that can communicate with a Redis database.\n\n\nWhat is Redis?\n\n\nRedis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).\n\n\nRedis works as a key-value store, but allows querying the keys, unlike most databases.\n\n\nWith and without Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/redis.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \n3.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nRedis\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nIf this is your first time adding a dependency, you should read our introduction to \nPackage.swift\n.\n\n\nUse \nimport Redis\n to access Redis' APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/redis/getting-started/#redis", 
            "text": "Redis is a Redis client library that can communicate with a Redis database.", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/getting-started/#what-is-redis", 
            "text": "Redis is an in-memory data store used as a database, cache and message broker. It supports most common data structures. Redis is most commonly used for caching data such as sessions and notifications (between multiple servers).  Redis works as a key-value store, but allows querying the keys, unlike most databases.", 
            "title": "What is Redis?"
        }, 
        {
            "location": "/redis/getting-started/#with-and-without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/redis.git ,   . upToNextMajor ( from :   3.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Redis ,   ...   ]) \n     ]  )   If this is your first time adding a dependency, you should read our introduction to  Package.swift .  Use  import Redis  to access Redis' APIs.", 
            "title": "With and without Vapor"
        }, 
        {
            "location": "/redis/basics/", 
            "text": "Redis basic usage\n\n\nTo interact with Redis, you first need to construct a Redis client.\nThe Redis library primarily supports \nTCP sockets\n.\n\n\nThis requires a hostname, port and \nWorker\n. The eventloop will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to \nlocalhost\n, and the port to Redis' default port \n6379\n.\n\n\nlet\n \nclient\n \n=\n \ntry\n \nRedisClient\n.\nconnect\n(\non\n:\n \nworker\n)\n \n// Future\nRedisClient\n\n\n\n\n\n\nThe \nconnect\n method will return a \nFuture\n containing the TCP based Redis Client.\n\n\nRedis Data Types\n\n\nRedis has 6 data types:\n\n\n\n\nnull\n\n\nInt\n\n\nError\n\n\nArray\n\n\nBasic String (used for command names and basic replies only)\n\n\nBulk String (used for Strings and binary data blobs)\n\n\n\n\nYou can instantiate one from the static functions and variables on \nRedisData\n.\n\n\nlet\n \nnull\n \n=\n \nRedisData\n.\nnull\n\n\n\nlet\n \nhelloWorld\n \n=\n \nRedisData\n.\nbulkString\n(\nHello World\n)\n\n\n\nlet\n \nthree\n \n=\n \nRedisData\n.\ninteger\n(\n3\n)\n\n\n\nlet\n \noneThroughTen\n \n=\n \nRedisData\n.\narray\n([\n\n  \n.\ninteger\n(\n1\n),\n\n  \n.\ninteger\n(\n2\n),\n\n  \n.\ninteger\n(\n3\n),\n\n  \n.\ninteger\n(\n4\n),\n\n  \n.\ninteger\n(\n5\n),\n\n  \n.\ninteger\n(\n6\n),\n\n  \n.\ninteger\n(\n7\n),\n\n  \n.\ninteger\n(\n8\n),\n\n  \n.\ninteger\n(\n9\n),\n\n  \n.\ninteger\n(\n10\n)\n\n\n])\n\n\n\n\n\n\nThe above is the explicit way of defining Redis Types. You can also use literals in most scenarios:\n\n\nlet\n \narray\n \n=\n \nRedisData\n.\narray\n([\n\n  \n[\n\n    \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n\n  \n],\n\n  \nHello World\n,\n\n  \nOne\n,\n\n  \nTwo\n,\n\n  \n.\nnull\n,\n\n  \n.\nnull\n,\n\n  \ntest\n\n\n])\n\n\n\n\n\n\nCRUD using Redis\n\n\nFrom here on it is assumed that your client has been successfully created and is available in the variable \nclient\n as a \nRedisClient\n.\n\n\nCreating a record\n\n\nCreating a record is done using a \nRedisData\n for a value and a key.\n\n\nclient\n.\nset\n(\nworld\n,\n \nforKey\n:\n \nhello\n)\n\n\n\n\n\n\nThis returns a future that'll indicate successful or unsuccessful insertion.\n\n\nReading a record\n\n\nReading a record is similar, only you'll get a warning if you don't use the returned future.\n\n\nThe \nFuture\nRedisData\n for the key \"hello\" will be \"world\" if you created the record as shown above.\n\n\nlet\n \nfutureRecord\n \n=\n \nclient\n.\ngetData\n(\nforKey\n:\n \nhello\n)\n \n// Future\nRedisData\n\n\n\n\n\n\nDeleting a record\n\n\nDeleting a record is similar but allows querying the keys, too.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\nhello\n])\n\n\n\n\n\n\nWhere the above command will remove the key \"hello\", the next command will delete \nall\n keys from the Redis database.\n\n\nclient\n.\ndelete\n(\nkeys\n:\n \n[\n*\n])", 
            "title": "Basics"
        }, 
        {
            "location": "/redis/basics/#redis-basic-usage", 
            "text": "To interact with Redis, you first need to construct a Redis client.\nThe Redis library primarily supports  TCP sockets .  This requires a hostname, port and  Worker . The eventloop will be used for Redis' Socket. The hostname and port have a default. The hostname is defaulted to  localhost , and the port to Redis' default port  6379 .  let   client   =   try   RedisClient . connect ( on :   worker )   // Future RedisClient   The  connect  method will return a  Future  containing the TCP based Redis Client.", 
            "title": "Redis basic usage"
        }, 
        {
            "location": "/redis/basics/#redis-data-types", 
            "text": "Redis has 6 data types:   null  Int  Error  Array  Basic String (used for command names and basic replies only)  Bulk String (used for Strings and binary data blobs)   You can instantiate one from the static functions and variables on  RedisData .  let   null   =   RedisData . null  let   helloWorld   =   RedisData . bulkString ( Hello World )  let   three   =   RedisData . integer ( 3 )  let   oneThroughTen   =   RedisData . array ([ \n   . integer ( 1 ), \n   . integer ( 2 ), \n   . integer ( 3 ), \n   . integer ( 4 ), \n   . integer ( 5 ), \n   . integer ( 6 ), \n   . integer ( 7 ), \n   . integer ( 8 ), \n   . integer ( 9 ), \n   . integer ( 10 )  ])   The above is the explicit way of defining Redis Types. You can also use literals in most scenarios:  let   array   =   RedisData . array ([ \n   [ \n     1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ,   10 \n   ], \n   Hello World , \n   One , \n   Two , \n   . null , \n   . null , \n   test  ])", 
            "title": "Redis Data Types"
        }, 
        {
            "location": "/redis/basics/#crud-using-redis", 
            "text": "From here on it is assumed that your client has been successfully created and is available in the variable  client  as a  RedisClient .", 
            "title": "CRUD using Redis"
        }, 
        {
            "location": "/redis/basics/#creating-a-record", 
            "text": "Creating a record is done using a  RedisData  for a value and a key.  client . set ( world ,   forKey :   hello )   This returns a future that'll indicate successful or unsuccessful insertion.", 
            "title": "Creating a record"
        }, 
        {
            "location": "/redis/basics/#reading-a-record", 
            "text": "Reading a record is similar, only you'll get a warning if you don't use the returned future.  The  Future RedisData  for the key \"hello\" will be \"world\" if you created the record as shown above.  let   futureRecord   =   client . getData ( forKey :   hello )   // Future RedisData", 
            "title": "Reading a record"
        }, 
        {
            "location": "/redis/basics/#deleting-a-record", 
            "text": "Deleting a record is similar but allows querying the keys, too.  client . delete ( keys :   [ hello ])   Where the above command will remove the key \"hello\", the next command will delete  all  keys from the Redis database.  client . delete ( keys :   [ * ])", 
            "title": "Deleting a record"
        }, 
        {
            "location": "/redis/custom-commands/", 
            "text": "Custom commands\n\n\nMany commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.\n\n\n(Almost) all functions listed here\n work out of the box using custom commands.\n\n\nUsage\n\n\nThe Redis client has a \nrun\n function that allows you to run these commands.\n\n\nThe following code demonstrates a \"custom\" implementation for \nGET\n.\n\n\nlet\n \nfuture\n \n=\n \nclient\n.\nrun\n(\ncommand\n:\n \nGET\n,\n \narguments\n:\n \n[\nmy-key\n])\n \n// Future\nRedisData\n\n\n\n\n\n\nThis future will contain the result as specified in the article on the redis command page or an error.\n\n\nThe future can be used as described in the \nAsync API\n.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#custom-commands", 
            "text": "Many commands are not (yet) implemented by the driver using a convenience function. This does not mean the feature/command is not usable.  (Almost) all functions listed here  work out of the box using custom commands.", 
            "title": "Custom commands"
        }, 
        {
            "location": "/redis/custom-commands/#usage", 
            "text": "The Redis client has a  run  function that allows you to run these commands.  The following code demonstrates a \"custom\" implementation for  GET .  let   future   =   client . run ( command :   GET ,   arguments :   [ my-key ])   // Future RedisData   This future will contain the result as specified in the article on the redis command page or an error.  The future can be used as described in the  Async API .", 
            "title": "Usage"
        }, 
        {
            "location": "/redis/pub-sub/", 
            "text": "Publish \n Subscribe\n\n\nRedis' Publish and Subscribe model is really useful for notifications.\n\n\nUse cases\n\n\nPub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.\n\n\nA channel consists of a name and group of listeners. Think of it as being \n[String: [Listener]]\n.\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.\n\n\nChannels must be a string. For chat groups, for example, you could use the database identifier.\n\n\nPublishing\n\n\nYou cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:\n\n\n// Any redis data\n\n\nlet\n \nnotification\n:\n \nRedisData\n \n=\n \nMy-Notification\n\n\n\nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n\n\n\n\n\n\nIf you want access to the listener count:\n\n\nlet\n \nnotifiedCount\n \n=\n \nclient\n.\npublish\n(\nnotification\n,\n \nto\n:\n \nmy-channel\n)\n \n// Future\nInt\n\n\n\n\n\n\nSubscribing\n\n\nTo subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.\n\n\nA single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a \nSubscriptionStream\n.\n\n\nlet\n \nnotifications\n \n=\n \nclient\n.\nsubscribe\n(\nto\n:\n \n[\nsome-notification-channel\n,\n \nother-notification-channel\n])\n\n\n\n\n\n\nIf you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.\n\n\nThis stream will receive messages asynchronously from the point of \ndraining\n. This works like \nany other async stream\n\n\nNotifications consist of the channel and payload.\n\n\nnotifications\n.\ndrain\n \n{\n \nnotification\n \nin\n\n  \nprint\n(\nnotification\n.\nchannel\n)\n\n\n  \nlet\n \npayload\n \n=\n \nnotification\n.\npayload\n\n\n  \n// \nTODO:\n Process the payload\n\n\n}", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#publish-subscribe", 
            "text": "Redis' Publish and Subscribe model is really useful for notifications.", 
            "title": "Publish &amp; Subscribe"
        }, 
        {
            "location": "/redis/pub-sub/#use-cases", 
            "text": "Pub/sub is used for notifying subscribers of an event.\nA simple and common event for example would be a chat message.  A channel consists of a name and group of listeners. Think of it as being  [String: [Listener]] .\nWhen you send a notification to a channel you need to provide a payload.\nEach listener will get a notification consisting of this payload.  Channels must be a string. For chat groups, for example, you could use the database identifier.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pub-sub/#publishing", 
            "text": "You cannot get a list of listeners, but sending a payload will emit the amount of listeners that received the notification.\nSending (publishing) an event is done like so:  // Any redis data  let   notification :   RedisData   =   My-Notification  client . publish ( notification ,   to :   my-channel )   If you want access to the listener count:  let   notifiedCount   =   client . publish ( notification ,   to :   my-channel )   // Future Int", 
            "title": "Publishing"
        }, 
        {
            "location": "/redis/pub-sub/#subscribing", 
            "text": "To subscribe for notifications you're rendering an entire Redis Client useless in exchange for listening to events.  A single client can listen to one or more channels, which is provided using a set of unique channel names. The result of subscribing is a  SubscriptionStream .  let   notifications   =   client . subscribe ( to :   [ some-notification-channel ,   other-notification-channel ])   If you try to use the client after subscribing, all operations will fail. These errors are usually emitted through the Future.  This stream will receive messages asynchronously from the point of  draining . This works like  any other async stream  Notifications consist of the channel and payload.  notifications . drain   {   notification   in \n   print ( notification . channel ) \n\n   let   payload   =   notification . payload \n\n   //  TODO:  Process the payload  }", 
            "title": "Subscribing"
        }, 
        {
            "location": "/redis/pipeline/", 
            "text": "Pipelining\n\n\nPipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle. \n\n\nUse cases\n\n\nSometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.\n\n\nEnqueuing Commands\n\n\n \nlet\n \npipeline\n \n=\n \nconnection\n.\nmakePipeline\n()\n\n \nlet\n \nresult\n \n=\n \ntry\n \npipeline\n\n         \n.\nenqueue\n(\ncommand\n:\n \nSET\n,\n \narguments\n:\n \n[\nKEY\n,\n \nVALUE\n])\n\n         \n.\nenqueue\n(\ncommand\n:\n \nINCR\n,\n \narguments\n:\n \n[\nCOUNT\n])\n\n         \n.\nexecute\n()\n \n// Future\n[RedisData]\n\n\n\n\n\n\nNote: Commands will not be executed until execute is called.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/redis/pipeline/#pipelining", 
            "text": "Pipelining is used for sending multiple commands at once. The performance advantages become apparent when sending a large number of queries. Redis' pipelining cuts down latency by reducing the RTT (Round Trip Time) between the client and server. Pipelining also reduces the amount of IO operations Redis has to perform, this increases the amount of queries per second Redis can handle.", 
            "title": "Pipelining"
        }, 
        {
            "location": "/redis/pipeline/#use-cases", 
            "text": "Sometimes multiple commands need to be executed at once.  Instead of sending those commands individually in a loop, pipelining allows the commands to be batched and sent in one request. A common scenario might be needing to set a key and increment a count, pipelining those commands would be ideal.", 
            "title": "Use cases"
        }, 
        {
            "location": "/redis/pipeline/#enqueuing-commands", 
            "text": "let   pipeline   =   connection . makePipeline () \n  let   result   =   try   pipeline \n          . enqueue ( command :   SET ,   arguments :   [ KEY ,   VALUE ]) \n          . enqueue ( command :   INCR ,   arguments :   [ COUNT ]) \n          . execute ()   // Future [RedisData]   Note: Commands will not be executed until execute is called.", 
            "title": "Enqueuing Commands"
        }, 
        {
            "location": "/websocket/websocket/", 
            "text": "WebSocket\n\n\nWebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1.1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.\n\n\nVapor 3 supports both WebSocket Clients and server-side sockets.\n\n\nServer side Sockets\n\n\nVapor 3 adds a helper to routing that helps accepting clients.\n\n\nimport\n \nWebSocket\n\n\n\nrouting\n.\nwebsocket\n(\napi/v1/websocket\n)\n \n{\n \nreq\n,\n \nwebsocket\n \nin\n\n  \n// set up the websocket\n\n\n}\n\n\n\n\n\n\nClient side sockets\n\n\nConnecting to a remote WebSocket is relatively painless. You can provide a URL and Vapor 3 will attempt to set up a connection.\n\n\nFor creating an SSL connection, however, a \ncontainer\n must be provided.\n\n\n\n\nWarning\n\n\nVapor does not retain the WebSocket. You need to keep the WebSocket active by means of strong references and pings.\n\n\n\n\nlet\n \nfutureWebSocket\n \n=\n \ntry\n \nWebSocket\n.\nconnect\n(\nto\n:\n \nws://localhost/path\n,\n \nusing\n:\n \ncontainer\n)\n \n// Future\nWebSocket\n\n\n\n\n\n\nUsing websockets\n\n\nSending strings\n\n\nSending a \nString\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nstring\n:\n \nstring\n)\n\n\n\n\n\n\nReceiving strings\n\n\nString data can be read using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonString\n \n{\n \nstring\n \nin\n\n  \n// use the `String`\n\n\n}\n\n\n\n\n\n\nSending binary data\n\n\nSending a \nData\n or \nByteBuffer\n using a WebSocket sends it to the remote.\n\n\nwebSocket\n.\nsend\n(\nbytes\n:\n \nbyteBuffer\n)\n\n\nwebSocket\n.\nsend\n(\ndata\n:\n \ndata\n)\n\n\n\n\n\n\nReceiving binary data\n\n\nBinary data can be read as a \nByteBuffer\n using the following function. Only one closure can read at a time.\n\n\nwebSocket\n.\nonByteBuffer\n \n{\n \nbyteBuffer\n \nin\n\n  \n// use the `ByteBuffer`\n\n\n}\n\n\n\n\n\n\nBinary data can also, instead, be used as Foundation's \nData\n. This is less efficient than \nByteBuffer\n but is often easier to use.\n\n\nwebSocket\n.\nonData\n \n{\n \ndata\n \nin\n\n  \n// use the `Data`\n\n\n}\n\n\n\n\n\n\nSetting a listener will override all previous listeners. You need to split into multiple listeners manually.\n\n\nErrors\n\n\nAny error in a WebSocket will close the connection. This notification will be received on the binary \nand\n text streams.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#websocket", 
            "text": "WebSockets are a type of connection that can be instantiated by upgrading an existing HTTP/1.1 connection. They're used to dispatch notifications and communicate real-time binary and textual Data.  Vapor 3 supports both WebSocket Clients and server-side sockets.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/websocket/websocket/#server-side-sockets", 
            "text": "Vapor 3 adds a helper to routing that helps accepting clients.  import   WebSocket  routing . websocket ( api/v1/websocket )   {   req ,   websocket   in \n   // set up the websocket  }", 
            "title": "Server side Sockets"
        }, 
        {
            "location": "/websocket/websocket/#client-side-sockets", 
            "text": "Connecting to a remote WebSocket is relatively painless. You can provide a URL and Vapor 3 will attempt to set up a connection.  For creating an SSL connection, however, a  container  must be provided.   Warning  Vapor does not retain the WebSocket. You need to keep the WebSocket active by means of strong references and pings.   let   futureWebSocket   =   try   WebSocket . connect ( to :   ws://localhost/path ,   using :   container )   // Future WebSocket", 
            "title": "Client side sockets"
        }, 
        {
            "location": "/websocket/websocket/#using-websockets", 
            "text": "", 
            "title": "Using websockets"
        }, 
        {
            "location": "/websocket/websocket/#sending-strings", 
            "text": "Sending a  String  using a WebSocket sends it to the remote.  webSocket . send ( string :   string )", 
            "title": "Sending strings"
        }, 
        {
            "location": "/websocket/websocket/#receiving-strings", 
            "text": "String data can be read using the following function. Only one closure can read at a time.  webSocket . onString   {   string   in \n   // use the `String`  }", 
            "title": "Receiving strings"
        }, 
        {
            "location": "/websocket/websocket/#sending-binary-data", 
            "text": "Sending a  Data  or  ByteBuffer  using a WebSocket sends it to the remote.  webSocket . send ( bytes :   byteBuffer )  webSocket . send ( data :   data )", 
            "title": "Sending binary data"
        }, 
        {
            "location": "/websocket/websocket/#receiving-binary-data", 
            "text": "Binary data can be read as a  ByteBuffer  using the following function. Only one closure can read at a time.  webSocket . onByteBuffer   {   byteBuffer   in \n   // use the `ByteBuffer`  }   Binary data can also, instead, be used as Foundation's  Data . This is less efficient than  ByteBuffer  but is often easier to use.  webSocket . onData   {   data   in \n   // use the `Data`  }   Setting a listener will override all previous listeners. You need to split into multiple listeners manually.", 
            "title": "Receiving binary data"
        }, 
        {
            "location": "/websocket/websocket/#errors", 
            "text": "Any error in a WebSocket will close the connection. This notification will be received on the binary  and  text streams.", 
            "title": "Errors"
        }, 
        {
            "location": "/services/getting-started/", 
            "text": "TODO\n\n\nRefer to the concepts/services for now", 
            "title": "Services"
        }, 
        {
            "location": "/services/getting-started/#todo", 
            "text": "Refer to the concepts/services for now", 
            "title": "TODO"
        }, 
        {
            "location": "/crypto/getting-started/", 
            "text": "Using Crypto\n\n\nCrypto is a library containing all common APIs related to cryptography and security.\n\n\nThis project does \nnot\n support TLS. For that, please see \nthe TLS package\n.\n\n\nWith Vapor\n\n\nThis package is included with Vapor by default, just add:\n\n\nimport\n \nCrypto\n\n\n\n\n\n\nWithout Vapor\n\n\nTo include it in your package, add the following to your \nPackage.swift\n file.\n\n\n// swift-tools-version:4.0\n\n\nimport\n \nPackageDescription\n\n\n\nlet\n \npackage\n \n=\n \nPackage\n(\n\n    \nname\n:\n \nProject\n,\n\n    \ndependencies\n:\n \n[\n\n        \n...\n\n        \n.\npackage\n(\nurl\n:\n \nhttps://github.com/vapor/crypto.git\n,\n \n.\nupToNextMajor\n(\nfrom\n:\n \nx.0.0\n)),\n\n    \n],\n\n    \ntargets\n:\n \n[\n\n      \n.\ntarget\n(\nname\n:\n \nProject\n,\n \ndependencies\n:\n \n[\nCrypto\n,\n \n...\n \n])\n\n    \n]\n\n\n)\n\n\n\n\n\n\nUse \nimport Crypto\n to access Crypto's APIs.", 
            "title": "Package"
        }, 
        {
            "location": "/crypto/getting-started/#using-crypto", 
            "text": "Crypto is a library containing all common APIs related to cryptography and security.  This project does  not  support TLS. For that, please see  the TLS package .", 
            "title": "Using Crypto"
        }, 
        {
            "location": "/crypto/getting-started/#with-vapor", 
            "text": "This package is included with Vapor by default, just add:  import   Crypto", 
            "title": "With Vapor"
        }, 
        {
            "location": "/crypto/getting-started/#without-vapor", 
            "text": "To include it in your package, add the following to your  Package.swift  file.  // swift-tools-version:4.0  import   PackageDescription  let   package   =   Package ( \n     name :   Project , \n     dependencies :   [ \n         ... \n         . package ( url :   https://github.com/vapor/crypto.git ,   . upToNextMajor ( from :   x.0.0 )), \n     ], \n     targets :   [ \n       . target ( name :   Project ,   dependencies :   [ Crypto ,   ...   ]) \n     ]  )   Use  import Crypto  to access Crypto's APIs.", 
            "title": "Without Vapor"
        }, 
        {
            "location": "/crypto/base64/", 
            "text": "Base64\n\n\nComing soon", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/base64/#base64", 
            "text": "Coming soon", 
            "title": "Base64"
        }, 
        {
            "location": "/crypto/hash/", 
            "text": "Hash\n\n\nHashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.\n\n\nAvailable hashes\n\n\nCrypto currently supports a few hashes.\n\n\n\n\nMD5\n\n\nSHA1\n\n\nSHA2 (all variants)\n\n\n\n\nMD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.\n\n\nEvery Hash type has a set of helpers that you can use.\n\n\nHashing blobs of data\n\n\nEvery \nHash\n has a static method called \nhash\n that can be used for hashing the entire contents of \nFoundation.Data\n, \nByteBuffer\n or \nString\n.\n\n\nThe result is \nData\n containing the resulting hash. The hash's length is according to spec and defined in the static variable \ndigestSize\n.\n\n\n// MD5 with `Data`\n\n\nlet\n \nfileData\n \n=\n \nData\n()\n\n\nlet\n \nfileMD5\n \n=\n \nMD5\n.\nhash\n(\nfileData\n)\n\n\n\n// SHA1 with `ByteBuffer`\n\n\nlet\n \nfileBuffer\n:\n \nByteBuffer\n \n=\n \n...\n\n\nlet\n \nfileSHA1\n \n=\n \nSHA1\n.\nhash\n(\nfileBuffer\n)\n\n\n\n// SHA2 variants with String\n\n\nlet\n \nstaticUnsafeToken\n:\n \nString\n \n=\n \nrsadd14ndmasidfm12i4j\n\n\n\nlet\n \ntokenHashSHA224\n \n=\n \nSHA224\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA256\n \n=\n \nSHA256\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA384\n \n=\n \nSHA384\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\nlet\n \ntokenHashSHA512\n \n=\n \nSHA512\n.\nhash\n(\nstaticUnsafeToken\n)\n\n\n\n\n\n\nIncremental hashes (manual)\n\n\nTo incrementally process hashes you can create an instance of the Hash. This will set up a context.\n\n\nAll hash context initializers are empty:\n\n\n// Create an MD5 context\n\n\nlet\n \nmd5Context\n \n=\n \nMD5\n()\n\n\n\n\n\n\nTo process a single chunk of data, you can call the \nupdate\n function on a context using any \nSequence\n of \nUInt8\n. That means \nArray\n, \nData\n and \nByteBuffer\n work alongside any other sequence of bytes.\n\n\nmd5Context\n.\nupdate\n(\ndata\n)\n\n\n\n\n\n\nThe data data need not be a specific length. Any length works.\n\n\nWhen you need the result, you can call \nmd5Context.finalize()\n. This will finish calculating the hash by appending the standard \n1\n bit, padding and message bitlength.\n\n\nYou can optionally provide a last set of data to \nfinalize()\n.\n\n\nAfter calling \nfinalize()\n, do not update the hash if you want correct results.\n\n\nFetching the results\n\n\nThe context can then be accessed to extract the resulting Hash.\n\n\nlet\n \nhash\n:\n \nData\n \n=\n \nmd5Context\n.\nhash\n\n\n\n\n\n\nStreaming hashes (Async)\n\n\nSometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use \nByteStreamHasher\n.\n\n\nFirst, create a new generic \nByteStreamHasher\nHash\n where \nHash\n is the hash you want to use. In this case, SHA512.\n\n\nlet\n \nstreamHasher\n \n=\n \nByteStreamHasher\nSHA512\n()\n\n\n\n\n\n\nThis stream works like any \ninputStream\n by consuming the incoming data and passing the buffers to the hash context.\n\n\nFor example, draining a TCP socket.\n\n\nlet\n \nsocket\n:\n \nTCP\n.\nSocket\n \n=\n \n...\n\n\n\nsocket\n.\ndrain\n(\ninto\n:\n \nstreamHasher\n)\n\n\n\n\n\n\nThis will incrementally update the hash using the provided TCP socket's data.\n\n\nWhen the hash has been completely accumulated, you can \ncomplete\n the hash.\n\n\nlet\n \nhash\n \n=\n \nstreamHasher\n.\ncomplete\n()\n \n// Foundation `Data`\n\n\n\n\n\n\nThis will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Hashes"
        }, 
        {
            "location": "/crypto/hash/#hash", 
            "text": "Hashes are a one-directional encryption that is commonly used for validating files or one-way securing data such as passwords.", 
            "title": "Hash"
        }, 
        {
            "location": "/crypto/hash/#available-hashes", 
            "text": "Crypto currently supports a few hashes.   MD5  SHA1  SHA2 (all variants)   MD5 and SHA1 are generally used for file validation or legacy (weak) passwords. They're performant and lightweight.  Every Hash type has a set of helpers that you can use.", 
            "title": "Available hashes"
        }, 
        {
            "location": "/crypto/hash/#hashing-blobs-of-data", 
            "text": "Every  Hash  has a static method called  hash  that can be used for hashing the entire contents of  Foundation.Data ,  ByteBuffer  or  String .  The result is  Data  containing the resulting hash. The hash's length is according to spec and defined in the static variable  digestSize .  // MD5 with `Data`  let   fileData   =   Data ()  let   fileMD5   =   MD5 . hash ( fileData )  // SHA1 with `ByteBuffer`  let   fileBuffer :   ByteBuffer   =   ...  let   fileSHA1   =   SHA1 . hash ( fileBuffer )  // SHA2 variants with String  let   staticUnsafeToken :   String   =   rsadd14ndmasidfm12i4j  let   tokenHashSHA224   =   SHA224 . hash ( staticUnsafeToken )  let   tokenHashSHA256   =   SHA256 . hash ( staticUnsafeToken )  let   tokenHashSHA384   =   SHA384 . hash ( staticUnsafeToken )  let   tokenHashSHA512   =   SHA512 . hash ( staticUnsafeToken )", 
            "title": "Hashing blobs of data"
        }, 
        {
            "location": "/crypto/hash/#incremental-hashes-manual", 
            "text": "To incrementally process hashes you can create an instance of the Hash. This will set up a context.  All hash context initializers are empty:  // Create an MD5 context  let   md5Context   =   MD5 ()   To process a single chunk of data, you can call the  update  function on a context using any  Sequence  of  UInt8 . That means  Array ,  Data  and  ByteBuffer  work alongside any other sequence of bytes.  md5Context . update ( data )   The data data need not be a specific length. Any length works.  When you need the result, you can call  md5Context.finalize() . This will finish calculating the hash by appending the standard  1  bit, padding and message bitlength.  You can optionally provide a last set of data to  finalize() .  After calling  finalize() , do not update the hash if you want correct results.", 
            "title": "Incremental hashes (manual)"
        }, 
        {
            "location": "/crypto/hash/#fetching-the-results", 
            "text": "The context can then be accessed to extract the resulting Hash.  let   hash :   Data   =   md5Context . hash", 
            "title": "Fetching the results"
        }, 
        {
            "location": "/crypto/hash/#streaming-hashes-async", 
            "text": "Sometimes you need to hash the contents of a Stream, for example, when processing a file transfer. In this case you can use  ByteStreamHasher .  First, create a new generic  ByteStreamHasher Hash  where  Hash  is the hash you want to use. In this case, SHA512.  let   streamHasher   =   ByteStreamHasher SHA512 ()   This stream works like any  inputStream  by consuming the incoming data and passing the buffers to the hash context.  For example, draining a TCP socket.  let   socket :   TCP . Socket   =   ...  socket . drain ( into :   streamHasher )   This will incrementally update the hash using the provided TCP socket's data.  When the hash has been completely accumulated, you can  complete  the hash.  let   hash   =   streamHasher . complete ()   // Foundation `Data`   This will reset the hash's context to the default configuration, ready to start over.", 
            "title": "Streaming hashes (Async)"
        }, 
        {
            "location": "/crypto/mac/", 
            "text": "Message authentication\n\n\nMessage authentication is used for verifying message authenticity and validity.\n\n\nCommon use cases are JSON Web Tokens.\n\n\nFor message authentication, Vapor only supports HMAC.\n\n\nUsing HMAC\n\n\nTo use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.\n\n\nlet\n \nhash\n \n=\n \nHMAC\nSHA224\n.\nauthenticate\n(\nmessage\n,\n \nwithKey\n:\n \nauthenticationKey\n)", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#message-authentication", 
            "text": "Message authentication is used for verifying message authenticity and validity.  Common use cases are JSON Web Tokens.  For message authentication, Vapor only supports HMAC.", 
            "title": "Message authentication"
        }, 
        {
            "location": "/crypto/mac/#using-hmac", 
            "text": "To use HMAC you first need to select the used hashing algorithm for authentication. This works using generics.  let   hash   =   HMAC SHA224 . authenticate ( message ,   withKey :   authenticationKey )", 
            "title": "Using HMAC"
        }, 
        {
            "location": "/crypto/passwords/", 
            "text": "Password hashing\n\n\nPassword management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.\n\n\nFor password hashing Vapor supports PBKDF2 and BCrypt.\n\n\nWe recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.\n\n\nBCrypt\n\n\nBCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.\n\n\nDeriving a key\n\n\nUnlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.\n\n\nThe output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.\n\n\nlet\n \nresult\n:\n \nData\n \n=\n \ntry\n \nBCrypt\n.\nmake\n(\nmessage\n:\n \nMyPassword\n)\n\n\n\nguard\n \ntry\n \nBCrypt\n.\nverify\n(\nmessage\n:\n \nMyPassword\n,\n \nmatches\n:\n \nresult\n)\n \nelse\n \n{\n\n    \nfatalError\n(\nThis never triggers, since the verification process will always be successful for the same password and conditions\n)\n\n\n}\n\n\n\n\n\n\nThe default cost factor is \n12\n, based on the official recommendations.\n\n\nStoring the derived key as a String\n\n\nBCrypt always outputs valid ASCII/UTF-8 for the resulting hash.\n\n\nThis means you can convert the output \nData\n to a \nString\n as such:\n\n\nguard\n \nlet\n \nstring\n \n=\n \nString\n(\nbytes\n:\n \nresult\n,\n \nencoding\n:\n \n.\nutf8\n)\n \nelse\n \n{\n\n    \n// This must never trigger\n\n\n}\n\n\n\n\n\n\nPBKDF2\n\n\nPBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.\n\n\nPBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.\n\n\nFor PBKDF2 you also select the Hash using generics.\n\n\nDeriving a key\n\n\nIn the following example:\n\n\n\n\npassword\n is either a \nString\n or \nData\n\n\nThe \nsalt\n is \nData\n\n\nIterations is defaulted to \n10_000\n iterations\n\n\nThe keySize is equivalent to 1 hash's length.\n\n\n\n\n// Generate a random salt\n\n\nlet\n \nsalt\n:\n \nData\n \n=\n \nOSRandom\n().\ndata\n(\ncount\n:\n \n32\n)\n\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n)\n\n\n\n\n\n\nYou can optionally configure PBKDF2 to use a different iteration count and output keysize.\n\n\n// Iterates 20\n000 times and outputs 100 bytes\n\n\nlet\n \nhash\n \n=\n \ntry\n \nPBKDF2\nSHA256\n.\nderive\n(\nfromPassword\n:\n \npassword\n,\n \nsalt\n:\n \nsalt\n,\n \niterating\n:\n \n20_000\n,\n \nderivedKeyLength\n:\n \n100\n)\n\n\n\n\n\n\nStoring the results\n\n\nWhen you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#password-hashing", 
            "text": "Password management is critical for good user security and doesn't need to cost a lot of effort. No software is perfect. Even if your software is perfect, other software on the same server likely isn't. Good password encryption security prevents users' passwords from leaking out in case of a hypothetical future data breach.  For password hashing Vapor supports PBKDF2 and BCrypt.  We recommend using BCrypt over PBKDF2 for almost all scenarios. Whilst PBKDF2 is a proven standard, it's much more easily brute-forced than BCrypt and is less future-proof.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/crypto/passwords/#bcrypt", 
            "text": "BCrypt is an algorithm specifically designed for password hashing. It's easy to store and verify.", 
            "title": "BCrypt"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key", 
            "text": "Unlike PBKDF2 you don't need to generate and store a salt, that's part of the BCrypt hashing and verification process.  The output is a combination of the BCrypt \"cost\" factor, salt and resulting hash. Meaning that the derived output contains all information necessary for verification, simplifying the database access.  let   result :   Data   =   try   BCrypt . make ( message :   MyPassword )  guard   try   BCrypt . verify ( message :   MyPassword ,   matches :   result )   else   { \n     fatalError ( This never triggers, since the verification process will always be successful for the same password and conditions )  }   The default cost factor is  12 , based on the official recommendations.", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-derived-key-as-a-string", 
            "text": "BCrypt always outputs valid ASCII/UTF-8 for the resulting hash.  This means you can convert the output  Data  to a  String  as such:  guard   let   string   =   String ( bytes :   result ,   encoding :   . utf8 )   else   { \n     // This must never trigger  }", 
            "title": "Storing the derived key as a String"
        }, 
        {
            "location": "/crypto/passwords/#pbkdf2", 
            "text": "PBKDF2 is an algorithm that is almost always (and in Vapor, exclusively) used with HMAC for message authentication.  PBKDF2 can be paired up with any hashing algorithm and is simple to implement. PBKDF2 is used all over the world through the WPA2 standard, securing WiFi connections. But we still recommend PBKDF2 above any normal hashing function.  For PBKDF2 you also select the Hash using generics.", 
            "title": "PBKDF2"
        }, 
        {
            "location": "/crypto/passwords/#deriving-a-key_1", 
            "text": "In the following example:   password  is either a  String  or  Data  The  salt  is  Data  Iterations is defaulted to  10_000  iterations  The keySize is equivalent to 1 hash's length.   // Generate a random salt  let   salt :   Data   =   OSRandom (). data ( count :   32 )  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt )   You can optionally configure PBKDF2 to use a different iteration count and output keysize.  // Iterates 20 000 times and outputs 100 bytes  let   hash   =   try   PBKDF2 SHA256 . derive ( fromPassword :   password ,   salt :   salt ,   iterating :   20_000 ,   derivedKeyLength :   100 )", 
            "title": "Deriving a key"
        }, 
        {
            "location": "/crypto/passwords/#storing-the-results", 
            "text": "When you're storing the PBKDF2 results, be sure to also store the Salt. Without the original salt, iteration count and other parameters you cannot reproduce the same hash for validation or authentication.", 
            "title": "Storing the results"
        }, 
        {
            "location": "/crypto/random/", 
            "text": "Random\n\n\nCrypto has two primary random number generators.\n\n\nOSRandom generates random numbers by calling the operating system's random number generator.\n\n\nURandom generates random numbers by reading from \n/dev/urandom\n.\n\n\nAccessing random numbers\n\n\nFirst, create an instance of the preferred random number generator:\n\n\nlet\n \nrandom\n \n=\n \nOSRandom\n()\n\n\n\n\n\n\nor\n\n\nlet\n \nrandom\n \n=\n \ntry\n \nURandom\n()\n\n\n\n\n\n\nReading integers\n\n\nFor every Swift integer a random number function exists.\n\n\nlet\n \nint8\n:\n \nInt8\n \n=\n \ntry\n \nrandom\n.\nmakeInt8\n()\n\n\nlet\n \nuint8\n:\n \nUInt8\n \n=\n \ntry\n \nrandom\n.\nmakeUInt8\n()\n\n\nlet\n \nint16\n:\n \nInt16\n \n=\n \ntry\n \nrandom\n.\nmakeInt16\n()\n\n\nlet\n \nuint16\n:\n \nUInt16\n \n=\n \ntry\n \nrandom\n.\nmakeUInt16\n()\n\n\nlet\n \nint32\n:\n \nInt32\n \n=\n \ntry\n \nrandom\n.\nmakeInt32\n()\n\n\nlet\n \nuint32\n:\n \nUInt32\n \n=\n \ntry\n \nrandom\n.\nmakeUInt32\n()\n\n\nlet\n \nint64\n:\n \nInt64\n \n=\n \ntry\n \nrandom\n.\nmakeInt64\n()\n\n\nlet\n \nuint64\n:\n \nUInt64\n \n=\n \ntry\n \nrandom\n.\nmakeUInt64\n()\n\n\nlet\n \nint\n:\n \nInt\n \n=\n \ntry\n \nrandom\n.\nmakeInt\n()\n\n\nlet\n \nuint\n:\n \nUInt\n \n=\n \ntry\n \nrandom\n.\nmakeUInt\n()\n\n\n\n\n\n\nReading random data\n\n\nRandom buffers of data are useful when, for example, generating tokens or other unique strings/blobs.\n\n\nTo generate a buffer of random data:\n\n\n// generates 20 random bytes\n\n\nlet\n \ndata\n:\n \nData\n \n=\n \nrandom\n.\ndata\n(\ncount\n:\n \n20\n)", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#random", 
            "text": "Crypto has two primary random number generators.  OSRandom generates random numbers by calling the operating system's random number generator.  URandom generates random numbers by reading from  /dev/urandom .", 
            "title": "Random"
        }, 
        {
            "location": "/crypto/random/#accessing-random-numbers", 
            "text": "First, create an instance of the preferred random number generator:  let   random   =   OSRandom ()   or  let   random   =   try   URandom ()", 
            "title": "Accessing random numbers"
        }, 
        {
            "location": "/crypto/random/#reading-integers", 
            "text": "For every Swift integer a random number function exists.  let   int8 :   Int8   =   try   random . makeInt8 ()  let   uint8 :   UInt8   =   try   random . makeUInt8 ()  let   int16 :   Int16   =   try   random . makeInt16 ()  let   uint16 :   UInt16   =   try   random . makeUInt16 ()  let   int32 :   Int32   =   try   random . makeInt32 ()  let   uint32 :   UInt32   =   try   random . makeUInt32 ()  let   int64 :   Int64   =   try   random . makeInt64 ()  let   uint64 :   UInt64   =   try   random . makeUInt64 ()  let   int :   Int   =   try   random . makeInt ()  let   uint :   UInt   =   try   random . makeUInt ()", 
            "title": "Reading integers"
        }, 
        {
            "location": "/crypto/random/#reading-random-data", 
            "text": "Random buffers of data are useful when, for example, generating tokens or other unique strings/blobs.  To generate a buffer of random data:  // generates 20 random bytes  let   data :   Data   =   random . data ( count :   20 )", 
            "title": "Reading random data"
        }, 
        {
            "location": "/version/1_5/", 
            "text": "Redirecting...", 
            "title": "1.5"
        }, 
        {
            "location": "/version/1_5/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/2_0/", 
            "text": "Redirecting...", 
            "title": "2.0"
        }, 
        {
            "location": "/version/2_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/3_0/", 
            "text": "Redirecting...", 
            "title": "3.0-alpha"
        }, 
        {
            "location": "/version/3_0/#redirecting", 
            "text": "", 
            "title": "Redirecting..."
        }, 
        {
            "location": "/version/support/", 
            "text": "Version Support\n\n\n\n\nVapor 3.0 is currently in beta.\n\n\nVapor 2.0 is currently active.\n\n\nVapor 1.5 is being maintained until November 2017.\n\n\n\n\nWarning\n\n\nDashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.\n\n\n\n\nCore\n\n\nAll packages in the \nVapor GitHub\n are maintained according to the following rules.\n\n\nActive\n\n\nWhile a version is active, reported security issues and bugs are fixed.\n\n\nAdditionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.\n\n\nMaintenance\n\n\nWhen a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.\n\n\n\n\nNote\n\n\nOnly the latest minor version will be maintained.\n\n\n\n\nUnstable\n\n\nThe master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.\n\n\nCommunity\n\n\nAll packages in the \nVapor Community GitHub\n are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Support"
        }, 
        {
            "location": "/version/support/#version-support", 
            "text": "Vapor 3.0 is currently in beta.  Vapor 2.0 is currently active.  Vapor 1.5 is being maintained until November 2017.   Warning  Dashed blocks and lines represent the team's goals and are not yet guaranteed. \nVapor 3's release and the beginning of Vapor 2's maintenance phase have not yet been decided.", 
            "title": "Version Support"
        }, 
        {
            "location": "/version/support/#core", 
            "text": "All packages in the  Vapor GitHub  are maintained according to the following rules.", 
            "title": "Core"
        }, 
        {
            "location": "/version/support/#active", 
            "text": "While a version is active, reported security issues and bugs are fixed.  Additionally, new features and optimizations may be added. If new API is added, the minor version number will be incremented. At no point can existing API be removed or broken during an active version. Semver is strictly followed and tested.", 
            "title": "Active"
        }, 
        {
            "location": "/version/support/#maintenance", 
            "text": "When a new version of Vapor is released, the previous version will enter a maintenance phase which lasts for six months. During this phase, critical security issues and bugs will be fixed. No new features will be added.   Note  Only the latest minor version will be maintained.", 
            "title": "Maintenance"
        }, 
        {
            "location": "/version/support/#unstable", 
            "text": "The master branch is the latest development version of Vapor and is constantly changing. Before a new version of Vapor is released, there may be unstable alpha and beta phases in which you are welcome to test and provide feedback on the changes.", 
            "title": "Unstable"
        }, 
        {
            "location": "/version/support/#community", 
            "text": "All packages in the  Vapor Community GitHub  are maintained in strict accordance of semver. Violations of semver should be reported as issues to the offending package's GitHub page.", 
            "title": "Community"
        }
    ]
}